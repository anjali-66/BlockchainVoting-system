{"ast":null,"code":"import { sleep } from \"../../../../../utils/sleep.js\";\nconst iframeBaseStyle = {\n  height: \"100%\",\n  width: \"100%\",\n  border: \"none\",\n  backgroundColor: \"transparent\",\n  colorScheme: \"light\",\n  position: \"fixed\",\n  top: \"0px\",\n  right: \"0px\",\n  zIndex: \"2147483646\",\n  display: \"none\",\n  pointerEvents: \"all\"\n};\n// Global var to help track iframe state\nconst isIframeLoaded = new Map();\n/**\n * @internal\n */\n// biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\nexport class IframeCommunicator {\n  /**\n   * @internal\n   */\n  constructor({\n    link,\n    baseUrl,\n    iframeId,\n    container = document.body,\n    onIframeInitialize,\n    localStorage,\n    clientId,\n    ecosystem\n  }) {\n    Object.defineProperty(this, \"iframe\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"POLLING_INTERVAL_SECONDS\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1.4\n    });\n    Object.defineProperty(this, \"iframeBaseUrl\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"localStorage\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"clientId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"ecosystem\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.localStorage = localStorage;\n    this.clientId = clientId;\n    this.ecosystem = ecosystem;\n    this.iframeBaseUrl = baseUrl;\n    // Creating the IFrame element for communication\n    let iframe = document.getElementById(iframeId);\n    const hrefLink = new URL(link);\n    // TODO (ew) - bring back version tracking\n    // const sdkVersion = process.env.THIRDWEB_EWS_SDK_VERSION;\n    // if (!sdkVersion) {\n    //   throw new Error(\"Missing THIRDWEB_EWS_SDK_VERSION env var\");\n    // }\n    // hrefLink.searchParams.set(\"sdkVersion\", sdkVersion);\n    if (!iframe || iframe.src !== hrefLink.href) {\n      // ! Do not update the hrefLink here or it'll cause multiple re-renders\n      iframe = document.createElement(\"iframe\");\n      const mergedIframeStyles = {\n        ...iframeBaseStyle\n      };\n      Object.assign(iframe.style, mergedIframeStyles);\n      iframe.setAttribute(\"id\", iframeId);\n      iframe.setAttribute(\"fetchpriority\", \"high\");\n      container.appendChild(iframe);\n      iframe.src = hrefLink.href;\n      // iframe.setAttribute(\"data-version\", sdkVersion);\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n      const onIframeLoaded = event => {\n        if (event.data.eventType === \"ewsIframeLoaded\") {\n          window.removeEventListener(\"message\", onIframeLoaded);\n          if (!iframe) {\n            console.warn(\"thirdweb iFrame not found\");\n            return;\n          }\n          this.onIframeLoadHandler(iframe, onIframeInitialize)();\n        }\n      };\n      window.addEventListener(\"message\", onIframeLoaded);\n    }\n    this.iframe = iframe;\n  }\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n  async onIframeLoadedInitVariables() {\n    return {\n      authCookie: await this.localStorage.getAuthCookie(),\n      deviceShareStored: await this.localStorage.getDeviceShare(),\n      walletUserId: await this.localStorage.getWalletUserId(),\n      clientId: this.clientId,\n      partnerId: this.ecosystem?.partnerId,\n      ecosystemId: this.ecosystem?.id\n    };\n  }\n  /**\n   * @internal\n   */\n  onIframeLoadHandler(iframe, onIframeInitialize) {\n    return async () => {\n      const channel = new MessageChannel();\n      const promise = new Promise((res, rej) => {\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n        channel.port1.onmessage = event => {\n          const {\n            data\n          } = event;\n          channel.port1.close();\n          if (!data.success) {\n            rej(new Error(data.error));\n          }\n          isIframeLoaded.set(iframe.src, true);\n          if (onIframeInitialize) {\n            onIframeInitialize();\n          }\n          res(true);\n        };\n      });\n      iframe?.contentWindow?.postMessage({\n        eventType: \"initIframe\",\n        data: await this.onIframeLoadedInitVariables()\n      }, this.iframeBaseUrl, [channel.port2]);\n      await promise;\n    };\n  }\n  /**\n   * @internal\n   */\n  async call({\n    procedureName,\n    params,\n    showIframe = false\n  }) {\n    while (!isIframeLoaded.get(this.iframe.src)) {\n      await sleep(this.POLLING_INTERVAL_SECONDS * 1000);\n    }\n    if (showIframe) {\n      this.iframe.style.display = \"block\";\n      // magic number to let the display render before performing the animation of the modal in\n      await sleep(0.005 * 1000);\n    }\n    const channel = new MessageChannel();\n    const promise = new Promise((res, rej) => {\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n      channel.port1.onmessage = async event => {\n        const {\n          data\n        } = event;\n        channel.port1.close();\n        if (showIframe) {\n          // magic number to let modal fade out before hiding it\n          await sleep(0.1 * 1000);\n          this.iframe.style.display = \"none\";\n        }\n        if (!data.success) {\n          rej(new Error(data.error));\n        } else {\n          res(data.data);\n        }\n      };\n    });\n    this.iframe.contentWindow?.postMessage({\n      eventType: procedureName,\n      // Pass the initialization data on every request in case the iframe storage was reset (can happen in some environments such as iOS PWAs)\n      data: {\n        ...params,\n        ...(await this.onIframeLoadedInitVariables())\n      }\n    }, this.iframeBaseUrl, [channel.port2]);\n    return promise;\n  }\n  /**\n   * This has to be called by any iframe that will be removed from the DOM.\n   * Use to make sure that we reset the global loaded state of the particular iframe.src\n   * @internal\n   */\n  destroy() {\n    isIframeLoaded.delete(this.iframe.src);\n  }\n}\n//# sourceMappingURL=IframeCommunicator.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}