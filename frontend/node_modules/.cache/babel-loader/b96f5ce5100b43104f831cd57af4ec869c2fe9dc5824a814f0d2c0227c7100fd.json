{"ast":null,"code":"import * as ox__Hex from \"ox/Hex\";\nimport * as ox__Signature from \"ox/Signature\";\nimport * as ox__TransactionEnvelopeEip1559 from \"ox/TransactionEnvelopeEip1559\";\nimport * as ox__TransactionEnvelopeEip2930 from \"ox/TransactionEnvelopeEip2930\";\nimport * as ox__TransactionEnvelopeLegacy from \"ox/TransactionEnvelopeLegacy\";\n/**\n * Serializes a legacy, EIP-1559, EIP-2930, EIP-4844, or EIP-7702 transaction object.\n *\n * @param options - The serialization options.\n * @param options.transaction - The transaction object to be serialized.\n * @param [options.signature] - The signature to include with the transaction, if necessary.\n * @returns The serialized transaction.\n * @throws An error if the provided transaction object is invalid.\n * @transaction\n * @example\n * ```ts\n * import { serializeTransaction } from \"thirdweb\";\n *\n * const serializedTransaction = serializeTransaction({ transaction: {\n *    to: \"0x\",\n *    value: 0n,\n *  }\n * });\n * ```\n */\nexport function serializeTransaction(options) {\n  const {\n    transaction\n  } = options;\n  const type = getTransactionEnvelopeType(transaction);\n  // This is to maintain compatibility with our old interface (including the signature in the transaction object)\n  const signature = (() => {\n    if (options.signature) {\n      if (\"v\" in options.signature && typeof options.signature.v !== \"undefined\") {\n        return ox__Signature.fromLegacy({\n          r: ox__Hex.toBigInt(options.signature.r),\n          s: ox__Hex.toBigInt(options.signature.s),\n          v: Number(options.signature.v)\n        });\n      }\n      return {\n        r: ox__Hex.toBigInt(options.signature.r),\n        s: ox__Hex.toBigInt(options.signature.s),\n        // We force the Signature type here because we filter for legacy type above\n        yParity: options.signature.yParity\n      };\n    }\n    if (typeof transaction.v === \"undefined\" && typeof transaction.yParity === \"undefined\") {\n      return undefined;\n    }\n    if (transaction.r === undefined || transaction.s === undefined) {\n      throw new Error(\"Invalid signature provided with transaction\");\n    }\n    return {\n      r: typeof transaction.r === \"bigint\" ? transaction.r : ox__Hex.toBigInt(transaction.r),\n      s: typeof transaction.s === \"bigint\" ? transaction.s : ox__Hex.toBigInt(transaction.s),\n      yParity: typeof transaction.v !== \"undefined\" && typeof transaction.yParity === \"undefined\" ? ox__Signature.vToYParity(Number(transaction.v)) : Number(transaction.yParity)\n    };\n  })();\n  if (type === \"eip1559\") {\n    const typedTransaction = transaction;\n    ox__TransactionEnvelopeEip1559.assert(typedTransaction);\n    return ox__TransactionEnvelopeEip1559.serialize(typedTransaction, {\n      signature\n    });\n  }\n  if (type === \"legacy\") {\n    const typedTransaction = transaction;\n    ox__TransactionEnvelopeLegacy.assert(typedTransaction);\n    return ox__TransactionEnvelopeLegacy.serialize(typedTransaction, {\n      signature\n    });\n  }\n  if (type === \"eip2930\") {\n    const typedTransaction = transaction;\n    ox__TransactionEnvelopeEip2930.assert(typedTransaction);\n    return ox__TransactionEnvelopeEip2930.serialize(typedTransaction, {\n      signature\n    });\n  }\n  throw new Error(\"Invalid transaction type\");\n}\n/**\n * @internal\n */\nfunction getTransactionEnvelopeType(transactionEnvelope) {\n  if (typeof transactionEnvelope.type !== \"undefined\") {\n    return transactionEnvelope.type;\n  }\n  if (typeof transactionEnvelope.maxFeePerGas !== \"undefined\" || typeof transactionEnvelope.maxPriorityFeePerGas !== \"undefined\") {\n    return \"eip1559\";\n  }\n  if (typeof transactionEnvelope.gasPrice !== \"undefined\") {\n    if (typeof transactionEnvelope.accessList !== \"undefined\") {\n      return \"eip2930\";\n    }\n    return \"legacy\";\n  }\n  throw new Error(\"Invalid transaction type\");\n}\n//# sourceMappingURL=serialize-transaction.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}