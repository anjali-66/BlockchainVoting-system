{"ast":null,"code":"import * as AccessList from './AccessList.js';\nimport * as Address from './Address.js';\nimport * as Authorization from './Authorization.js';\nimport * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\nimport * as Rlp from './Rlp.js';\nimport * as Signature from './Signature.js';\nimport * as TransactionEnvelope from './TransactionEnvelope.js';\nimport * as TransactionEnvelopeEip1559 from './TransactionEnvelopeEip1559.js';\nexport const serializedType = '0x04';\nexport const type = 'eip7702';\n/**\n * Asserts a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * TransactionEnvelopeEip7702.assert({\n *   authorizationList: [],\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: FeeCapTooHighError:\n * // @error: The fee cap (`masFeePerGas` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nexport function assert(envelope) {\n  const {\n    authorizationList\n  } = envelope;\n  if (authorizationList) {\n    for (const authorization of authorizationList) {\n      const {\n        address,\n        chainId\n      } = authorization;\n      if (address) Address.assert(address, {\n        strict: false\n      });\n      if (Number(chainId) < 0) throw new TransactionEnvelope.InvalidChainIdError({\n        chainId\n      });\n    }\n  }\n  TransactionEnvelopeEip1559.assert(envelope);\n}\n/**\n * Deserializes a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.deserialize('0x04ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   type: 'eip7702',\n * // @log:   nonce: 785n,\n * // @log:   maxFeePerGas: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nexport function deserialize(serialized) {\n  const transactionArray = Rlp.toHex(Hex.slice(serialized, 1));\n  const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, authorizationList, yParity, r, s] = transactionArray;\n  if (!(transactionArray.length === 10 || transactionArray.length === 13)) throw new TransactionEnvelope.InvalidSerializedError({\n    attributes: {\n      chainId,\n      nonce,\n      maxPriorityFeePerGas,\n      maxFeePerGas,\n      gas,\n      to,\n      value,\n      data,\n      accessList,\n      authorizationList,\n      ...(transactionArray.length > 9 ? {\n        yParity,\n        r,\n        s\n      } : {})\n    },\n    serialized,\n    type\n  });\n  let transaction = {\n    chainId: Number(chainId),\n    type\n  };\n  if (Hex.validate(to) && to !== '0x') transaction.to = to;\n  if (Hex.validate(gas) && gas !== '0x') transaction.gas = BigInt(gas);\n  if (Hex.validate(data) && data !== '0x') transaction.data = data;\n  if (Hex.validate(nonce) && nonce !== '0x') transaction.nonce = BigInt(nonce);\n  if (Hex.validate(value) && value !== '0x') transaction.value = BigInt(value);\n  if (Hex.validate(maxFeePerGas) && maxFeePerGas !== '0x') transaction.maxFeePerGas = BigInt(maxFeePerGas);\n  if (Hex.validate(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x') transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);\n  if (accessList.length !== 0 && accessList !== '0x') transaction.accessList = AccessList.fromTupleList(accessList);\n  if (authorizationList !== '0x') transaction.authorizationList = Authorization.fromTupleList(authorizationList);\n  const signature = r && s && yParity ? Signature.fromTuple([yParity, r, s]) : undefined;\n  if (signature) transaction = {\n    ...transaction,\n    ...signature\n  };\n  assert(transaction);\n  return transaction;\n}\n/**\n * Converts an arbitrary transaction object into an EIP-7702 Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * import { Authorization, Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   chainId: 1,\n *   nonce: 0n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorizationList = [Authorization.from(authorization, { signature })]\n *\n * const envelope = TransactionEnvelopeEip7702.from({ // [!code focus]\n *   authorizationList, // [!code focus]\n *   chainId: 1, // [!code focus]\n *   maxFeePerGas: Value.fromGwei('10'), // [!code focus]\n *   maxPriorityFeePerGas: Value.fromGwei('1'), // [!code focus]\n *   to: '0x0000000000000000000000000000000000000000', // [!code focus]\n *   value: Value.fromEther('1'), // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip7702.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip7702',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an EIP-7702 Transaction Envelope from a {@link ox#TransactionEnvelopeEip7702.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from('0x04f858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip7702',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns An EIP-7702 Transaction Envelope.\n */\nexport function from(envelope, options = {}) {\n  const {\n    signature\n  } = options;\n  const envelope_ = typeof envelope === 'string' ? deserialize(envelope) : envelope;\n  assert(envelope_);\n  return {\n    ...envelope_,\n    ...(signature ? Signature.from(signature) : {}),\n    type: 'eip7702'\n  };\n}\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeEip7702.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nexport function getSignPayload(envelope) {\n  return hash(envelope, {\n    presign: true\n  });\n}\n/**\n * Hashes a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip7702.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeEip7702.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The EIP-7702 Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nexport function hash(envelope, options = {}) {\n  const {\n    presign\n  } = options;\n  return Hash.keccak256(serialize({\n    ...envelope,\n    ...(presign ? {\n      r: undefined,\n      s: undefined,\n      yParity: undefined\n    } : {})\n  }));\n}\n/**\n * Serializes a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Authorization, Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   chainId: 1,\n *   nonce: 0n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorizationList = [Authorization.from(authorization, { signature })]\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList,\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip7702.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeEip7702.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nexport function serialize(envelope, options = {}) {\n  const {\n    authorizationList,\n    chainId,\n    gas,\n    nonce,\n    to,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    accessList,\n    data,\n    input\n  } = envelope;\n  assert(envelope);\n  const accessTupleList = AccessList.toTupleList(accessList);\n  const authorizationTupleList = Authorization.toTupleList(authorizationList);\n  const signature = Signature.extract(options.signature || envelope);\n  const serialized = [Hex.fromNumber(chainId), nonce ? Hex.fromNumber(nonce) : '0x', maxPriorityFeePerGas ? Hex.fromNumber(maxPriorityFeePerGas) : '0x', maxFeePerGas ? Hex.fromNumber(maxFeePerGas) : '0x', gas ? Hex.fromNumber(gas) : '0x', to ?? '0x', value ? Hex.fromNumber(value) : '0x', data ?? input ?? '0x', accessTupleList, authorizationTupleList, ...(signature ? Signature.toTuple(signature) : [])];\n  return Hex.concat(serializedType, Rlp.fromHex(serialized));\n}\n/**\n * Validates a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeEip7702.validate({\n *   authorizationList: [],\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nexport function validate(envelope) {\n  try {\n    assert(envelope);\n    return true;\n  } catch {\n    return false;\n  }\n}\n//# sourceMappingURL=TransactionEnvelopeEip7702.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}