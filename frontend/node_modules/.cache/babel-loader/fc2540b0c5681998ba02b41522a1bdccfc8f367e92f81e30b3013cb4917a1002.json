{"ast":null,"code":"import { bls12_381 as bls } from '@noble/curves/bls12-381';\nimport * as Bytes from './Bytes.js';\nimport * as Hex from './Hex.js';\n/** Re-export of noble/curves BLS12-381 utilities. */\nexport const noble = bls;\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function aggregate(points) {\n  const group = typeof points[0]?.x === 'bigint' ? bls.G1 : bls.G2;\n  const point = points.reduce((acc, point) => acc.add(new group.ProjectivePoint(point.x, point.y, point.z)), group.ProjectivePoint.ZERO);\n  return {\n    x: point.px,\n    y: point.py,\n    z: point.pz\n  };\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function getPublicKey(options) {\n  const {\n    privateKey,\n    size = 'short-key:long-sig'\n  } = options;\n  const group = size === 'short-key:long-sig' ? bls.G1 : bls.G2;\n  const {\n    px,\n    py,\n    pz\n  } = group.ProjectivePoint.fromPrivateKey(Hex.from(privateKey).slice(2));\n  return {\n    x: px,\n    y: py,\n    z: pz\n  };\n}\n/**\n * Generates a random BLS12-381 private key.\n *\n * @example\n * ```ts twoslash\n * import { Bls } from 'ox'\n *\n * const privateKey = Bls.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nexport function randomPrivateKey(options = {}) {\n  const {\n    as = 'Hex'\n  } = options;\n  const bytes = bls.utils.randomPrivateKey();\n  if (as === 'Hex') return Hex.fromBytes(bytes);\n  return bytes;\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function sign(options) {\n  const {\n    payload,\n    privateKey,\n    suite,\n    size = 'short-key:long-sig'\n  } = options;\n  const payloadGroup = size === 'short-key:long-sig' ? bls.G2 : bls.G1;\n  const payloadPoint = payloadGroup.hashToCurve(Bytes.from(payload), suite ? {\n    DST: Bytes.fromString(suite)\n  } : undefined);\n  const privateKeyGroup = size === 'short-key:long-sig' ? bls.G1 : bls.G2;\n  const signature = payloadPoint.multiply(privateKeyGroup.normPrivateKeyToScalar(privateKey.slice(2)));\n  return {\n    x: signature.px,\n    y: signature.py,\n    z: signature.pz\n  };\n}\n/**\n * Verifies a payload was signed by the provided public key(s).\n *\n * @example\n *\n * ```ts twoslash\n * import { Bls, Hex } from 'ox'\n *\n * const payload = Hex.random(32)\n * const privateKey = Bls.randomPrivateKey()\n *\n * const publicKey = Bls.getPublicKey({ privateKey })\n * const signature = Bls.sign({ payload, privateKey })\n *\n * const verified = Bls.verify({ // [!code focus]\n *   payload, // [!code focus]\n *   publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Verify Aggregated Signatures\n *\n * We can also pass a public key and signature that was aggregated with {@link ox#Bls.(aggregate:function)} to `Bls.verify`.\n *\n * ```ts twoslash\n * import { Bls, Hex } from 'ox'\n *\n * const payload = Hex.random(32)\n * const privateKeys = Array.from({ length: 100 }, () => Bls.randomPrivateKey())\n *\n * const publicKeys = privateKeys.map((privateKey) =>\n *   Bls.getPublicKey({ privateKey }),\n * )\n * const signatures = privateKeys.map((privateKey) =>\n *   Bls.sign({ payload, privateKey }),\n * )\n *\n * const publicKey = Bls.aggregate(publicKeys) // [!code focus]\n * const signature = Bls.aggregate(signatures) // [!code focus]\n *\n * const valid = Bls.verify({ payload, publicKey, signature }) // [!code focus]\n * ```\n *\n * @param options - Verification options.\n * @returns Whether the payload was signed by the provided public key.\n */\nexport function verify(options) {\n  const {\n    payload,\n    suite\n  } = options;\n  const publicKey = options.publicKey;\n  const signature = options.signature;\n  const isShortSig = typeof signature.x === 'bigint';\n  const group = isShortSig ? bls.G1 : bls.G2;\n  const payloadPoint = group.hashToCurve(Bytes.from(payload), suite ? {\n    DST: Bytes.fromString(suite)\n  } : undefined);\n  const shortSigPairing = () => bls.pairingBatch([{\n    g1: payloadPoint,\n    g2: new bls.G2.ProjectivePoint(publicKey.x, publicKey.y, publicKey.z)\n  }, {\n    g1: new bls.G1.ProjectivePoint(signature.x, signature.y, signature.z),\n    g2: bls.G2.ProjectivePoint.BASE.negate()\n  }]);\n  const longSigPairing = () => bls.pairingBatch([{\n    g1: new bls.G1.ProjectivePoint(publicKey.x, publicKey.y, publicKey.z).negate(),\n    g2: payloadPoint\n  }, {\n    g1: bls.G1.ProjectivePoint.BASE,\n    g2: new bls.G2.ProjectivePoint(signature.x, signature.y, signature.z)\n  }]);\n  return bls.fields.Fp12.eql(isShortSig ? shortSigPairing() : longSigPairing(), bls.fields.Fp12.ONE);\n}\n//# sourceMappingURL=Bls.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}