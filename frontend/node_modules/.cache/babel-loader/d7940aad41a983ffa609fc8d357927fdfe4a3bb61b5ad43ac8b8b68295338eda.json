{"ast":null,"code":"\"use client\";\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { getFunctionId } from \"../../../../../utils/function-id.js\";\nimport { useNFTContext } from \"./provider.js\";\nimport { getNFTInfo } from \"./utils.js\";\n/**\n * This component fetches and displays an NFT's description. It inherits all the attributes of a <span>\n * so you can style it just like how you would style a <span> element.\n * @returns A <span> element containing the description of the NFT\n *\n * @example\n * ### Basic usage\n * ```tsx\n * import { NFTProvider, NFTDescription } from \"thirdweb/react\";\n *\n * <NFTProvider>\n *   <NFTDescription />\n * </NFTProvider>\n * ```\n *\n * ### Show a loading sign while the description is being fetched\n * ```tsx\n * import { NFTProvider, NFTDescription } from \"thirdweb/react\";\n *\n * <NFTProvider>\n *   <NFTDescription loadingComponent={<YourLoadingSign />} />\n * </NFTProvider>\n * ```\n *\n * ### Show something in case the description failed to resolve\n * ```tsx\n * import { NFTProvider, NFTDescription } from \"thirdweb/react\";\n *\n * <NFTProvider>\n *   <NFTDescription fallbackComponent={<span>Failed to load description</span>} />\n * </NFTProvider>\n * ```\n *\n * ### Custom query options for useQuery (tanstack-query)\n * ```tsx\n * import { NFTProvider, NFTDescription } from \"thirdweb/react\";\n *\n * <NFTProvider>\n *   <NFTDescription queryOptions={{ retry: 3, enabled: false, }} />\n * </NFTProvider>\n * ```\n *\n * ### Override the description with the `descriptionResolver` prop\n * If you already have the url, you can skip the network requests and pass it directly to the NFTDescription\n * ```tsx\n * <NFTDescription descriptionResolver=\"The desc of the NFT\" />\n * ```\n *\n * You can also pass in your own custom (async) function that retrieves the description\n * ```tsx\n * const getDescription = async () => {\n *   // ...\n *   return description;\n * };\n *\n * <NFTDescription descriptionResolver={getDescription} />\n * ```\n * @component\n * @nft\n * @beta\n */\nexport function NFTDescription({\n  loadingComponent,\n  fallbackComponent,\n  queryOptions,\n  descriptionResolver,\n  ...restProps\n}) {\n  const {\n    contract,\n    tokenId\n  } = useNFTContext();\n  const descQuery = useQuery({\n    queryKey: [\"_internal_nft_description_\", contract.chain.id, tokenId.toString(), {\n      resolver: typeof descriptionResolver === \"string\" ? descriptionResolver : typeof descriptionResolver === \"function\" ? getFunctionId(descriptionResolver) : undefined\n    }],\n    queryFn: async () => fetchNftDescription({\n      descriptionResolver,\n      contract,\n      tokenId\n    }),\n    ...queryOptions\n  });\n  if (descQuery.isLoading) {\n    return loadingComponent || null;\n  }\n  if (!descQuery.data) {\n    return fallbackComponent || null;\n  }\n  return _jsx(\"span\", {\n    ...restProps,\n    children: descQuery.data\n  });\n}\n/**\n * @internal Exported for tests\n */\nexport async function fetchNftDescription(props) {\n  const {\n    descriptionResolver,\n    contract,\n    tokenId\n  } = props;\n  if (typeof descriptionResolver === \"string\") {\n    return descriptionResolver;\n  }\n  if (typeof descriptionResolver === \"function\") {\n    return descriptionResolver();\n  }\n  const nft = await getNFTInfo({\n    contract,\n    tokenId\n  }).catch(() => undefined);\n  if (!nft) {\n    throw new Error(\"Failed to resolve NFT info\");\n  }\n  if (typeof nft.metadata.description !== \"string\") {\n    throw new Error(\"Failed to resolve NFT description\");\n  }\n  return nft.metadata.description;\n}\n//# sourceMappingURL=description.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}