{"ast":null,"code":"import { EventEmitter as P } from \"events\";\nimport { getAccountsFromNamespaces as _, getSdkError as A, isValidArray as f } from \"@walletconnect/utils\";\nimport { UniversalProvider as S } from \"@walletconnect/universal-provider\";\nconst R = \"wc\",\n  T = \"ethereum_provider\",\n  $ = `${R}@2:${T}:`,\n  j = \"https://rpc.walletconnect.org/v1/\",\n  g = [\"eth_sendTransaction\", \"personal_sign\"],\n  y = [\"eth_accounts\", \"eth_requestAccounts\", \"eth_sendRawTransaction\", \"eth_sign\", \"eth_signTransaction\", \"eth_signTypedData\", \"eth_signTypedData_v3\", \"eth_signTypedData_v4\", \"eth_sendTransaction\", \"personal_sign\", \"wallet_switchEthereumChain\", \"wallet_addEthereumChain\", \"wallet_getPermissions\", \"wallet_requestPermissions\", \"wallet_registerOnboarding\", \"wallet_watchAsset\", \"wallet_scanQRCode\", \"wallet_sendCalls\", \"wallet_getCapabilities\", \"wallet_getCallsStatus\", \"wallet_showCallsStatus\"],\n  u = [\"chainChanged\", \"accountsChanged\"],\n  b = [\"chainChanged\", \"accountsChanged\", \"message\", \"disconnect\", \"connect\"];\nvar q = Object.defineProperty,\n  N = Object.defineProperties,\n  D = Object.getOwnPropertyDescriptors,\n  M = Object.getOwnPropertySymbols,\n  U = Object.prototype.hasOwnProperty,\n  Q = Object.prototype.propertyIsEnumerable,\n  O = (r, t, s) => t in r ? q(r, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: s\n  }) : r[t] = s,\n  p = (r, t) => {\n    for (var s in t || (t = {})) U.call(t, s) && O(r, s, t[s]);\n    if (M) for (var s of M(t)) Q.call(t, s) && O(r, s, t[s]);\n    return r;\n  },\n  E = (r, t) => N(r, D(t));\nfunction m(r) {\n  return Number(r[0].split(\":\")[1]);\n}\nfunction v(r) {\n  return `0x${r.toString(16)}`;\n}\nfunction L(r) {\n  const {\n    chains: t,\n    optionalChains: s,\n    methods: i,\n    optionalMethods: e,\n    events: n,\n    optionalEvents: o,\n    rpcMap: c\n  } = r;\n  if (!f(t)) throw new Error(\"Invalid chains\");\n  const a = {\n      chains: t,\n      methods: i || g,\n      events: n || u,\n      rpcMap: p({}, t.length ? {\n        [m(t)]: c[m(t)]\n      } : {})\n    },\n    h = n?.filter(l => !u.includes(l)),\n    d = i?.filter(l => !g.includes(l));\n  if (!s && !o && !e && !(h != null && h.length) && !(d != null && d.length)) return {\n    required: t.length ? a : void 0\n  };\n  const w = h?.length && d?.length || !s,\n    I = {\n      chains: [...new Set(w ? a.chains.concat(s || []) : s)],\n      methods: [...new Set(a.methods.concat(e != null && e.length ? e : y))],\n      events: [...new Set(a.events.concat(o != null && o.length ? o : b))],\n      rpcMap: c\n    };\n  return {\n    required: t.length ? a : void 0,\n    optional: s.length ? I : void 0\n  };\n}\nclass C {\n  constructor() {\n    this.events = new P(), this.namespace = \"eip155\", this.accounts = [], this.chainId = 1, this.STORAGE_KEY = $, this.on = (t, s) => (this.events.on(t, s), this), this.once = (t, s) => (this.events.once(t, s), this), this.removeListener = (t, s) => (this.events.removeListener(t, s), this), this.off = (t, s) => (this.events.off(t, s), this), this.parseAccount = t => this.isCompatibleChainId(t) ? this.parseAccountId(t).address : t, this.signer = {}, this.rpc = {};\n  }\n  static async init(t) {\n    const s = new C();\n    return await s.initialize(t), s;\n  }\n  async request(t, s) {\n    return await this.signer.request(t, this.formatChainId(this.chainId), s);\n  }\n  sendAsync(t, s, i) {\n    this.signer.sendAsync(t, s, this.formatChainId(this.chainId), i);\n  }\n  get connected() {\n    return this.signer.client ? this.signer.client.core.relayer.connected : !1;\n  }\n  get connecting() {\n    return this.signer.client ? this.signer.client.core.relayer.connecting : !1;\n  }\n  async enable() {\n    return this.session || (await this.connect()), await this.request({\n      method: \"eth_requestAccounts\"\n    });\n  }\n  async connect(t) {\n    if (!this.signer.client) throw new Error(\"Provider not initialized. Call init() first\");\n    this.loadConnectOpts(t);\n    const {\n      required: s,\n      optional: i\n    } = L(this.rpc);\n    try {\n      const e = await new Promise(async (o, c) => {\n        var a;\n        this.rpc.showQrModal && ((a = this.modal) == null || a.subscribeModal(h => {\n          !h.open && !this.signer.session && (this.signer.abortPairingAttempt(), c(new Error(\"Connection request reset. Please try again.\")));\n        })), await this.signer.connect(E(p({\n          namespaces: p({}, s && {\n            [this.namespace]: s\n          })\n        }, i && {\n          optionalNamespaces: {\n            [this.namespace]: i\n          }\n        }), {\n          pairingTopic: t?.pairingTopic\n        })).then(h => {\n          o(h);\n        }).catch(h => {\n          c(new Error(h.message));\n        });\n      });\n      if (!e) return;\n      const n = _(e.namespaces, [this.namespace]);\n      this.setChainIds(this.rpc.chains.length ? this.rpc.chains : n), this.setAccounts(n), this.events.emit(\"connect\", {\n        chainId: v(this.chainId)\n      });\n    } catch (e) {\n      throw this.signer.logger.error(e), e;\n    } finally {\n      this.modal && this.modal.closeModal();\n    }\n  }\n  async authenticate(t, s) {\n    if (!this.signer.client) throw new Error(\"Provider not initialized. Call init() first\");\n    this.loadConnectOpts({\n      chains: t?.chains\n    });\n    try {\n      const i = await new Promise(async (n, o) => {\n          var c;\n          this.rpc.showQrModal && ((c = this.modal) == null || c.subscribeModal(a => {\n            !a.open && !this.signer.session && (this.signer.abortPairingAttempt(), o(new Error(\"Connection request reset. Please try again.\")));\n          })), await this.signer.authenticate(E(p({}, t), {\n            chains: this.rpc.chains\n          }), s).then(a => {\n            n(a);\n          }).catch(a => {\n            o(new Error(a.message));\n          });\n        }),\n        e = i.session;\n      if (e) {\n        const n = _(e.namespaces, [this.namespace]);\n        this.setChainIds(this.rpc.chains.length ? this.rpc.chains : n), this.setAccounts(n), this.events.emit(\"connect\", {\n          chainId: v(this.chainId)\n        });\n      }\n      return i;\n    } catch (i) {\n      throw this.signer.logger.error(i), i;\n    } finally {\n      this.modal && this.modal.closeModal();\n    }\n  }\n  async disconnect() {\n    this.session && (await this.signer.disconnect()), this.reset();\n  }\n  get isWalletConnect() {\n    return !0;\n  }\n  get session() {\n    return this.signer.session;\n  }\n  registerEventListeners() {\n    this.signer.on(\"session_event\", t => {\n      const {\n          params: s\n        } = t,\n        {\n          event: i\n        } = s;\n      i.name === \"accountsChanged\" ? (this.accounts = this.parseAccounts(i.data), this.events.emit(\"accountsChanged\", this.accounts)) : i.name === \"chainChanged\" ? this.setChainId(this.formatChainId(i.data)) : this.events.emit(i.name, i.data), this.events.emit(\"session_event\", t);\n    }), this.signer.on(\"chainChanged\", t => {\n      const s = parseInt(t);\n      this.chainId = s, this.events.emit(\"chainChanged\", v(this.chainId)), this.persist();\n    }), this.signer.on(\"session_update\", t => {\n      this.events.emit(\"session_update\", t);\n    }), this.signer.on(\"session_delete\", t => {\n      this.reset(), this.events.emit(\"session_delete\", t), this.events.emit(\"disconnect\", E(p({}, A(\"USER_DISCONNECTED\")), {\n        data: t.topic,\n        name: \"USER_DISCONNECTED\"\n      }));\n    }), this.signer.on(\"display_uri\", t => {\n      var s, i;\n      this.rpc.showQrModal && ((s = this.modal) == null || s.closeModal(), (i = this.modal) == null || i.openModal({\n        uri: t\n      })), this.events.emit(\"display_uri\", t);\n    });\n  }\n  switchEthereumChain(t) {\n    this.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{\n        chainId: t.toString(16)\n      }]\n    });\n  }\n  isCompatibleChainId(t) {\n    return typeof t == \"string\" ? t.startsWith(`${this.namespace}:`) : !1;\n  }\n  formatChainId(t) {\n    return `${this.namespace}:${t}`;\n  }\n  parseChainId(t) {\n    return Number(t.split(\":\")[1]);\n  }\n  setChainIds(t) {\n    const s = t.filter(i => this.isCompatibleChainId(i)).map(i => this.parseChainId(i));\n    s.length && (this.chainId = s[0], this.events.emit(\"chainChanged\", v(this.chainId)), this.persist());\n  }\n  setChainId(t) {\n    if (this.isCompatibleChainId(t)) {\n      const s = this.parseChainId(t);\n      this.chainId = s, this.switchEthereumChain(s);\n    }\n  }\n  parseAccountId(t) {\n    const [s, i, e] = t.split(\":\");\n    return {\n      chainId: `${s}:${i}`,\n      address: e\n    };\n  }\n  setAccounts(t) {\n    this.accounts = t.filter(s => this.parseChainId(this.parseAccountId(s).chainId) === this.chainId).map(s => this.parseAccountId(s).address), this.events.emit(\"accountsChanged\", this.accounts);\n  }\n  getRpcConfig(t) {\n    var s, i;\n    const e = (s = t?.chains) != null ? s : [],\n      n = (i = t?.optionalChains) != null ? i : [],\n      o = e.concat(n);\n    if (!o.length) throw new Error(\"No chains specified in either `chains` or `optionalChains`\");\n    const c = e.length ? t?.methods || g : [],\n      a = e.length ? t?.events || u : [],\n      h = t?.optionalMethods || [],\n      d = t?.optionalEvents || [],\n      w = t?.rpcMap || this.buildRpcMap(o, t.projectId),\n      I = t?.qrModalOptions || void 0;\n    return {\n      chains: e?.map(l => this.formatChainId(l)),\n      optionalChains: n.map(l => this.formatChainId(l)),\n      methods: c,\n      events: a,\n      optionalMethods: h,\n      optionalEvents: d,\n      rpcMap: w,\n      showQrModal: !!(t != null && t.showQrModal),\n      qrModalOptions: I,\n      projectId: t.projectId,\n      metadata: t.metadata\n    };\n  }\n  buildRpcMap(t, s) {\n    const i = {};\n    return t.forEach(e => {\n      i[e] = this.getRpcUrl(e, s);\n    }), i;\n  }\n  async initialize(t) {\n    if (this.rpc = this.getRpcConfig(t), this.chainId = this.rpc.chains.length ? m(this.rpc.chains) : m(this.rpc.optionalChains), this.signer = await S.init({\n      projectId: this.rpc.projectId,\n      metadata: this.rpc.metadata,\n      disableProviderPing: t.disableProviderPing,\n      relayUrl: t.relayUrl,\n      storageOptions: t.storageOptions,\n      customStoragePrefix: t.customStoragePrefix,\n      telemetryEnabled: t.telemetryEnabled,\n      logger: t.logger\n    }), this.registerEventListeners(), await this.loadPersistedSession(), this.rpc.showQrModal) {\n      let s;\n      try {\n        const {\n          WalletConnectModal: i\n        } = await import(\"@walletconnect/modal\");\n        s = i;\n      } catch {\n        throw new Error(\"To use QR modal, please install @walletconnect/modal package\");\n      }\n      if (s) try {\n        this.modal = new s(p({\n          projectId: this.rpc.projectId\n        }, this.rpc.qrModalOptions));\n      } catch (i) {\n        throw this.signer.logger.error(i), new Error(\"Could not generate WalletConnectModal Instance\");\n      }\n    }\n  }\n  loadConnectOpts(t) {\n    if (!t) return;\n    const {\n      chains: s,\n      optionalChains: i,\n      rpcMap: e\n    } = t;\n    s && f(s) && (this.rpc.chains = s.map(n => this.formatChainId(n)), s.forEach(n => {\n      this.rpc.rpcMap[n] = e?.[n] || this.getRpcUrl(n);\n    })), i && f(i) && (this.rpc.optionalChains = [], this.rpc.optionalChains = i?.map(n => this.formatChainId(n)), i.forEach(n => {\n      this.rpc.rpcMap[n] = e?.[n] || this.getRpcUrl(n);\n    }));\n  }\n  getRpcUrl(t, s) {\n    var i;\n    return ((i = this.rpc.rpcMap) == null ? void 0 : i[t]) || `${j}?chainId=eip155:${t}&projectId=${s || this.rpc.projectId}`;\n  }\n  async loadPersistedSession() {\n    if (this.session) try {\n      const t = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`),\n        s = this.session.namespaces[`${this.namespace}:${t}`] ? this.session.namespaces[`${this.namespace}:${t}`] : this.session.namespaces[this.namespace];\n      this.setChainIds(t ? [this.formatChainId(t)] : s?.accounts), this.setAccounts(s?.accounts);\n    } catch (t) {\n      this.signer.logger.error(\"Failed to load persisted session, clearing state...\"), this.signer.logger.error(t), await this.disconnect().catch(s => this.signer.logger.warn(s));\n    }\n  }\n  reset() {\n    this.chainId = 1, this.accounts = [];\n  }\n  persist() {\n    this.session && this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId);\n  }\n  parseAccounts(t) {\n    return typeof t == \"string\" || t instanceof String ? [this.parseAccount(t)] : t.map(s => this.parseAccount(s));\n  }\n}\nconst x = C;\nexport { x as EthereumProvider, b as OPTIONAL_EVENTS, y as OPTIONAL_METHODS, u as REQUIRED_EVENTS, g as REQUIRED_METHODS, C as default };\n//# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}