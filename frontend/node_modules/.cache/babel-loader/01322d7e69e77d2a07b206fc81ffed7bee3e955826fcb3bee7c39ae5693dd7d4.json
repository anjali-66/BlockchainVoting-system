{"ast":null,"code":"\"use client\";\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useCallback } from \"react\";\nimport { getContract } from \"../../../../../../contract/contract.js\";\nimport { getListing } from \"../../../../../../extensions/marketplace/direct-listings/read/getListing.js\";\nimport { useReadContract } from \"../../../../../core/hooks/contract/useReadContract.js\";\nimport { useSendAndConfirmTransaction } from \"../../../../../core/hooks/transaction/useSendAndConfirmTransaction.js\";\nimport { useActiveAccount } from \"../../../../../core/hooks/wallets/useActiveAccount.js\";\nimport { TransactionButton } from \"../../../TransactionButton/index.js\";\n/**\n * This button is used with thirdweb Marketplace v3 contract, for buying NFT(s) from a listing.\n *\n * Under the hood, it prepares a transaction using the [`buyFromListing` extension](https://portal.thirdweb.com/references/typescript/v5/marketplace/buyFromListing)\n * and then pass it to a <TransactionButton />\n *\n * Since it uses the TransactionButton, it can take in any props that can be passed\n * to the [`TransactionButton`](https://portal.thirdweb.com/references/typescript/v5/TransactionButton)\n *\n *\n * @param props\n * @returns <TransactionButton />\n *\n * @example\n * ```tsx\n * import { BuyDirectListingButton } from \"thirdweb/react\";\n *\n * <BuyDirectListingButton\n *   contractAddress=\"0x...\" // contract address of the marketplace v3\n *   chain={...} // the chain which the marketplace contract is deployed on\n *   client={...} // thirdweb client\n *   listingId={100n} // the listingId or the item you want to buy\n *   quantity={1n} // optional - see the docs to learn more\n * >\n *   Buy NFT\n * </BuyDirectListingButton>\n * ```\n *\n * For error handling & callbacks on transaction-sent and transaction-confirmed,\n * please refer to the TransactionButton docs.\n * @component\n * @transaction\n */\nexport function BuyDirectListingButton(props) {\n  const {\n    contractAddress,\n    listingId,\n    children,\n    chain,\n    client,\n    quantity,\n    payModal\n  } = props;\n  const defaultPayModalMetadata = payModal ? payModal.metadata : undefined;\n  const account = useActiveAccount();\n  const contract = getContract({\n    address: contractAddress,\n    client,\n    chain\n  });\n  const {\n    data: payMetadata\n  } = useReadContract(getPayMetadata, {\n    contract,\n    listingId,\n    queryOptions: {\n      enabled: !defaultPayModalMetadata\n    }\n  });\n  const {\n    mutateAsync\n  } = useSendAndConfirmTransaction();\n  const prepareBuyTransaction = useCallback(async () => {\n    if (!account) {\n      throw new Error(\"No account detected\");\n    }\n    const [listing, {\n      getApprovalForTransaction\n    }, {\n      buyFromListing\n    }] = await Promise.all([getListing({\n      contract,\n      listingId\n    }), import(\"../../../../../../extensions/erc20/write/getApprovalForTransaction.js\"), import(\"../../../../../../extensions/marketplace/direct-listings/write/buyFromListing.js\")]);\n    if (!listing) {\n      throw new Error(`Could not retrieve listing with ID: ${listingId}`);\n    }\n    let _quantity = 1n;\n    // For ERC721 the quantity should always be 1n. We throw an error if user passes a different props\n    if (listing.asset.type === \"ERC721\") {\n      if (typeof quantity === \"bigint\" && (quantity !== 1n || quantity < 0n)) {\n        throw new Error(\"Invalid quantity. This is an ERC721 listing & quantity is always `1n`\");\n      }\n    } else if (listing.asset.type === \"ERC1155\") {\n      if (typeof quantity === \"bigint\") {\n        if (quantity > listing.quantity) {\n          throw new Error(`quantity exceeds available amount. Available: ${listing.quantity.toString()}`);\n        }\n        if (quantity < 0n) {\n          throw new Error(\"Invalid quantity. Should be at least 1n\");\n        }\n        _quantity = quantity;\n      }\n      _quantity = listing.quantity;\n    }\n    const buyTx = buyFromListing({\n      contract,\n      listingId,\n      quantity: _quantity,\n      recipient: account?.address || \"\"\n    });\n    const approveTx = await getApprovalForTransaction({\n      transaction: buyTx,\n      account\n    });\n    if (approveTx) {\n      await mutateAsync(approveTx);\n    }\n    return buyTx;\n  }, [account, contract, quantity, listingId, mutateAsync]);\n  return _jsx(TransactionButton, {\n    payModal: {\n      metadata: defaultPayModalMetadata || payMetadata,\n      ...payModal\n    },\n    transaction: () => prepareBuyTransaction(),\n    ...props,\n    children: children\n  });\n}\n/**\n * @internal\n */\nasync function getPayMetadata(options) {\n  const listing = await getListing(options);\n  if (!listing) {\n    return {\n      name: undefined,\n      image: undefined\n    };\n  }\n  return {\n    name: listing.asset?.metadata?.name,\n    image: listing.asset?.metadata?.image\n  };\n}\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}