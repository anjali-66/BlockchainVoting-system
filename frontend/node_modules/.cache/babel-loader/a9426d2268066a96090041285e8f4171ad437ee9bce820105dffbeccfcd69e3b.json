{"ast":null,"code":"import { ZERO_ADDRESS, isNativeTokenAddress } from \"../../../constants/addresses.js\";\nimport { MerkleTree } from \"../../../merkletree/MerkleTree.js\";\nimport { download } from \"../../../storage/download.js\";\nimport { convertQuantity } from \"./convert-quantity.js\";\nimport { hashEntry } from \"./hash-entry.js\";\nexport async function fetchProofsForClaimer(options) {\n  const {\n    contract,\n    merkleTreeUri,\n    claimer\n  } = options;\n  const hashEntryFn = options.hashEntry || hashEntry;\n  // 2. download snapshot data\n  const response = await download({\n    client: contract.client,\n    uri: merkleTreeUri\n  });\n  const merkleInfo = await response.json();\n  // 3. download shard data based off the user address\n  const shardId = claimer.slice(2, 2 + merkleInfo.shardNybbles).toLowerCase();\n  const uri = merkleInfo.baseUri.endsWith(\"/\") ? merkleInfo.baseUri : `${merkleInfo.baseUri}/`;\n  let shardData;\n  try {\n    const constructedShardUri = `${uri}${shardId}.json`;\n    const shard = await download({\n      client: contract.client,\n      uri: constructedShardUri\n    });\n    shardData = await shard.json();\n  } catch {\n    // if the file can't be fetched it means claimer not in merkle tree\n    return null;\n  }\n  // 4. hash all the entries in that shard and construct the sub merkle tree\n  const hashedEntries = await Promise.all(shardData.entries.map(async entry => {\n    return hashEntryFn({\n      entry,\n      chain: contract.chain,\n      client: contract.client,\n      tokenDecimals: options.tokenDecimals\n    });\n  }));\n  // 5. get the proof for the claimer + the sub merkle tree root\n  const tree = new MerkleTree(hashedEntries);\n  const entry = shardData.entries.find(i => i.address.toLowerCase() === claimer.toLowerCase());\n  if (!entry) {\n    return null;\n  }\n  const proof = tree.getHexProof(await hashEntryFn({\n    entry,\n    chain: contract.chain,\n    client: contract.client,\n    tokenDecimals: options.tokenDecimals\n  })).concat(shardData.proofs);\n  // 6. return the proof and the entry data for the contract call\n  const currencyAddress = entry.currencyAddress || ZERO_ADDRESS;\n  const currencyDecimals = await (async () => {\n    if (isNativeTokenAddress(currencyAddress) || currencyAddress === ZERO_ADDRESS) {\n      return 18;\n    }\n    const [{\n      getContract\n    }, {\n      decimals: getDecimals\n    }] = await Promise.all([import(\"../../../contract/contract.js\"), import(\"../../../extensions/erc20/read/decimals.js\")]);\n    const currencyContract = getContract({\n      address: currencyAddress,\n      chain: contract.chain,\n      client: contract.client\n    });\n    return await getDecimals({\n      contract: currencyContract\n    });\n  })();\n  return {\n    proof,\n    quantityLimitPerWallet: convertQuantity({\n      quantity: entry.maxClaimable || \"unlimited\",\n      tokenDecimals: options.tokenDecimals\n    }),\n    pricePerToken: convertQuantity({\n      quantity: entry.price || \"unlimited\",\n      tokenDecimals: currencyDecimals\n    }),\n    currency: currencyAddress\n  };\n}\n//# sourceMappingURL=fetch-proofs-for-claimers.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}