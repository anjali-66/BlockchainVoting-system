{"ast":null,"code":"// ADAPTED FROM https://github.com/merkletreejs/merkletreejs\nimport { uint8ArrayToHex } from \"../utils/encoding/hex.js\";\nimport { hexToBytes } from \"../utils/encoding/to-bytes.js\";\nimport { keccak256 } from \"../utils/hashing/keccak256.js\";\nimport { areUint8ArraysEqual, compareUint8Arrays, concatUint8Arrays } from \"../utils/uint8-array.js\";\n/**\n * Class reprensenting a Merkle Tree\n * @namespace MerkleTree\n */\nexport class MerkleTree {\n  constructor(leaves) {\n    Object.defineProperty(this, \"leaves\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"layers\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    this.leaves = leaves.map(el => el instanceof Uint8Array ? el : hexToBytes(el));\n    this.leaves = this.leaves.sort(compareUint8Arrays);\n    this.createHashes(this.leaves);\n  }\n  getHexRoot() {\n    return uint8ArrayToHex(this.getRoot());\n  }\n  getHexProof(leaf, index) {\n    return this.getProof(leaf, index).map(item => uint8ArrayToHex(item.data));\n  }\n  // private below\n  createHashes(nodes) {\n    this.layers = [nodes];\n    while (nodes.length > 1) {\n      const layerIndex = this.layers.length;\n      this.layers.push([]);\n      const layerLimit = nodes.length;\n      for (let i = 0; i < nodes.length; i += 2) {\n        if (i >= layerLimit) {\n          // biome-ignore lint/style/noNonNullAssertion: in bounds\n          this.layers[layerIndex].push(...nodes.slice(layerLimit));\n          break;\n        }\n        if (i + 1 === nodes.length) {\n          if (nodes.length % 2 === 1) {\n            // push copy of hash and continue iteration\n            // biome-ignore lint/style/noNonNullAssertion: in bounds\n            this.layers[layerIndex].push(nodes[i]);\n            continue;\n          }\n        }\n        // biome-ignore lint/style/noNonNullAssertion: in bounds\n        const left = nodes[i];\n        // biome-ignore lint/style/noNonNullAssertion: in bounds\n        const right = i + 1 === nodes.length ? left : nodes[i + 1];\n        const combined = [left, right];\n        combined.sort(compareUint8Arrays);\n        const hash = keccak256(concatUint8Arrays(combined), \"bytes\");\n        // biome-ignore lint/style/noNonNullAssertion: in bounds\n        this.layers[layerIndex].push(hash);\n      }\n      // biome-ignore lint/style/noParameterAssign: part of the functionality\n      // biome-ignore lint/style/noNonNullAssertion: in bounds\n      nodes = this.layers[layerIndex];\n    }\n  }\n  getRoot() {\n    if (this.layers.length === 0) {\n      return new Uint8Array();\n    }\n    // biome-ignore lint/style/noNonNullAssertion: in bounds\n    return this.layers[this.layers.length - 1][0] || new Uint8Array();\n  }\n  getProof(leaf, index) {\n    if (typeof leaf === \"undefined\") {\n      throw new Error(\"leaf is required\");\n    }\n    // biome-ignore lint/style/noParameterAssign: part of the functionality\n    leaf = leaf instanceof Uint8Array ? leaf : hexToBytes(leaf);\n    const proof = [];\n    if (!Number.isInteger(index)) {\n      // biome-ignore lint/style/noParameterAssign: part of the functionality\n      index = -1;\n      for (let i = 0; i < this.leaves.length; i++) {\n        // biome-ignore lint/style/noNonNullAssertion: within bounds\n        if (areUint8ArraysEqual(leaf, this.leaves[i])) {\n          // biome-ignore lint/style/noParameterAssign: part of the functionality\n          index = i;\n        }\n      }\n    }\n    // @ts-expect-error - issue from original code\n    if (index <= -1) {\n      return [];\n    }\n    for (let i = 0; i < this.layers.length; i++) {\n      // biome-ignore lint/style/noNonNullAssertion: in bounds\n      const layer = this.layers[i];\n      // @ts-expect-error - issue from original code\n      const isRightNode = index % 2;\n      const pairIndex = isRightNode ?\n      // @ts-expect-error - issue from original code\n      index - 1 :\n      // Proof Generation for Non-Bitcoin Trees\n      // @ts-expect-error - issue from original code\n      index + 1;\n      if (pairIndex < layer.length) {\n        proof.push({\n          position: isRightNode ? \"left\" : \"right\",\n          data: layer[pairIndex]\n        });\n      }\n      // set index to parent index\n      // @ts-expect-error - issue from original code\n      // biome-ignore lint/style/noParameterAssign: part of the functionality\n      index = index / 2 | 0;\n    }\n    // @ts-expect-error - issue from original code\n    return proof;\n  }\n}\n//# sourceMappingURL=MerkleTree.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}