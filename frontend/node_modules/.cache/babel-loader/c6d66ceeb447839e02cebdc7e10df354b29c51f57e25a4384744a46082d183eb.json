{"ast":null,"code":"import { generateWallet } from \"../../../core/actions/generate-wallet.enclave.js\";\nimport { getUserStatus } from \"../../../core/actions/get-enclave-user-status.js\";\nimport { BaseLogin } from \"./base-login.js\";\n/**\n *\n */\nexport class Auth {\n  /**\n   * Used to manage the user's auth states. This should not be instantiated directly.\n   * @internal\n   */\n  constructor({\n    client,\n    querier,\n    onAuthSuccess,\n    ecosystem,\n    baseUrl,\n    localStorage\n  }) {\n    Object.defineProperty(this, \"client\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"ecosystem\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"AuthQuerier\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"localStorage\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"onAuthSuccess\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"BaseLogin\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.client = client;\n    this.ecosystem = ecosystem;\n    this.AuthQuerier = querier;\n    this.localStorage = localStorage;\n    this.onAuthSuccess = onAuthSuccess;\n    this.BaseLogin = new BaseLogin({\n      postLogin: async result => {\n        return this.postLogin(result);\n      },\n      preLogin: async () => {\n        await this.preLogin();\n      },\n      ecosystem,\n      querier: querier,\n      client,\n      baseUrl\n    });\n  }\n  async preLogin() {\n    await this.logout();\n  }\n  async postLogin({\n    storedToken,\n    walletDetails\n  }) {\n    if (storedToken.shouldStoreCookieString) {\n      await this.localStorage.saveAuthCookie(storedToken.cookieString);\n    }\n    const initializedUser = await this.onAuthSuccess({\n      storedToken,\n      walletDetails\n    });\n    return initializedUser;\n  }\n  async loginWithAuthToken(authToken, recoveryCode) {\n    await this.preLogin();\n    const user = await getUserStatus({\n      authToken: authToken.storedToken.cookieString,\n      client: this.client,\n      ecosystem: this.ecosystem\n    });\n    if (!user) {\n      throw new Error(\"Cannot login, no user found for auth token\");\n    }\n    // If they're already an enclave wallet, proceed to login\n    if (user.wallets.length > 0 && user.wallets[0]?.type === \"enclave\") {\n      return this.postLogin({\n        storedToken: authToken.storedToken,\n        walletDetails: {\n          walletAddress: user.wallets[0].address\n        }\n      });\n    }\n    if (user.wallets.length === 0) {\n      // If this is a new ecosystem wallet without an enclave yet, we'll generate an enclave\n      const result = await generateWallet({\n        authToken: authToken.storedToken.cookieString,\n        client: this.client,\n        ecosystem: this.ecosystem\n      });\n      return this.postLogin({\n        storedToken: authToken.storedToken,\n        walletDetails: {\n          walletAddress: result.address\n        }\n      });\n    }\n    // If this is an existing sharded wallet or in-app wallet, we'll login with the sharded wallet\n    const result = await this.AuthQuerier.call({\n      procedureName: \"loginWithStoredTokenDetails\",\n      params: {\n        storedToken: authToken.storedToken,\n        recoveryCode\n      }\n    });\n    return this.postLogin(result);\n  }\n  /**\n   * Used to log the user into their thirdweb wallet on your platform via a myriad of auth providers\n   * @example\n   * ```typescript\n   * const thirdwebInAppWallet = new InAppWalletSdk({clientId: \"YOUR_CLIENT_ID\", chain: \"Polygon\"})\n   * try {\n   *   const user = await thirdwebInAppWallet.auth.loginWithModal();\n   *   // user is now logged in\n   * } catch (e) {\n   *   // User closed modal or something else went wrong during the authentication process\n   *   console.error(e)\n   * }\n   * ```\n   * @returns `{{user: InitializedUser}}` An InitializedUser object.\n   */\n  async loginWithModal() {\n    return this.BaseLogin.loginWithModal();\n  }\n  async authenticateWithModal() {\n    return this.BaseLogin.authenticateWithModal();\n  }\n  /**\n   * Used to log the user into their thirdweb wallet using email OTP\n   * @example\n   * ```typescript\n   *  // Basic Flow\n   *  const thirdwebInAppWallet = new InAppWalletSdk({clientId: \"\", chain: \"Polygon\"});\n   *  try {\n   *    // prompts user to enter the code they received\n   *    const user = await thirdwebInAppWallet.auth.loginWithThirdwebEmailOtp({ email : \"you@example.com\" });\n   *    // user is now logged in\n   *  } catch (e) {\n   *    // User closed the OTP modal or something else went wrong during the authentication process\n   *    console.error(e)\n   *  }\n   * ```\n   * @param args - args.email: We will send the email an OTP that needs to be entered in order for them to be logged in.\n   * @returns `{{user: InitializedUser}}` An InitializedUser object. See {@link InAppWalletSdk.getUser} for more\n   */\n  async loginWithIframe(args) {\n    return this.BaseLogin.loginWithIframe(args);\n  }\n  async authenticateWithIframe(args) {\n    return this.BaseLogin.authenticateWithIframe(args);\n  }\n  /**\n   * @internal\n   */\n  async loginWithCustomJwt(args) {\n    return this.BaseLogin.loginWithCustomJwt(args);\n  }\n  async authenticateWithCustomJwt(args) {\n    return this.BaseLogin.authenticateWithCustomJwt(args);\n  }\n  /**\n   * @internal\n   */\n  async loginWithCustomAuthEndpoint(args) {\n    return this.BaseLogin.loginWithCustomAuthEndpoint(args);\n  }\n  async authenticateWithCustomAuthEndpoint(args) {\n    return this.BaseLogin.authenticateWithCustomAuthEndpoint(args);\n  }\n  /**\n   * A headless way to send the users at the passed email an OTP code.\n   * You need to then call {@link Auth.loginWithEmailOtp} in order to complete the login process\n   * @example\n   * @param param0.email\n   * ```typescript\n   *  const thirdwebInAppWallet = new InAppWalletSdk({clientId: \"\", chain: \"Polygon\"});\n   *  // sends user an OTP code\n   * try {\n   *    await thirdwebInAppWallet.auth.sendEmailLoginOtp({ email : \"you@example.com\" });\n   * } catch(e) {\n   *    // Error Sending user's email an OTP code\n   *    console.error(e);\n   * }\n   *\n   * // Then when your user is ready to verify their OTP\n   * try {\n   *    const user = await thirdwebInAppWallet.auth.verifyEmailLoginOtp({ email: \"you@example.com\", otp: \"6-DIGIT_CODE_HERE\" });\n   * } catch(e) {\n   *    // Error verifying the OTP code\n   *    console.error(e)\n   * }\n   * ```\n   * @param param0 - param0.email We will send the email an OTP that needs to be entered in order for them to be logged in.\n   * @returns `{{ isNewUser: boolean }}` IsNewUser indicates if the user is a new user to your platform\n   * @internal\n   */\n  async sendEmailLoginOtp({\n    email\n  }) {\n    return this.BaseLogin.sendEmailLoginOtp({\n      email\n    });\n  }\n  /**\n   * @internal\n   */\n  async sendSmsLoginOtp({\n    phoneNumber\n  }) {\n    return this.BaseLogin.sendSmsLoginOtp({\n      phoneNumber\n    });\n  }\n  /**\n   * Used to verify the otp that the user receives from thirdweb\n   *\n   * See {@link Auth.sendEmailLoginOtp} for how the headless call flow looks like. Simply swap out the calls to `loginWithThirdwebEmailOtp` with `verifyThirdwebEmailLoginOtp`\n   * @param args - props.email We will send the email an OTP that needs to be entered in order for them to be logged in.\n   * props.otp The code that the user received in their email\n   * @returns `{{user: InitializedUser}}` An InitializedUser object containing the user's status, wallet, authDetails, and more\n   * @internal\n   */\n  async loginWithEmailOtp(args) {\n    await this.preLogin();\n    return this.BaseLogin.loginWithEmailOtp(args);\n  }\n  async authenticateWithEmailOtp(args) {\n    return this.BaseLogin.authenticateWithEmailOtp(args);\n  }\n  /**\n   * @internal\n   */\n  async loginWithSmsOtp(args) {\n    await this.preLogin();\n    return this.BaseLogin.loginWithSmsOtp(args);\n  }\n  async authenticateWithSmsOtp(args) {\n    return this.BaseLogin.authenticateWithSmsOtp(args);\n  }\n  /**\n   * Logs any existing user out of their wallet.\n   * @returns `{{success: boolean}}` true if a user is successfully logged out. false if there's no user currently logged in.\n   * @internal\n   */\n  async logout() {\n    if (this.AuthQuerier) {\n      await this.AuthQuerier.call({\n        procedureName: \"logout\",\n        params: undefined\n      });\n    }\n    const isRemoveAuthCookie = await this.localStorage.removeAuthCookie();\n    const isRemoveUserId = await this.localStorage.removeWalletUserId();\n    return {\n      success: isRemoveAuthCookie || isRemoveUserId\n    };\n  }\n}\n//# sourceMappingURL=iframe-auth.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}