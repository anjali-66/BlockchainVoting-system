{"ast":null,"code":"import { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport { getClientFetch } from \"../../../../utils/fetch.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nfunction getVerificationPath() {\n  return `${getThirdwebBaseUrl(\"inAppWallet\")}/api/2024-05-05/login/passkey/callback`;\n}\nfunction getChallengePath(type, username) {\n  return `${getThirdwebBaseUrl(\"inAppWallet\")}/api/2024-05-05/login/passkey?type=${type}${username ? `&username=${username}` : \"\"}`;\n}\nexport async function registerPasskey(options) {\n  if (!options.passkeyClient.isAvailable()) {\n    throw new Error(\"Passkeys are not available on this device\");\n  }\n  const fetchWithId = getClientFetch(options.client, options.ecosystem);\n  const generatedName = options.username ?? generateUsername(options.ecosystem);\n  // 1. request challenge from  server\n  const res = await fetchWithId(getChallengePath(\"sign-up\", generatedName));\n  const challengeData = await res.json();\n  if (!challengeData.challenge) {\n    throw new Error(\"No challenge received\");\n  }\n  const challenge = challengeData.challenge;\n  // 2. initiate registration\n  const registration = await options.passkeyClient.register({\n    name: generatedName,\n    challenge,\n    rp: options.rp\n  });\n  const customHeaders = {};\n  if (options.ecosystem?.partnerId) {\n    customHeaders[\"x-ecosystem-partner-id\"] = options.ecosystem.partnerId;\n  }\n  if (options.ecosystem?.id) {\n    customHeaders[\"x-ecosystem-id\"] = options.ecosystem.id;\n  }\n  // 3. send the registration object to the server\n  const verifRes = await fetchWithId(getVerificationPath(), {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...customHeaders\n    },\n    body: stringify({\n      type: \"sign-up\",\n      authenticatorData: registration.authenticatorData,\n      credentialId: registration.credentialId,\n      serverVerificationId: challengeData.serverVerificationId,\n      clientData: registration.clientData,\n      username: generatedName,\n      credential: {\n        publicKey: registration.credential.publicKey,\n        algorithm: registration.credential.algorithm\n      },\n      origin: registration.origin,\n      rpId: options.rp.id\n    })\n  });\n  const verifData = await verifRes.json();\n  if (!verifData || !verifData.storedToken) {\n    throw new Error(`Error verifying passkey: ${verifData.message ?? \"unknown error\"}`);\n  }\n  // 4. store the credentialId in local storage\n  await options.storage?.savePasskeyCredentialId(registration.credentialId);\n  // 5. returns back the IAW authentication token\n  return verifData;\n}\nexport async function loginWithPasskey(options) {\n  if (!options.passkeyClient.isAvailable()) {\n    throw new Error(\"Passkeys are not available on this device\");\n  }\n  const fetchWithId = getClientFetch(options.client, options.ecosystem);\n  // 1. request challenge from  server/iframe\n  const [challengeData, credentialId] = await Promise.all([fetchWithId(getChallengePath(\"sign-in\")).then(r => r.json()), options.storage?.getPasskeyCredentialId()]);\n  if (!challengeData.challenge) {\n    throw new Error(\"No challenge received\");\n  }\n  const challenge = challengeData.challenge;\n  // 2. initiate login\n  const authentication = await options.passkeyClient.authenticate({\n    credentialId: credentialId ?? undefined,\n    challenge,\n    rp: options.rp\n  });\n  const customHeaders = {};\n  if (options.ecosystem?.partnerId) {\n    customHeaders[\"x-ecosystem-partner-id\"] = options.ecosystem.partnerId;\n  }\n  if (options.ecosystem?.id) {\n    customHeaders[\"x-ecosystem-id\"] = options.ecosystem.id;\n  }\n  const verifRes = await fetchWithId(getVerificationPath(), {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...customHeaders\n    },\n    body: stringify({\n      type: \"sign-in\",\n      authenticatorData: authentication.authenticatorData,\n      credentialId: authentication.credentialId,\n      serverVerificationId: challengeData.serverVerificationId,\n      clientData: authentication.clientData,\n      signature: authentication.signature,\n      origin: authentication.origin,\n      rpId: options.rp.id\n    })\n  });\n  const verifData = await verifRes.json();\n  if (!verifData || !verifData.storedToken) {\n    throw new Error(`Error verifying passkey: ${verifData.message ?? \"unknown error\"}`);\n  }\n  // 5. store the credentialId in local storage\n  await options.storage?.savePasskeyCredentialId(authentication.credentialId);\n  // 6. return the auth'd user type\n  return verifData;\n}\nfunction generateUsername(ecosystem) {\n  return `${ecosystem?.id ?? \"wallet\"}-${new Date().toISOString()}`;\n}\n//# sourceMappingURL=passkeys.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}