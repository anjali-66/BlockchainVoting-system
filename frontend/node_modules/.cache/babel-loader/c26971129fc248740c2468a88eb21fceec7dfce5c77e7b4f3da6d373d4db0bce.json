{"ast":null,"code":"import { NATIVE_TOKEN_ADDRESS } from \"../../constants/addresses.js\";\nimport { getBytecode } from \"../../contract/actions/get-bytecode.js\";\nimport { getContract } from \"../../contract/contract.js\";\nimport { isAddress } from \"../../utils/address.js\";\nimport { getClientFetch } from \"../../utils/fetch.js\";\nimport { getPayConvertCryptoToFiatEndpoint } from \"../utils/definitions.js\";\n/**\n * Get a price of a token (using tokenAddress + chainId) in fiat.\n * Only USD is supported at the moment.\n * @example\n * ### Basic usage\n * For native token (non-ERC20), you should use NATIVE_TOKEN_ADDRESS as the value for `tokenAddress`\n * ```ts\n * import { convertCryptoToFiat } from \"thirdweb/pay\";\n *\n * // Get Ethereum price\n * const result = convertCryptoToFiat({\n *   fromTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   to: \"USD\",\n *   chain: ethereum,\n *   fromAmount: 1,\n * });\n *\n * // Result: `{ result: 3404.11 }`\n * ```\n * @buyCrypto\n * @returns a number representing the price (in selected fiat) of \"x\" token, with \"x\" being the `fromAmount`.\n */\nexport async function convertCryptoToFiat(options) {\n  const {\n    client,\n    fromTokenAddress,\n    to,\n    chain,\n    fromAmount\n  } = options;\n  if (Number(fromAmount) === 0) {\n    return {\n      result: 0\n    };\n  }\n  // Testnets just don't work with our current provider(s)\n  if (chain.testnet === true) {\n    throw new Error(`Cannot fetch price for a testnet (chainId: ${chain.id})`);\n  }\n  // Some provider that we are using will return `0` for unsupported token\n  // so we should do some basic input validations before sending the request\n  // Make sure it's a valid EVM address\n  if (!isAddress(fromTokenAddress)) {\n    throw new Error(\"Invalid fromTokenAddress. Expected a valid EVM contract address\");\n  }\n  // Make sure it's either a valid contract or a native token address\n  if (fromTokenAddress.toLowerCase() !== NATIVE_TOKEN_ADDRESS.toLowerCase()) {\n    const bytecode = await getBytecode(getContract({\n      address: fromTokenAddress,\n      chain,\n      client\n    })).catch(() => undefined);\n    if (!bytecode || bytecode === \"0x\") {\n      throw new Error(`Error: ${fromTokenAddress} on chainId: ${chain.id} is not a valid contract address.`);\n    }\n  }\n  const params = {\n    fromTokenAddress,\n    to,\n    chainId: String(chain.id),\n    fromAmount: String(fromAmount)\n  };\n  const queryString = new URLSearchParams(params).toString();\n  const url = `${getPayConvertCryptoToFiatEndpoint()}?${queryString}`;\n  const response = await getClientFetch(client)(url);\n  if (!response.ok) {\n    throw new Error(`Failed to fetch ${to} value for token (${fromTokenAddress}) on chainId: ${chain.id}`);\n  }\n  const data = await response.json();\n  return data;\n}\n//# sourceMappingURL=cryptoToFiat.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}