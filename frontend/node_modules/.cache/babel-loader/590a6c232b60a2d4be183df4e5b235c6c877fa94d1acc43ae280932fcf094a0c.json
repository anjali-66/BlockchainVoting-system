{"ast":null,"code":"import { formatAbi, parseAbi } from \"abitype\";\nimport { download } from \"../../storage/download.js\";\nimport { getClientFetch } from \"../../utils/fetch.js\";\nconst ABI_RESOLUTION_CACHE = new WeakMap();\n/**\n * Resolves the ABI (Application Binary Interface) for a given contract.\n * If the ABI is already cached, it returns the cached value.\n * Otherwise, it tries to resolve the ABI from the contract's API.\n * If that fails, it resolves the ABI from the contract's bytecode.\n * @param contract The contract for which to resolve the ABI.\n * @param contractApiBaseUrl The base URL of the contract API. Defaults to \"https://contract.thirdweb.com/abi\".\n * @returns A promise that resolves to the ABI of the contract.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { resolveContractAbi } from \"thirdweb/contract\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const myContract = getContract({\n *  client,\n *  address: \"...\",\n *  chain: ethereum,\n * });\n * const abi = await resolveContractAbi(myContract);\n * ```\n * @contract\n */\nexport function resolveContractAbi(contract, contractApiBaseUrl = \"https://contract.thirdweb.com/abi\") {\n  if (ABI_RESOLUTION_CACHE.has(contract)) {\n    return ABI_RESOLUTION_CACHE.get(contract);\n  }\n  const prom = (async () => {\n    // if the contract already HAS a user defined we always use that!\n    if (contract.abi) {\n      return contract.abi;\n    }\n    // for local chains, we need to resolve the composite abi from bytecode\n    if (contract.chain.id === 31337 || contract.chain.id === 1337) {\n      return await resolveCompositeAbi(contract);\n    }\n    // try to get it from the api\n    try {\n      return await resolveAbiFromContractApi(contract, contractApiBaseUrl);\n    } catch {\n      // if that fails, try to resolve it from the bytecode\n      return await resolveCompositeAbi(contract);\n    }\n  })();\n  ABI_RESOLUTION_CACHE.set(contract, prom);\n  return prom;\n}\n/**\n * Resolves the ABI (Application Binary Interface) for a contract from the contract API.\n * @param contract The ThirdwebContract instance representing the contract.\n * @param contractApiBaseUrl The base URL of the contract API. Defaults to \"https://contract.thirdweb.com/abi\".\n * @returns A promise that resolves to the ABI of the contract.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { resolveAbiFromContractApi } from \"thirdweb/contract\"\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const myContract = getContract({\n *  client,\n *  address: \"...\",\n *  chain: ethereum,\n * });\n * const abi = await resolveAbiFromContractApi(myContract);\n * ```\n * @contract\n */\nexport async function resolveAbiFromContractApi(\n// biome-ignore lint/suspicious/noExplicitAny: library function that accepts any contract type\ncontract, contractApiBaseUrl = \"https://contract.thirdweb.com/abi\") {\n  const response = await getClientFetch(contract.client)(`${contractApiBaseUrl}/${contract.chain.id}/${contract.address}`);\n  const json = await response.json();\n  if (!json || json.error) {\n    throw new Error(`Failed to resolve ABI from contract API. ${json.error || \"\"}`);\n  }\n  return json;\n}\n/**\n * Resolves the ABI (Application Binary Interface) from the bytecode of a contract.\n * @param contract The ThirdwebContract instance.\n * @returns The resolved ABI as a generic type.\n * @throws Error if no IPFS URI is found in the bytecode.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { resolveAbiFromBytecode } from \"thirdweb/contract\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const myContract = getContract({\n *  client,\n *  address: \"...\",\n *  chain: ethereum,\n * });\n * const abi = await resolveAbiFromBytecode(myContract);\n * ```\n * @contract\n */\nexport async function resolveAbiFromBytecode(\n// biome-ignore lint/suspicious/noExplicitAny: library function that accepts any contract type\ncontract) {\n  const [{\n    resolveImplementation\n  }, {\n    extractIPFSUri\n  }] = await Promise.all([import(\"../../utils/bytecode/resolveImplementation.js\"), import(\"../../utils/bytecode/extractIPFS.js\")]);\n  const {\n    bytecode\n  } = await resolveImplementation(contract);\n  if (bytecode === \"0x\") {\n    const {\n      id,\n      name\n    } = contract.chain;\n    throw new Error(`Failed to load contract bytecode. Make sure the contract [${contract.address}] exists on the chain [${name || \"Unknown Chain\"} (chain id: ${id})]`);\n  }\n  const ipfsUri = extractIPFSUri(bytecode);\n  if (!ipfsUri) {\n    // just early exit if we can't find an IPFS URI\n    return [];\n  }\n  try {\n    const res = await download({\n      uri: ipfsUri,\n      client: contract.client\n    });\n    const json = await res.json();\n    // ABI is at `json.output.abi`\n    return json.output.abi;\n  } catch {\n    // if we can't resolve the ABI from the IPFS URI, return an empty array\n    return [];\n  }\n}\nconst PLUGINS_ABI = {\n  inputs: [],\n  name: \"getAllPlugins\",\n  outputs: [{\n    components: [{\n      internalType: \"bytes4\",\n      name: \"functionSelector\",\n      type: \"bytes4\"\n    }, {\n      internalType: \"string\",\n      name: \"functionSignature\",\n      type: \"string\"\n    }, {\n      internalType: \"address\",\n      name: \"pluginAddress\",\n      type: \"address\"\n    }],\n    internalType: \"struct IPluginMap.Plugin[]\",\n    name: \"registered\",\n    type: \"tuple[]\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n};\nconst BASE_ROUTER_ABI = {\n  inputs: [],\n  name: \"getAllExtensions\",\n  outputs: [{\n    components: [{\n      components: [{\n        internalType: \"string\",\n        name: \"name\",\n        type: \"string\"\n      }, {\n        internalType: \"string\",\n        name: \"metadataURI\",\n        type: \"string\"\n      }, {\n        internalType: \"address\",\n        name: \"implementation\",\n        type: \"address\"\n      }],\n      internalType: \"struct IExtension.ExtensionMetadata\",\n      name: \"metadata\",\n      type: \"tuple\"\n    }, {\n      components: [{\n        internalType: \"bytes4\",\n        name: \"functionSelector\",\n        type: \"bytes4\"\n      }, {\n        internalType: \"string\",\n        name: \"functionSignature\",\n        type: \"string\"\n      }],\n      internalType: \"struct IExtension.ExtensionFunction[]\",\n      name: \"functions\",\n      type: \"tuple[]\"\n    }],\n    internalType: \"struct IExtension.Extension[]\",\n    name: \"allExtensions\",\n    type: \"tuple[]\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n};\nconst DIAMOND_ABI = {\n  inputs: [],\n  name: \"facets\",\n  outputs: [{\n    components: [{\n      internalType: \"address\",\n      name: \"facetAddress\",\n      type: \"address\"\n    }, {\n      internalType: \"bytes4[]\",\n      name: \"functionSelectors\",\n      type: \"bytes4[]\"\n    }],\n    type: \"tuple[]\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n};\n/**\n * Resolves the ABI for a contract based on its bytecode.\n * If the contract follows the plugin-pattern or dynamic pattern, it resolves the ABIs for the plugins and merges them with the root ABI.\n * If the contract follows the base router pattern, it resolves the ABIs for the plugins and merges them with the root ABI.\n * If the contract follows the diamond pattern, it resolves the ABIs for the facets and merges them with the root ABI.\n * @param contract The contract for which to resolve the ABI.\n * @param rootAbi The root ABI to use for the contract. If not provided, it resolves the ABI from the contract's bytecode.\n * @param resolveSubAbi A function to resolve the ABI for a sub-contract. If not provided, it uses the default ABI resolution logic.\n * @returns The resolved ABI for the contract.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { resolveCompositeAbiFromBytecode } from \"thirdweb/contract\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const myContract = getContract({\n *  client,\n *  address: \"...\",\n *  chain: ethereum,\n * });\n * const abi = await resolveCompositeAbiFromBytecode(myContract);\n * ```\n * @contract\n */\nexport async function resolveCompositeAbi(contract, rootAbi, resolveSubAbi) {\n  const [rootAbi_, pluginPatternAddresses, baseRouterAddresses, modularExtensionAddresses, diamondFacetAddresses] = await Promise.all([rootAbi ? rootAbi : resolveAbiFromBytecode(contract),\n  // check these all at the same time\n  resolvePluginPatternAddresses(contract), resolveBaseRouterAddresses(contract), resolveModularModuleAddresses(contract), resolveDiamondFacetAddresses(contract)]);\n  const mergedPlugins = [...new Set([...pluginPatternAddresses, ...baseRouterAddresses, ...modularExtensionAddresses, ...diamondFacetAddresses])];\n  // no plugins\n  if (!mergedPlugins.length) {\n    return rootAbi_;\n  }\n  // get all the abis for the plugins\n  const pluginAbis = await getAbisForPlugins({\n    contract,\n    plugins: mergedPlugins,\n    resolveSubAbi\n  });\n  // join them together\n  return joinAbis({\n    rootAbi: rootAbi_,\n    pluginAbis\n  });\n}\nasync function resolvePluginPatternAddresses(contract) {\n  try {\n    const {\n      readContract\n    } = await import(\"../../transaction/read-contract.js\");\n    const pluginMap = await readContract({\n      contract,\n      method: PLUGINS_ABI\n    });\n    // if there are no plugins, return the root ABI\n    if (!pluginMap.length) {\n      return [];\n    }\n    // get all the plugin addresses\n    return [...new Set(pluginMap.map(item => item.pluginAddress))];\n  } catch {\n    // no-op, expected because not everything supports this\n  }\n  return [];\n}\nasync function resolveBaseRouterAddresses(contract) {\n  try {\n    const {\n      readContract\n    } = await import(\"../../transaction/read-contract.js\");\n    const pluginMap = await readContract({\n      contract,\n      method: BASE_ROUTER_ABI\n    });\n    // if there are no plugins, return the root ABI\n    if (!pluginMap.length) {\n      return [];\n    }\n    // get all the plugin addresses\n    return [...new Set(pluginMap.map(item => item.metadata.implementation))];\n  } catch {\n    // no-op, expected because not everything supports this\n  }\n  return [];\n}\nasync function resolveModularModuleAddresses(contract) {\n  try {\n    const {\n      getInstalledModules\n    } = await import(\"../../extensions/modules/__generated__/IModularCore/read/getInstalledModules.js\");\n    const modules = await getInstalledModules({\n      contract\n    });\n    // if there are no plugins, return the root ABI\n    if (!modules.length) {\n      return [];\n    }\n    // get all the plugin addresses\n    return [...new Set(modules.map(item => item.implementation))];\n  } catch {\n    // no-op, expected because not everything supports this\n  }\n  return [];\n}\nasync function resolveDiamondFacetAddresses(contract) {\n  try {\n    const {\n      readContract\n    } = await import(\"../../transaction/read-contract.js\");\n    const facets = await readContract({\n      contract,\n      method: DIAMOND_ABI\n    });\n    // if there are no facets, return the root ABI\n    if (!facets.length) {\n      return [];\n    }\n    // get all the plugin addresses\n    return facets.map(item => item.facetAddress);\n  } catch {\n    // no-op, expected because not everything supports this\n  }\n  return [];\n}\nasync function getAbisForPlugins(options) {\n  return Promise.all(options.plugins.map(pluginAddress => {\n    const newContract = {\n      ...options.contract,\n      address: pluginAddress\n    };\n    // if we have a method passed in that tells us how to resove the sub-api, use that\n    if (options.resolveSubAbi) {\n      return options.resolveSubAbi(newContract);\n    }\n    // otherwise default logic\n    return resolveAbiFromBytecode(newContract);\n  }));\n}\nfunction joinAbis(options) {\n  let mergedPlugins = options.pluginAbis.flat().filter(item => item.type !== \"constructor\");\n  if (options.rootAbi) {\n    mergedPlugins = [...options.rootAbi, ...mergedPlugins].filter(item => item.type !== \"fallback\" && item.type !== \"receive\").filter(Boolean);\n  }\n  // unique by formatting every abi and then throwing them in a set\n  // TODO: this may not be super efficient...\n  const humanReadableAbi = [...new Set(formatAbi(mergedPlugins))];\n  // finally parse it back out\n  return parseAbi(humanReadableAbi);\n}\n//# sourceMappingURL=resolve-abi.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}