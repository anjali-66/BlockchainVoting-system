{"ast":null,"code":"import { getGasOverridesForTransaction } from \"../../gas/fee-data.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { isZkSyncChain } from \"../../utils/any-evm/zksync/isZkSyncChain.js\";\nimport { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport { encode } from \"./encode.js\";\nimport { estimateGas } from \"./estimate-gas.js\";\n/**\n * Converts a prepared transaction to a transaction with populated options.\n * @param options - The transaction and additional options for conversion\n * @returns A serializable transaction for inspection or submission to an account.\n *\n *  For easier transaction sending, {@see sendTransaction}\n * @example\n * ```ts\n * import { prepareTransaction, toSerializableTransaction } from \"thirdweb\";\n *\n * const transaction = await prepareTransaction({\n *   transaction: {\n *     to: \"0x...\",\n *     value: 100,\n *   },\n * });\n * const finalTx = await toSerializableTransaction({\n *   transaction,\n * });\n *\n * account.sendTransaction(finalTx);\n * ```\n * @transaction\n */\nexport async function toSerializableTransaction(options) {\n  // zk chains require a different rpc method for gas estimation and gas fees\n  const isZkSync = await isZkSyncChain(options.transaction.chain);\n  if (isZkSync) {\n    const {\n      getZkGasFees\n    } = await import(\"./zksync/send-eip712-transaction.js\");\n    const {\n      gas,\n      maxFeePerGas,\n      maxPriorityFeePerGas\n    } = await getZkGasFees({\n      transaction: options.transaction,\n      from: options.from ? getAddress(options.from) : undefined\n    });\n    // passing these values here will avoid re-fetching them below\n    options.transaction = {\n      ...options.transaction,\n      gas,\n      maxFeePerGas,\n      maxPriorityFeePerGas\n    };\n  }\n  const rpcRequest = getRpcClient(options.transaction);\n  const chainId = options.transaction.chain.id;\n  const from = options.from;\n  let [data, nonce, gas, feeData, to, accessList, value] = await Promise.all([encode(options.transaction), (async () => {\n    // if the user has specified a nonce, use that\n    const resolvedNonce = await resolvePromisedValue(options.transaction.nonce);\n    if (resolvedNonce !== undefined) {\n      return resolvedNonce;\n    }\n    return from // otherwise get the next nonce (import the method to do so)\n    ? await import(\"../../rpc/actions/eth_getTransactionCount.js\").then(({\n      eth_getTransactionCount\n    }) => eth_getTransactionCount(rpcRequest, {\n      address: from,\n      blockTag: \"pending\"\n    })) : undefined;\n  })(),\n  // takes the same options as the sendTransaction function thankfully!\n  estimateGas(options), getGasOverridesForTransaction(options.transaction), resolvePromisedValue(options.transaction.to), resolvePromisedValue(options.transaction.accessList), resolvePromisedValue(options.transaction.value)]);\n  const extraGas = await resolvePromisedValue(options.transaction.extraGas);\n  if (extraGas) {\n    gas += extraGas;\n  }\n  return {\n    to,\n    chainId,\n    data,\n    gas,\n    nonce,\n    accessList,\n    value,\n    ...feeData\n  };\n}\n//# sourceMappingURL=to-serializable-transaction.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}