{"ast":null,"code":"import { p256 } from '@noble/curves/p256';\nimport * as Bytes from './Bytes.js';\nimport * as PublicKey from './PublicKey.js';\n/**\n * Generates an ECDSA P256 key pair that includes:\n *\n * - a `privateKey` of type [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n *\n * - a `publicKey` of type {@link ox#Hex.Hex} or {@link ox#Bytes.Bytes}\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPair()\n * // @log: {\n * // @log:   privateKey: CryptoKey {},\n * // @log:   publicKey: {\n * // @log:     x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:     y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log:     prefix: 4,\n * // @log:   },\n * // @log: }\n * ```\n *\n * @param options - Options for creating the key pair.\n * @returns The key pair.\n */\nexport async function createKeyPair(options = {}) {\n  const {\n    extractable = false\n  } = options;\n  const keypair = await globalThis.crypto.subtle.generateKey({\n    name: 'ECDSA',\n    namedCurve: 'P-256'\n  }, extractable, ['sign', 'verify']);\n  const publicKey_raw = await globalThis.crypto.subtle.exportKey('raw', keypair.publicKey);\n  const publicKey = PublicKey.from(new Uint8Array(publicKey_raw));\n  return {\n    privateKey: keypair.privateKey,\n    publicKey\n  };\n}\n/**\n * Signs a payload with the provided `CryptoKey` private key and returns a P256 signature.\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey } = await WebCryptoP256.createKeyPair()\n *\n * const signature = await WebCryptoP256.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   r: 151231...4423n,\n * // @log:   s: 516123...5512n,\n * // @log: }\n * ```\n *\n * @param options - Options for signing the payload.\n * @returns The P256 ECDSA {@link ox#Signature.Signature}.\n */\nexport async function sign(options) {\n  const {\n    payload,\n    privateKey\n  } = options;\n  const signature = await globalThis.crypto.subtle.sign({\n    name: 'ECDSA',\n    hash: 'SHA-256'\n  }, privateKey, Bytes.from(payload));\n  const signature_bytes = Bytes.fromArray(new Uint8Array(signature));\n  const r = Bytes.toBigInt(Bytes.slice(signature_bytes, 0, 32));\n  let s = Bytes.toBigInt(Bytes.slice(signature_bytes, 32, 64));\n  if (s > p256.CURVE.n / 2n) s = p256.CURVE.n - s;\n  return {\n    r,\n    s\n  };\n}\n/**\n * Verifies a payload was signed by the provided public key.\n *\n * @example\n *\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey, publicKey } = await WebCryptoP256.createKeyPair()\n * const signature = await WebCryptoP256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = await WebCryptoP256.verify({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided public key.\n */\nexport async function verify(options) {\n  const {\n    payload,\n    signature\n  } = options;\n  const publicKey = await globalThis.crypto.subtle.importKey('raw', PublicKey.toBytes(options.publicKey), {\n    name: 'ECDSA',\n    namedCurve: 'P-256'\n  }, true, ['verify']);\n  return await globalThis.crypto.subtle.verify({\n    name: 'ECDSA',\n    hash: 'SHA-256'\n  }, publicKey, Bytes.concat(Bytes.fromNumber(signature.r), Bytes.fromNumber(signature.s)), Bytes.from(payload));\n}\n//# sourceMappingURL=WebCryptoP256.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}