{"ast":null,"code":"import { decodeErrorResult } from \"viem\";\nimport { resolveContractAbi } from \"../contract/actions/resolve-abi.js\";\nimport { isHex } from \"../utils/encoding/hex.js\";\nimport { stringify } from \"../utils/json.js\";\nimport { IS_DEV } from \"../utils/process.js\";\n/**\n * @internal\n */\nexport async function extractError(args) {\n  const {\n    error,\n    contract\n  } = args;\n  if (typeof error === \"object\") {\n    // try to parse RPC error\n    const errorObj = error;\n    if (errorObj.data) {\n      if (errorObj.data !== \"0x\" && isHex(errorObj.data)) {\n        let abi = contract?.abi;\n        if (contract && !abi) {\n          abi = await resolveContractAbi(contract).catch(() => undefined);\n        }\n        const parsedError = decodeErrorResult({\n          data: errorObj.data,\n          abi\n        });\n        return new TransactionError(`${parsedError.errorName}${parsedError.args ? ` - ${parsedError.args}` : \"\"}`, contract);\n      }\n      return new TransactionError(`Execution Reverted: ${stringify(errorObj)}`, contract);\n    }\n  }\n  return error;\n}\nclass TransactionError extends Error {\n  constructor(reason, contract) {\n    let message = reason;\n    if (IS_DEV && contract) {\n      // show more infor in dev\n      message = [reason, \"\", `contract: ${contract.address}`, `chainId: ${contract.chain?.id}`].join(\"\\n\");\n    }\n    super(message);\n    Object.defineProperty(this, \"contractAddress\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"chainId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.name = \"TransactionError\";\n    this.contractAddress = contract?.address;\n    this.chainId = contract?.chain?.id;\n    this.message = message;\n  }\n}\n//# sourceMappingURL=extract-error.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}