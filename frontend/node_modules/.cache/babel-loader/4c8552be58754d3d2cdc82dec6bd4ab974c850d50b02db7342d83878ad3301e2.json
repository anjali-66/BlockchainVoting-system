{"ast":null,"code":"import { SCWKeyManager } from './SCWKeyManager.js';\nimport { standardErrors } from '../../core/error/errors.js';\nimport { ScopedLocalStorage } from '../../core/storage/ScopedLocalStorage.js';\nimport { ensureIntNumber, hexStringFromNumber } from '../../core/type/util.js';\nimport { decryptContent, encryptContent, exportKeyToHexString, importKeyFromHexString } from '../../util/cipher.js';\nimport { fetchRPCRequest } from '../../util/provider.js';\nconst ACCOUNTS_KEY = 'accounts';\nconst ACTIVE_CHAIN_STORAGE_KEY = 'activeChain';\nconst AVAILABLE_CHAINS_STORAGE_KEY = 'availableChains';\nconst WALLET_CAPABILITIES_STORAGE_KEY = 'walletCapabilities';\nexport class SCWSigner {\n  constructor(params) {\n    var _a, _b, _c;\n    this.metadata = params.metadata;\n    this.communicator = params.communicator;\n    this.callback = params.callback;\n    this.keyManager = new SCWKeyManager();\n    this.storage = new ScopedLocalStorage('CBWSDK', 'SCWStateManager');\n    this.accounts = (_a = this.storage.loadObject(ACCOUNTS_KEY)) !== null && _a !== void 0 ? _a : [];\n    this.chain = this.storage.loadObject(ACTIVE_CHAIN_STORAGE_KEY) || {\n      id: (_c = (_b = params.metadata.appChainIds) === null || _b === void 0 ? void 0 : _b[0]) !== null && _c !== void 0 ? _c : 1\n    };\n    this.handshake = this.handshake.bind(this);\n    this.request = this.request.bind(this);\n    this.createRequestMessage = this.createRequestMessage.bind(this);\n    this.decryptResponseMessage = this.decryptResponseMessage.bind(this);\n  }\n  async handshake(args) {\n    var _a, _b;\n    const handshakeMessage = await this.createRequestMessage({\n      handshake: {\n        method: args.method,\n        params: Object.assign({}, this.metadata, (_a = args.params) !== null && _a !== void 0 ? _a : {})\n      }\n    });\n    const response = await this.communicator.postRequestAndWaitForResponse(handshakeMessage);\n    // store peer's public key\n    if ('failure' in response.content) throw response.content.failure;\n    const peerPublicKey = await importKeyFromHexString('public', response.sender);\n    await this.keyManager.setPeerPublicKey(peerPublicKey);\n    const decrypted = await this.decryptResponseMessage(response);\n    const result = decrypted.result;\n    if ('error' in result) throw result.error;\n    const accounts = result.value;\n    this.accounts = accounts;\n    this.storage.storeObject(ACCOUNTS_KEY, accounts);\n    (_b = this.callback) === null || _b === void 0 ? void 0 : _b.call(this, 'accountsChanged', accounts);\n  }\n  async request(request) {\n    var _a;\n    if (this.accounts.length === 0) {\n      throw standardErrors.provider.unauthorized();\n    }\n    switch (request.method) {\n      case 'eth_requestAccounts':\n        (_a = this.callback) === null || _a === void 0 ? void 0 : _a.call(this, 'connect', {\n          chainId: hexStringFromNumber(this.chain.id)\n        });\n        return this.accounts;\n      case 'eth_accounts':\n        return this.accounts;\n      case 'eth_coinbase':\n        return this.accounts[0];\n      case 'net_version':\n        return this.chain.id;\n      case 'eth_chainId':\n        return hexStringFromNumber(this.chain.id);\n      case 'wallet_getCapabilities':\n        return this.storage.loadObject(WALLET_CAPABILITIES_STORAGE_KEY);\n      case 'wallet_switchEthereumChain':\n        return this.handleSwitchChainRequest(request);\n      case 'eth_ecRecover':\n      case 'personal_sign':\n      case 'personal_ecRecover':\n      case 'eth_signTransaction':\n      case 'eth_sendTransaction':\n      case 'eth_signTypedData_v1':\n      case 'eth_signTypedData_v3':\n      case 'eth_signTypedData_v4':\n      case 'eth_signTypedData':\n      case 'wallet_addEthereumChain':\n      case 'wallet_watchAsset':\n      case 'wallet_sendCalls':\n      case 'wallet_showCallsStatus':\n      case 'wallet_grantPermissions':\n        return this.sendRequestToPopup(request);\n      default:\n        if (!this.chain.rpcUrl) throw standardErrors.rpc.internal('No RPC URL set for chain');\n        return fetchRPCRequest(request, this.chain.rpcUrl);\n    }\n  }\n  async sendRequestToPopup(request) {\n    var _a, _b;\n    // Open the popup before constructing the request message.\n    // This is to ensure that the popup is not blocked by some browsers (i.e. Safari)\n    await ((_b = (_a = this.communicator).waitForPopupLoaded) === null || _b === void 0 ? void 0 : _b.call(_a));\n    const response = await this.sendEncryptedRequest(request);\n    const decrypted = await this.decryptResponseMessage(response);\n    const result = decrypted.result;\n    if ('error' in result) throw result.error;\n    return result.value;\n  }\n  async cleanup() {\n    var _a, _b;\n    this.storage.clear();\n    await this.keyManager.clear();\n    this.accounts = [];\n    this.chain = {\n      id: (_b = (_a = this.metadata.appChainIds) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : 1\n    };\n  }\n  /**\n   * @returns `null` if the request was successful.\n   * https://eips.ethereum.org/EIPS/eip-3326#wallet_switchethereumchain\n   */\n  async handleSwitchChainRequest(request) {\n    var _a;\n    const params = request.params;\n    if (!params || !((_a = params[0]) === null || _a === void 0 ? void 0 : _a.chainId)) {\n      throw standardErrors.rpc.invalidParams();\n    }\n    const chainId = ensureIntNumber(params[0].chainId);\n    const localResult = this.updateChain(chainId);\n    if (localResult) return null;\n    const popupResult = await this.sendRequestToPopup(request);\n    if (popupResult === null) {\n      this.updateChain(chainId);\n    }\n    return popupResult;\n  }\n  async sendEncryptedRequest(request) {\n    const sharedSecret = await this.keyManager.getSharedSecret();\n    if (!sharedSecret) {\n      throw standardErrors.provider.unauthorized('No valid session found, try requestAccounts before other methods');\n    }\n    const encrypted = await encryptContent({\n      action: request,\n      chainId: this.chain.id\n    }, sharedSecret);\n    const message = await this.createRequestMessage({\n      encrypted\n    });\n    return this.communicator.postRequestAndWaitForResponse(message);\n  }\n  async createRequestMessage(content) {\n    const publicKey = await exportKeyToHexString('public', await this.keyManager.getOwnPublicKey());\n    return {\n      id: crypto.randomUUID(),\n      sender: publicKey,\n      content,\n      timestamp: new Date()\n    };\n  }\n  async decryptResponseMessage(message) {\n    var _a, _b;\n    const content = message.content;\n    // throw protocol level error\n    if ('failure' in content) {\n      throw content.failure;\n    }\n    const sharedSecret = await this.keyManager.getSharedSecret();\n    if (!sharedSecret) {\n      throw standardErrors.provider.unauthorized('Invalid session');\n    }\n    const response = await decryptContent(content.encrypted, sharedSecret);\n    const availableChains = (_a = response.data) === null || _a === void 0 ? void 0 : _a.chains;\n    if (availableChains) {\n      const chains = Object.entries(availableChains).map(([id, rpcUrl]) => ({\n        id: Number(id),\n        rpcUrl\n      }));\n      this.storage.storeObject(AVAILABLE_CHAINS_STORAGE_KEY, chains);\n      this.updateChain(this.chain.id, chains);\n    }\n    const walletCapabilities = (_b = response.data) === null || _b === void 0 ? void 0 : _b.capabilities;\n    if (walletCapabilities) {\n      this.storage.storeObject(WALLET_CAPABILITIES_STORAGE_KEY, walletCapabilities);\n    }\n    return response;\n  }\n  updateChain(chainId, newAvailableChains) {\n    var _a;\n    const chains = newAvailableChains !== null && newAvailableChains !== void 0 ? newAvailableChains : this.storage.loadObject(AVAILABLE_CHAINS_STORAGE_KEY);\n    const chain = chains === null || chains === void 0 ? void 0 : chains.find(chain => chain.id === chainId);\n    if (!chain) return false;\n    if (chain !== this.chain) {\n      this.chain = chain;\n      this.storage.storeObject(ACTIVE_CHAIN_STORAGE_KEY, chain);\n      (_a = this.callback) === null || _a === void 0 ? void 0 : _a.call(this, 'chainChanged', hexStringFromNumber(chain.id));\n    }\n    return true;\n  }\n}\n//# sourceMappingURL=SCWSigner.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}