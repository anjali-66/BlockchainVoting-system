{"ast":null,"code":"\"use client\";\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { getChainMetadata } from \"../../../../../chains/utils.js\";\nimport { getFunctionId } from \"../../../../../utils/function-id.js\";\nimport { resolveScheme } from \"../../../../../utils/ipfs.js\";\nimport { useChainContext } from \"./provider.js\";\n/**\n * This component tries to resolve the icon of a given chain, then return an image.\n * @returns an <img /> with the src of the chain icon\n *\n * @example\n * ### Basic usage\n * ```tsx\n * import { ChainProvider, ChainIcon } from \"thirdweb/react\";\n *\n * <ChainProvider chain={chain}>\n *   <ChainIcon />\n * </ChainProvider>\n * ```\n *\n * Result: An <img /> component with the src of the icon\n * ```html\n * <img src=\"chain-icon.png\" />\n * ```\n *\n * ### Override the icon with the `iconResolver` prop\n * If you already have the icon url, you can skip the network requests and pass it directly to the ChainIcon\n * ```tsx\n * <ChainIcon iconResolver=\"/ethereum-icon.png\" />\n * ```\n *\n * You can also pass in your own custom (async) function that retrieves the icon url\n * ```tsx\n * const getIcon = async () => {\n *   const icon = getIconFromCoinMarketCap(chainId, etc);\n *   return icon;\n * };\n *\n * <ChainIcon iconResolver={getIcon} />\n * ```\n *\n * ### Show a loading sign while the icon is being loaded\n * ```tsx\n * <ChainIcon loadingComponent={<Spinner />} />\n * ```\n *\n * ### Fallback to a dummy image if the chain icon fails to resolve\n * ```tsx\n * <ChainIcon fallbackComponent={<img src=\"blank-image.png\" />} />\n * ```\n *\n * ### Usage with queryOptions\n * ChainIcon uses useQuery() from tanstack query internally.\n * It allows you to pass a custom queryOptions of your choice for more control of the internal fetching logic\n * ```tsx\n * <ChainIcon queryOptions={{ enabled: someLogic, retry: 3, }} />\n * ```\n *\n * @component\n * @chain\n * @beta\n */\nexport function ChainIcon({\n  iconResolver,\n  loadingComponent,\n  fallbackComponent,\n  queryOptions,\n  client,\n  ...restProps\n}) {\n  const {\n    chain\n  } = useChainContext();\n  const iconQuery = useQuery({\n    queryKey: [\"_internal_chain_icon_\", chain.id, {\n      resolver: typeof iconResolver === \"string\" ? iconResolver : typeof iconResolver === \"function\" ? getFunctionId(iconResolver) : undefined\n    }],\n    queryFn: async () => {\n      if (typeof iconResolver === \"string\") {\n        return iconResolver;\n      }\n      if (typeof iconResolver === \"function\") {\n        return iconResolver();\n      }\n      // Check if the chain object already has \"icon\"\n      if (chain.icon?.url) {\n        return resolveScheme({\n          uri: chain.icon.url,\n          client\n        });\n      }\n      const possibleUrl = await getChainMetadata(chain).then(data => data.icon?.url);\n      if (!possibleUrl) {\n        throw new Error(\"Failed to resolve icon for chain\");\n      }\n      return resolveScheme({\n        uri: possibleUrl,\n        client\n      });\n    },\n    ...queryOptions\n  });\n  if (iconQuery.isLoading) {\n    return loadingComponent || null;\n  }\n  if (!iconQuery.data) {\n    return fallbackComponent || null;\n  }\n  return _jsx(\"img\", {\n    src: iconQuery.data,\n    ...restProps,\n    alt: restProps.alt\n  });\n}\n//# sourceMappingURL=icon.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}