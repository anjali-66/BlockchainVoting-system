{"ast":null,"code":"import { parseAbiItem } from \"abitype\";\nimport { encodeAbiParameters } from \"../utils/abi/encodeAbiParameters.js\";\nimport { prepareMethod } from \"../utils/abi/prepare-method.js\";\nimport { resolvePromisedValue } from \"../utils/promise/resolve-promised-value.js\";\nimport { prepareTransaction } from \"./prepare-transaction.js\";\nimport { isAbiFunction } from \"./utils.js\";\n/**\n * Prepares a contract call by resolving the ABI function, parameters and encoded data. Optionally specify other properties such as value or gas price.\n * @param options - The options for preparing the contract call.\n * @returns A promise that resolves to the prepared transaction.\n * @transaction\n * @example\n *\n * ### Usage with a human-readable method signature:\n *\n * ```ts\n * import { prepareContractCall } from \"thirdweb\";\n *\n * const transaction = prepareContractCall({\n *  contract,\n *  method: \"function transfer(address to, uint256 value)\",\n *  params: [to, value],\n * });\n * ```\n *\n * ### Usage with explicit gas price and/or value:\n *\n * ```ts\n * import { prepareContractCall } from \"thirdweb\";\n * import { toWei } from \"thirdweb/utils\";\n *\n * const transaction = prepareContractCall({\n *  contract,\n *  method: \"function transfer(address to, uint256 value)\",\n *  params: [to, value],\n *  maxFeePerGas: 30n,\n *  maxPriorityFeePerGas: 1n,\n *  value: toWei(\"0.01\"),\n * });\n * ```\n *\n * ### Usage with ERC20 value:\n *\n * For transactions that transfer ERC20 tokens, you can specify the value as the amount of tokens to transfer.\n *\n * You can use this in conjuction with the [`getApprovalForTransaction`](https://portal.thirdweb.com/references/typescript/v5/getApprovalForTransaction) function to easily create approval transactions for ERC20 tokens.\n *\n * This value will also be read by the react hooks and UI components to present to total cost to the user.\n *\n * ```ts\n * import { prepareContractCall } from \"thirdweb\";\n * import { toWei } from \"thirdweb/utils\";\n *\n * const transaction = prepareContractCall({\n *  contract,\n *  method: \"function payWithCoin()\",\n *  params: [],\n *  erc20Value: {\n *    tokenAddress: \"0x...\", // the address of the ERC20 token\n *    amountWei: toWei(\"0.1\"), // the amount of tokens to transfer in wei\n *  },\n * });\n * ```\n *\n * ### Usage with a JSON ABI function object:\n *\n * ```ts\n * import { prepareContractCall } from \"thirdweb\";\n *\n * const transaction = prepareContractCall({\n *  contract,\n *  method: {\n *    name: \"transfer\",\n *    type: \"function\",\n *    inputs: [\n *      { name: \"to\", type: \"address\" },\n *      { name: \"value\", type: \"uint256\" },\n *    ],\n *    outputs: [],\n *    stateMutability: \"payable\"\n *   },\n *  params: [to, value],\n * });\n * ```\n *\n * ### Usage with the ABI defined on the contract:\n *\n * ```ts\n * import { getContract, prepareContractCall } from \"thirdweb\";\n * const contract = getContract({\n *  ..., // chain, address, client\n *  abi: [...] // ABI with a \"transfer\" method\n * });\n * const transaction = prepareContractCall({\n *  contract,\n *  method: \"transfer\", // <- this gets inferred from the contract\n *  params: [to, value],\n * });\n * ```\n *\n * ### Passing extra call data to the transaction\n * ```ts\n * import { getContract, prepareContractCall } from \"thirdweb\";\n * const contract = getContract({\n *   ..., // chain, address, client\n * });\n *\n * const transaction = prepareContractCall({\n *   contract,\n *   method: \"function transfer(address to, uint256 value)\",\n *   params: [...],\n *   // The extra call data MUST be encoded to hex before passing\n *   extraCallData: \"0x.......\"\n * });\n * ```\n */\nexport function prepareContractCall(options) {\n  const {\n    contract,\n    method,\n    params,\n    ...rest\n  } = options;\n  const preparedMethodPromise = () => (async () => {\n    if (Array.isArray(method)) {\n      return method;\n    }\n    if (isAbiFunction(method)) {\n      return prepareMethod(method);\n    }\n    if (typeof method === \"function\") {\n      return prepareMethod(\n      // @ts-expect-error - method *is* function in this case\n      await method(contract));\n    }\n    // if the method starts with the string `function ` we always will want to try to parse it\n    if (typeof method === \"string\" && method.startsWith(\"function \")) {\n      // @ts-expect-error - method *is* string in this case\n      const abiItem = parseAbiItem(method);\n      if (abiItem.type === \"function\") {\n        return prepareMethod(abiItem);\n      }\n      throw new Error(`\"method\" passed is not of type \"function\"`);\n    }\n    // check if we have a \"abi\" on the contract\n    if (contract.abi && contract.abi?.length > 0) {\n      // extract the abiFunction from it\n      const abiFunction = contract.abi?.find(item => item.type === \"function\" && item.name === method);\n      // if we were able to find it -> return it\n      if (abiFunction) {\n        return prepareMethod(abiFunction);\n      }\n    }\n    throw new Error(`Could not resolve method \"${method}\".`);\n  })();\n  return prepareTransaction({\n    ...rest,\n    // these always inferred from the contract\n    to: contract.address,\n    chain: contract.chain,\n    client: contract.client,\n    data: async () => {\n      let preparedM;\n      if (Array.isArray(method)) {\n        preparedM = method;\n      } else {\n        preparedM = await preparedMethodPromise();\n      }\n      if (preparedM[1].length === 0) {\n        // just return the fn sig directly -> no params\n        return preparedM[0];\n      }\n      // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n      // we can do this because we know the specific formats of the values\n      return preparedM[0] + encodeAbiParameters(preparedM[1],\n      // @ts-expect-error - TODO: fix this type issue\n      await resolvePromisedValue(params ?? [])).slice(2);\n    }\n  }, {\n    preparedMethod: preparedMethodPromise,\n    contract: contract\n  });\n}\n//# sourceMappingURL=prepare-contract-call.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}