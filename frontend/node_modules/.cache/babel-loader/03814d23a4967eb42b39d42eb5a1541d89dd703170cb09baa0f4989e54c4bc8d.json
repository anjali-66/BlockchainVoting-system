{"ast":null,"code":"import { RELAYER_DEFAULT_PROTOCOL as Rt, TRANSPORT_TYPES as f, EVENT_CLIENT_SESSION_TRACES as C, EVENT_CLIENT_SESSION_ERRORS as F, EVENT_CLIENT_AUTHENTICATE_TRACES as Q, EVENT_CLIENT_AUTHENTICATE_ERRORS as se, EVENT_CLIENT_PAIRING_ERRORS as St, EVENT_CLIENT_PAIRING_TRACES as It, RELAYER_EVENTS as Ge, VERIFY_SERVER as ft, EXPIRER_EVENTS as vt, PAIRING_EVENTS as je, Store as Y, Core as qt } from \"@walletconnect/core\";\nimport { pino as Tt, getDefaultLoggerOptions as Nt, generateChildLogger as Pt, getLoggerContext as Ot } from \"@walletconnect/logger\";\nimport { IEngine as At, ISignClient as bt } from \"@walletconnect/types\";\nimport { THIRTY_DAYS as Ct, SEVEN_DAYS as Fe, FIVE_MINUTES as A, ONE_DAY as k, ONE_HOUR as Qe, ONE_SECOND as ze, toMiliseconds as Te } from \"@walletconnect/time\";\nimport { getInternalError as u, calcExpiry as b, createDelayedPromise as X, engineEvent as g, getSdkError as P, getDeepLink as Lt, handleDeeplinkRedirect as xt, isSessionCompatible as Dt, hashKey as Ne, parseChainId as Pe, createEncodedRecap as Vt, getRecapFromResources as Oe, mergeEncodedRecaps as Mt, TYPE_2 as kt, BASE64URL as ie, getLinkModeURL as he, validateSignedCacao as He, getNamespacedDidChainId as Ye, getDidAddress as Xe, getMethodsFromRecap as Je, getChainsFromRecap as Be, buildNamespacesFromAuth as We, formatMessage as $t, BASE64 as de, hashMessage as J, isExpired as B, MemoryStore as re, isValidParams as L, isUndefined as ne, isValidRelays as Kt, isValidObject as Ze, isValidRequiredNamespaces as Ut, isValidNamespaces as Ae, isConformingNamespaces as et, isValidString as $, isValidErrorReason as Gt, isValidRelay as jt, isValidController as Ft, isValidNamespacesChainId as tt, isValidRequest as Qt, isValidNamespacesRequest as zt, isValidRequestExpiry as Ht, isValidResponse as Yt, isValidEvent as Xt, isValidNamespacesEvent as Jt, getSearchParamFromURL as st, isTestRun as Bt, isReactNative as Wt, parseExpirerTarget as Zt, isValidId as es, TYPE_1 as be, getAppMetadata as ts } from \"@walletconnect/utils\";\nimport ss, { EventEmitter as is } from \"events\";\nimport { payloadId as z, getBigIntRpcId as ue, isJsonRpcResult as K, isJsonRpcError as U, formatJsonRpcRequest as ge, formatJsonRpcResult as rs, formatJsonRpcError as ns, isJsonRpcRequest as os, isJsonRpcResponse as as } from \"@walletconnect/jsonrpc-utils\";\nconst Ce = \"wc\",\n  Le = 2,\n  xe = \"client\",\n  ye = `${Ce}@${Le}:${xe}:`,\n  we = {\n    name: xe,\n    logger: \"error\",\n    controller: !1,\n    relayUrl: \"wss://relay.walletconnect.org\"\n  },\n  cs = {\n    session_proposal: \"session_proposal\",\n    session_update: \"session_update\",\n    session_extend: \"session_extend\",\n    session_ping: \"session_ping\",\n    session_delete: \"session_delete\",\n    session_expire: \"session_expire\",\n    session_request: \"session_request\",\n    session_request_sent: \"session_request_sent\",\n    session_event: \"session_event\",\n    proposal_expire: \"proposal_expire\",\n    session_authenticate: \"session_authenticate\",\n    session_request_expire: \"session_request_expire\"\n  },\n  ls = {\n    database: \":memory:\"\n  },\n  De = \"WALLETCONNECT_DEEPLINK_CHOICE\",\n  ps = {\n    created: \"history_created\",\n    updated: \"history_updated\",\n    deleted: \"history_deleted\",\n    sync: \"history_sync\"\n  },\n  hs = \"history\",\n  ds = \"0.3\",\n  it = \"proposal\",\n  us = Ct,\n  rt = \"Proposal expired\",\n  nt = \"session\",\n  H = Fe,\n  ot = \"engine\",\n  v = {\n    wc_sessionPropose: {\n      req: {\n        ttl: A,\n        prompt: !0,\n        tag: 1100\n      },\n      res: {\n        ttl: A,\n        prompt: !1,\n        tag: 1101\n      },\n      reject: {\n        ttl: A,\n        prompt: !1,\n        tag: 1120\n      },\n      autoReject: {\n        ttl: A,\n        prompt: !1,\n        tag: 1121\n      }\n    },\n    wc_sessionSettle: {\n      req: {\n        ttl: A,\n        prompt: !1,\n        tag: 1102\n      },\n      res: {\n        ttl: A,\n        prompt: !1,\n        tag: 1103\n      }\n    },\n    wc_sessionUpdate: {\n      req: {\n        ttl: k,\n        prompt: !1,\n        tag: 1104\n      },\n      res: {\n        ttl: k,\n        prompt: !1,\n        tag: 1105\n      }\n    },\n    wc_sessionExtend: {\n      req: {\n        ttl: k,\n        prompt: !1,\n        tag: 1106\n      },\n      res: {\n        ttl: k,\n        prompt: !1,\n        tag: 1107\n      }\n    },\n    wc_sessionRequest: {\n      req: {\n        ttl: A,\n        prompt: !0,\n        tag: 1108\n      },\n      res: {\n        ttl: A,\n        prompt: !1,\n        tag: 1109\n      }\n    },\n    wc_sessionEvent: {\n      req: {\n        ttl: A,\n        prompt: !0,\n        tag: 1110\n      },\n      res: {\n        ttl: A,\n        prompt: !1,\n        tag: 1111\n      }\n    },\n    wc_sessionDelete: {\n      req: {\n        ttl: k,\n        prompt: !1,\n        tag: 1112\n      },\n      res: {\n        ttl: k,\n        prompt: !1,\n        tag: 1113\n      }\n    },\n    wc_sessionPing: {\n      req: {\n        ttl: k,\n        prompt: !1,\n        tag: 1114\n      },\n      res: {\n        ttl: k,\n        prompt: !1,\n        tag: 1115\n      }\n    },\n    wc_sessionAuthenticate: {\n      req: {\n        ttl: Qe,\n        prompt: !0,\n        tag: 1116\n      },\n      res: {\n        ttl: Qe,\n        prompt: !1,\n        tag: 1117\n      },\n      reject: {\n        ttl: A,\n        prompt: !1,\n        tag: 1118\n      },\n      autoReject: {\n        ttl: A,\n        prompt: !1,\n        tag: 1119\n      }\n    }\n  },\n  me = {\n    min: A,\n    max: Fe\n  },\n  x = {\n    idle: \"IDLE\",\n    active: \"ACTIVE\"\n  },\n  at = \"request\",\n  ct = [\"wc_sessionPropose\", \"wc_sessionRequest\", \"wc_authRequest\", \"wc_sessionAuthenticate\"],\n  lt = \"wc\",\n  gs = 1.5,\n  pt = \"auth\",\n  ht = \"authKeys\",\n  dt = \"pairingTopics\",\n  ut = \"requests\",\n  oe = `${lt}@${1.5}:${pt}:`,\n  ae = `${oe}:PUB_KEY`;\nvar ys = Object.defineProperty,\n  ws = Object.defineProperties,\n  ms = Object.getOwnPropertyDescriptors,\n  gt = Object.getOwnPropertySymbols,\n  _s = Object.prototype.hasOwnProperty,\n  Es = Object.prototype.propertyIsEnumerable,\n  yt = (q, o, e) => o in q ? ys(q, o, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : q[o] = e,\n  I = (q, o) => {\n    for (var e in o || (o = {})) _s.call(o, e) && yt(q, e, o[e]);\n    if (gt) for (var e of gt(o)) Es.call(o, e) && yt(q, e, o[e]);\n    return q;\n  },\n  D = (q, o) => ws(q, ms(o));\nclass Rs extends At {\n  constructor(o) {\n    super(o), this.name = ot, this.events = new ss(), this.initialized = !1, this.requestQueue = {\n      state: x.idle,\n      queue: []\n    }, this.sessionRequestQueue = {\n      state: x.idle,\n      queue: []\n    }, this.requestQueueDelay = ze, this.expectedPairingMethodMap = new Map(), this.recentlyDeletedMap = new Map(), this.recentlyDeletedLimit = 200, this.relayMessageCache = [], this.init = async () => {\n      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({\n        methods: Object.keys(v)\n      }), this.initialized = !0, setTimeout(() => {\n        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();\n      }, Te(this.requestQueueDelay)));\n    }, this.connect = async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      const t = D(I({}, e), {\n        requiredNamespaces: e.requiredNamespaces || {},\n        optionalNamespaces: e.optionalNamespaces || {}\n      });\n      await this.isValidConnect(t);\n      const {\n        pairingTopic: s,\n        requiredNamespaces: i,\n        optionalNamespaces: r,\n        sessionProperties: n,\n        relays: a\n      } = t;\n      let c = s,\n        h,\n        p = !1;\n      try {\n        c && (p = this.client.core.pairing.pairings.get(c).active);\n      } catch (E) {\n        throw this.client.logger.error(`connect() -> pairing.get(${c}) failed`), E;\n      }\n      if (!c || !p) {\n        const {\n          topic: E,\n          uri: S\n        } = await this.client.core.pairing.create();\n        c = E, h = S;\n      }\n      if (!c) {\n        const {\n          message: E\n        } = u(\"NO_MATCHING_KEY\", `connect() pairing topic: ${c}`);\n        throw new Error(E);\n      }\n      const d = await this.client.core.crypto.generateKeyPair(),\n        l = v.wc_sessionPropose.req.ttl || A,\n        w = b(l),\n        m = I({\n          requiredNamespaces: i,\n          optionalNamespaces: r,\n          relays: a ?? [{\n            protocol: Rt\n          }],\n          proposer: {\n            publicKey: d,\n            metadata: this.client.metadata\n          },\n          expiryTimestamp: w,\n          pairingTopic: c\n        }, n && {\n          sessionProperties: n\n        }),\n        {\n          reject: y,\n          resolve: _,\n          done: R\n        } = X(l, rt);\n      this.events.once(g(\"session_connect\"), async ({\n        error: E,\n        session: S\n      }) => {\n        if (E) y(E);else if (S) {\n          S.self.publicKey = d;\n          const M = D(I({}, S), {\n            pairingTopic: m.pairingTopic,\n            requiredNamespaces: m.requiredNamespaces,\n            optionalNamespaces: m.optionalNamespaces,\n            transportType: f.relay\n          });\n          await this.client.session.set(S.topic, M), await this.setExpiry(S.topic, S.expiry), c && (await this.client.core.pairing.updateMetadata({\n            topic: c,\n            metadata: S.peer.metadata\n          })), this.cleanupDuplicatePairings(M), _(M);\n        }\n      });\n      const V = await this.sendRequest({\n        topic: c,\n        method: \"wc_sessionPropose\",\n        params: m,\n        throwOnFailedPublish: !0\n      });\n      return await this.setProposal(V, I({\n        id: V\n      }, m)), {\n        uri: h,\n        approval: R\n      };\n    }, this.pair = async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        return await this.client.core.pairing.pair(e);\n      } catch (t) {\n        throw this.client.logger.error(\"pair() failed\"), t;\n      }\n    }, this.approve = async e => {\n      var t, s, i;\n      const r = this.client.core.eventClient.createEvent({\n        properties: {\n          topic: (t = e?.id) == null ? void 0 : t.toString(),\n          trace: [C.session_approve_started]\n        }\n      });\n      try {\n        this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      } catch (N) {\n        throw r.setError(F.no_internet_connection), N;\n      }\n      try {\n        await this.isValidProposalId(e?.id);\n      } catch (N) {\n        throw this.client.logger.error(`approve() -> proposal.get(${e?.id}) failed`), r.setError(F.proposal_not_found), N;\n      }\n      try {\n        await this.isValidApprove(e);\n      } catch (N) {\n        throw this.client.logger.error(\"approve() -> isValidApprove() failed\"), r.setError(F.session_approve_namespace_validation_failure), N;\n      }\n      const {\n          id: n,\n          relayProtocol: a,\n          namespaces: c,\n          sessionProperties: h,\n          sessionConfig: p\n        } = e,\n        d = this.client.proposal.get(n);\n      this.client.core.eventClient.deleteEvent({\n        eventId: r.eventId\n      });\n      const {\n        pairingTopic: l,\n        proposer: w,\n        requiredNamespaces: m,\n        optionalNamespaces: y\n      } = d;\n      let _ = (s = this.client.core.eventClient) == null ? void 0 : s.getEvent({\n        topic: l\n      });\n      _ || (_ = (i = this.client.core.eventClient) == null ? void 0 : i.createEvent({\n        type: C.session_approve_started,\n        properties: {\n          topic: l,\n          trace: [C.session_approve_started, C.session_namespaces_validation_success]\n        }\n      }));\n      const R = await this.client.core.crypto.generateKeyPair(),\n        V = w.publicKey,\n        E = await this.client.core.crypto.generateSharedKey(R, V),\n        S = I(I({\n          relay: {\n            protocol: a ?? \"irn\"\n          },\n          namespaces: c,\n          controller: {\n            publicKey: R,\n            metadata: this.client.metadata\n          },\n          expiry: b(H)\n        }, h && {\n          sessionProperties: h\n        }), p && {\n          sessionConfig: p\n        }),\n        M = f.relay;\n      _.addTrace(C.subscribing_session_topic);\n      try {\n        await this.client.core.relayer.subscribe(E, {\n          transportType: M\n        });\n      } catch (N) {\n        throw _.setError(F.subscribe_session_topic_failure), N;\n      }\n      _.addTrace(C.subscribe_session_topic_success);\n      const W = D(I({}, S), {\n        topic: E,\n        requiredNamespaces: m,\n        optionalNamespaces: y,\n        pairingTopic: l,\n        acknowledged: !1,\n        self: S.controller,\n        peer: {\n          publicKey: w.publicKey,\n          metadata: w.metadata\n        },\n        controller: R,\n        transportType: f.relay\n      });\n      await this.client.session.set(E, W), _.addTrace(C.store_session);\n      try {\n        _.addTrace(C.publishing_session_settle), await this.sendRequest({\n          topic: E,\n          method: \"wc_sessionSettle\",\n          params: S,\n          throwOnFailedPublish: !0\n        }).catch(N => {\n          throw _?.setError(F.session_settle_publish_failure), N;\n        }), _.addTrace(C.session_settle_publish_success), _.addTrace(C.publishing_session_approve), await this.sendResult({\n          id: n,\n          topic: l,\n          result: {\n            relay: {\n              protocol: a ?? \"irn\"\n            },\n            responderPublicKey: R\n          },\n          throwOnFailedPublish: !0\n        }).catch(N => {\n          throw _?.setError(F.session_approve_publish_failure), N;\n        }), _.addTrace(C.session_approve_publish_success);\n      } catch (N) {\n        throw this.client.logger.error(N), this.client.session.delete(E, P(\"USER_DISCONNECTED\")), await this.client.core.relayer.unsubscribe(E), N;\n      }\n      return this.client.core.eventClient.deleteEvent({\n        eventId: _.eventId\n      }), await this.client.core.pairing.updateMetadata({\n        topic: l,\n        metadata: w.metadata\n      }), await this.client.proposal.delete(n, P(\"USER_DISCONNECTED\")), await this.client.core.pairing.activate({\n        topic: l\n      }), await this.setExpiry(E, b(H)), {\n        topic: E,\n        acknowledged: () => Promise.resolve(this.client.session.get(E))\n      };\n    }, this.reject = async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        await this.isValidReject(e);\n      } catch (r) {\n        throw this.client.logger.error(\"reject() -> isValidReject() failed\"), r;\n      }\n      const {\n        id: t,\n        reason: s\n      } = e;\n      let i;\n      try {\n        i = this.client.proposal.get(t).pairingTopic;\n      } catch (r) {\n        throw this.client.logger.error(`reject() -> proposal.get(${t}) failed`), r;\n      }\n      i && (await this.sendError({\n        id: t,\n        topic: i,\n        error: s,\n        rpcOpts: v.wc_sessionPropose.reject\n      }), await this.client.proposal.delete(t, P(\"USER_DISCONNECTED\")));\n    }, this.update = async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        await this.isValidUpdate(e);\n      } catch (p) {\n        throw this.client.logger.error(\"update() -> isValidUpdate() failed\"), p;\n      }\n      const {\n          topic: t,\n          namespaces: s\n        } = e,\n        {\n          done: i,\n          resolve: r,\n          reject: n\n        } = X(),\n        a = z(),\n        c = ue().toString(),\n        h = this.client.session.get(t).namespaces;\n      return this.events.once(g(\"session_update\", a), ({\n        error: p\n      }) => {\n        p ? n(p) : r();\n      }), await this.client.session.update(t, {\n        namespaces: s\n      }), await this.sendRequest({\n        topic: t,\n        method: \"wc_sessionUpdate\",\n        params: {\n          namespaces: s\n        },\n        throwOnFailedPublish: !0,\n        clientRpcId: a,\n        relayRpcId: c\n      }).catch(p => {\n        this.client.logger.error(p), this.client.session.update(t, {\n          namespaces: h\n        }), n(p);\n      }), {\n        acknowledged: i\n      };\n    }, this.extend = async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        await this.isValidExtend(e);\n      } catch (a) {\n        throw this.client.logger.error(\"extend() -> isValidExtend() failed\"), a;\n      }\n      const {\n          topic: t\n        } = e,\n        s = z(),\n        {\n          done: i,\n          resolve: r,\n          reject: n\n        } = X();\n      return this.events.once(g(\"session_extend\", s), ({\n        error: a\n      }) => {\n        a ? n(a) : r();\n      }), await this.setExpiry(t, b(H)), this.sendRequest({\n        topic: t,\n        method: \"wc_sessionExtend\",\n        params: {},\n        clientRpcId: s,\n        throwOnFailedPublish: !0\n      }).catch(a => {\n        n(a);\n      }), {\n        acknowledged: i\n      };\n    }, this.request = async e => {\n      this.isInitialized();\n      try {\n        await this.isValidRequest(e);\n      } catch (w) {\n        throw this.client.logger.error(\"request() -> isValidRequest() failed\"), w;\n      }\n      const {\n          chainId: t,\n          request: s,\n          topic: i,\n          expiry: r = v.wc_sessionRequest.req.ttl\n        } = e,\n        n = this.client.session.get(i);\n      n?.transportType === f.relay && (await this.confirmOnlineStateOrThrow());\n      const a = z(),\n        c = ue().toString(),\n        {\n          done: h,\n          resolve: p,\n          reject: d\n        } = X(r, \"Request expired. Please try again.\");\n      this.events.once(g(\"session_request\", a), ({\n        error: w,\n        result: m\n      }) => {\n        w ? d(w) : p(m);\n      });\n      const l = this.getAppLinkIfEnabled(n.peer.metadata, n.transportType);\n      return l ? (await this.sendRequest({\n        clientRpcId: a,\n        relayRpcId: c,\n        topic: i,\n        method: \"wc_sessionRequest\",\n        params: {\n          request: D(I({}, s), {\n            expiryTimestamp: b(r)\n          }),\n          chainId: t\n        },\n        expiry: r,\n        throwOnFailedPublish: !0,\n        appLink: l\n      }).catch(w => d(w)), this.client.events.emit(\"session_request_sent\", {\n        topic: i,\n        request: s,\n        chainId: t,\n        id: a\n      }), await h()) : await Promise.all([new Promise(async w => {\n        await this.sendRequest({\n          clientRpcId: a,\n          relayRpcId: c,\n          topic: i,\n          method: \"wc_sessionRequest\",\n          params: {\n            request: D(I({}, s), {\n              expiryTimestamp: b(r)\n            }),\n            chainId: t\n          },\n          expiry: r,\n          throwOnFailedPublish: !0\n        }).catch(m => d(m)), this.client.events.emit(\"session_request_sent\", {\n          topic: i,\n          request: s,\n          chainId: t,\n          id: a\n        }), w();\n      }), new Promise(async w => {\n        var m;\n        if (!((m = n.sessionConfig) != null && m.disableDeepLink)) {\n          const y = await Lt(this.client.core.storage, De);\n          await xt({\n            id: a,\n            topic: i,\n            wcDeepLink: y\n          });\n        }\n        w();\n      }), h()]).then(w => w[2]);\n    }, this.respond = async e => {\n      this.isInitialized(), await this.isValidRespond(e);\n      const {\n          topic: t,\n          response: s\n        } = e,\n        {\n          id: i\n        } = s,\n        r = this.client.session.get(t);\n      r.transportType === f.relay && (await this.confirmOnlineStateOrThrow());\n      const n = this.getAppLinkIfEnabled(r.peer.metadata, r.transportType);\n      K(s) ? await this.sendResult({\n        id: i,\n        topic: t,\n        result: s.result,\n        throwOnFailedPublish: !0,\n        appLink: n\n      }) : U(s) && (await this.sendError({\n        id: i,\n        topic: t,\n        error: s.error,\n        appLink: n\n      })), this.cleanupAfterResponse(e);\n    }, this.ping = async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow();\n      try {\n        await this.isValidPing(e);\n      } catch (s) {\n        throw this.client.logger.error(\"ping() -> isValidPing() failed\"), s;\n      }\n      const {\n        topic: t\n      } = e;\n      if (this.client.session.keys.includes(t)) {\n        const s = z(),\n          i = ue().toString(),\n          {\n            done: r,\n            resolve: n,\n            reject: a\n          } = X();\n        this.events.once(g(\"session_ping\", s), ({\n          error: c\n        }) => {\n          c ? a(c) : n();\n        }), await Promise.all([this.sendRequest({\n          topic: t,\n          method: \"wc_sessionPing\",\n          params: {},\n          throwOnFailedPublish: !0,\n          clientRpcId: s,\n          relayRpcId: i\n        }), r()]);\n      } else this.client.core.pairing.pairings.keys.includes(t) && (await this.client.core.pairing.ping({\n        topic: t\n      }));\n    }, this.emit = async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(e);\n      const {\n          topic: t,\n          event: s,\n          chainId: i\n        } = e,\n        r = ue().toString(),\n        n = z();\n      await this.sendRequest({\n        topic: t,\n        method: \"wc_sessionEvent\",\n        params: {\n          event: s,\n          chainId: i\n        },\n        throwOnFailedPublish: !0,\n        relayRpcId: r,\n        clientRpcId: n\n      });\n    }, this.disconnect = async e => {\n      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(e);\n      const {\n        topic: t\n      } = e;\n      if (this.client.session.keys.includes(t)) await this.sendRequest({\n        topic: t,\n        method: \"wc_sessionDelete\",\n        params: P(\"USER_DISCONNECTED\"),\n        throwOnFailedPublish: !0\n      }), await this.deleteSession({\n        topic: t,\n        emitEvent: !1\n      });else if (this.client.core.pairing.pairings.keys.includes(t)) await this.client.core.pairing.disconnect({\n        topic: t\n      });else {\n        const {\n          message: s\n        } = u(\"MISMATCHED_TOPIC\", `Session or pairing topic not found: ${t}`);\n        throw new Error(s);\n      }\n    }, this.find = e => (this.isInitialized(), this.client.session.getAll().filter(t => Dt(t, e))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.authenticate = async (e, t) => {\n      var s;\n      this.isInitialized(), this.isValidAuthenticate(e);\n      const i = t && this.client.core.linkModeSupportedApps.includes(t) && ((s = this.client.metadata.redirect) == null ? void 0 : s.linkMode),\n        r = i ? f.link_mode : f.relay;\n      r === f.relay && (await this.confirmOnlineStateOrThrow());\n      const {\n          chains: n,\n          statement: a = \"\",\n          uri: c,\n          domain: h,\n          nonce: p,\n          type: d,\n          exp: l,\n          nbf: w,\n          methods: m = [],\n          expiry: y\n        } = e,\n        _ = [...(e.resources || [])],\n        {\n          topic: R,\n          uri: V\n        } = await this.client.core.pairing.create({\n          methods: [\"wc_sessionAuthenticate\"],\n          transportType: r\n        });\n      this.client.logger.info({\n        message: \"Generated new pairing\",\n        pairing: {\n          topic: R,\n          uri: V\n        }\n      });\n      const E = await this.client.core.crypto.generateKeyPair(),\n        S = Ne(E);\n      if (await Promise.all([this.client.auth.authKeys.set(ae, {\n        responseTopic: S,\n        publicKey: E\n      }), this.client.auth.pairingTopics.set(S, {\n        topic: S,\n        pairingTopic: R\n      })]), await this.client.core.relayer.subscribe(S, {\n        transportType: r\n      }), this.client.logger.info(`sending request to new pairing topic: ${R}`), m.length > 0) {\n        const {\n          namespace: O\n        } = Pe(n[0]);\n        let T = Vt(O, \"request\", m);\n        Oe(_) && (T = Mt(T, _.pop())), _.push(T);\n      }\n      const M = y && y > v.wc_sessionAuthenticate.req.ttl ? y : v.wc_sessionAuthenticate.req.ttl,\n        W = {\n          authPayload: {\n            type: d ?? \"caip122\",\n            chains: n,\n            statement: a,\n            aud: c,\n            domain: h,\n            version: \"1\",\n            nonce: p,\n            iat: new Date().toISOString(),\n            exp: l,\n            nbf: w,\n            resources: _\n          },\n          requester: {\n            publicKey: E,\n            metadata: this.client.metadata\n          },\n          expiryTimestamp: b(M)\n        },\n        N = {\n          eip155: {\n            chains: n,\n            methods: [...new Set([\"personal_sign\", ...m])],\n            events: [\"chainChanged\", \"accountsChanged\"]\n          }\n        },\n        Ve = {\n          requiredNamespaces: {},\n          optionalNamespaces: N,\n          relays: [{\n            protocol: \"irn\"\n          }],\n          pairingTopic: R,\n          proposer: {\n            publicKey: E,\n            metadata: this.client.metadata\n          },\n          expiryTimestamp: b(v.wc_sessionPropose.req.ttl)\n        },\n        {\n          done: mt,\n          resolve: Me,\n          reject: Ee\n        } = X(M, \"Request expired\"),\n        ce = async ({\n          error: O,\n          session: T\n        }) => {\n          if (this.events.off(g(\"session_request\", G), Re), O) Ee(O);else if (T) {\n            T.self.publicKey = E, await this.client.session.set(T.topic, T), await this.setExpiry(T.topic, T.expiry), R && (await this.client.core.pairing.updateMetadata({\n              topic: R,\n              metadata: T.peer.metadata\n            }));\n            const le = this.client.session.get(T.topic);\n            await this.deleteProposal(Z), Me({\n              session: le\n            });\n          }\n        },\n        Re = async O => {\n          var T, le, ke;\n          if (await this.deletePendingAuthRequest(G, {\n            message: \"fulfilled\",\n            code: 0\n          }), O.error) {\n            const te = P(\"WC_METHOD_UNSUPPORTED\", \"wc_sessionAuthenticate\");\n            return O.error.code === te.code ? void 0 : (this.events.off(g(\"session_connect\"), ce), Ee(O.error.message));\n          }\n          await this.deleteProposal(Z), this.events.off(g(\"session_connect\"), ce);\n          const {\n              cacaos: $e,\n              responder: j\n            } = O.result,\n            Ie = [],\n            Ke = [];\n          for (const te of $e) {\n            (await He({\n              cacao: te,\n              projectId: this.client.core.projectId\n            })) || (this.client.logger.error(te, \"Signature verification failed\"), Ee(P(\"SESSION_SETTLEMENT_FAILED\", \"Signature verification failed\")));\n            const {\n                p: fe\n              } = te,\n              ve = Oe(fe.resources),\n              Ue = [Ye(fe.iss)],\n              _t = Xe(fe.iss);\n            if (ve) {\n              const qe = Je(ve),\n                Et = Be(ve);\n              Ie.push(...qe), Ue.push(...Et);\n            }\n            for (const qe of Ue) Ke.push(`${qe}:${_t}`);\n          }\n          const ee = await this.client.core.crypto.generateSharedKey(E, j.publicKey);\n          let pe;\n          Ie.length > 0 && (pe = {\n            topic: ee,\n            acknowledged: !0,\n            self: {\n              publicKey: E,\n              metadata: this.client.metadata\n            },\n            peer: j,\n            controller: j.publicKey,\n            expiry: b(H),\n            requiredNamespaces: {},\n            optionalNamespaces: {},\n            relay: {\n              protocol: \"irn\"\n            },\n            pairingTopic: R,\n            namespaces: We([...new Set(Ie)], [...new Set(Ke)]),\n            transportType: r\n          }, await this.client.core.relayer.subscribe(ee, {\n            transportType: r\n          }), await this.client.session.set(ee, pe), R && (await this.client.core.pairing.updateMetadata({\n            topic: R,\n            metadata: j.metadata\n          })), pe = this.client.session.get(ee)), (T = this.client.metadata.redirect) != null && T.linkMode && (le = j.metadata.redirect) != null && le.linkMode && (ke = j.metadata.redirect) != null && ke.universal && t && (this.client.core.addLinkModeSupportedApp(j.metadata.redirect.universal), this.client.session.update(ee, {\n            transportType: f.link_mode\n          })), Me({\n            auths: $e,\n            session: pe\n          });\n        },\n        G = z(),\n        Z = z();\n      this.events.once(g(\"session_connect\"), ce), this.events.once(g(\"session_request\", G), Re);\n      let Se;\n      try {\n        if (i) {\n          const O = ge(\"wc_sessionAuthenticate\", W, G);\n          this.client.core.history.set(R, O);\n          const T = await this.client.core.crypto.encode(\"\", O, {\n            type: kt,\n            encoding: ie\n          });\n          Se = he(t, R, T);\n        } else await Promise.all([this.sendRequest({\n          topic: R,\n          method: \"wc_sessionAuthenticate\",\n          params: W,\n          expiry: e.expiry,\n          throwOnFailedPublish: !0,\n          clientRpcId: G\n        }), this.sendRequest({\n          topic: R,\n          method: \"wc_sessionPropose\",\n          params: Ve,\n          expiry: v.wc_sessionPropose.req.ttl,\n          throwOnFailedPublish: !0,\n          clientRpcId: Z\n        })]);\n      } catch (O) {\n        throw this.events.off(g(\"session_connect\"), ce), this.events.off(g(\"session_request\", G), Re), O;\n      }\n      return await this.setProposal(Z, I({\n        id: Z\n      }, Ve)), await this.setAuthRequest(G, {\n        request: D(I({}, W), {\n          verifyContext: {}\n        }),\n        pairingTopic: R,\n        transportType: r\n      }), {\n        uri: Se ?? V,\n        response: mt\n      };\n    }, this.approveSessionAuthenticate = async e => {\n      const {\n          id: t,\n          auths: s\n        } = e,\n        i = this.client.core.eventClient.createEvent({\n          properties: {\n            topic: t.toString(),\n            trace: [Q.authenticated_session_approve_started]\n          }\n        });\n      try {\n        this.isInitialized();\n      } catch (y) {\n        throw i.setError(se.no_internet_connection), y;\n      }\n      const r = this.getPendingAuthRequest(t);\n      if (!r) throw i.setError(se.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${t}`);\n      const n = r.transportType || f.relay;\n      n === f.relay && (await this.confirmOnlineStateOrThrow());\n      const a = r.requester.publicKey,\n        c = await this.client.core.crypto.generateKeyPair(),\n        h = Ne(a),\n        p = {\n          type: be,\n          receiverPublicKey: a,\n          senderPublicKey: c\n        },\n        d = [],\n        l = [];\n      for (const y of s) {\n        if (!(await He({\n          cacao: y,\n          projectId: this.client.core.projectId\n        }))) {\n          i.setError(se.invalid_cacao);\n          const S = P(\"SESSION_SETTLEMENT_FAILED\", \"Signature verification failed\");\n          throw await this.sendError({\n            id: t,\n            topic: h,\n            error: S,\n            encodeOpts: p\n          }), new Error(S.message);\n        }\n        i.addTrace(Q.cacaos_verified);\n        const {\n            p: _\n          } = y,\n          R = Oe(_.resources),\n          V = [Ye(_.iss)],\n          E = Xe(_.iss);\n        if (R) {\n          const S = Je(R),\n            M = Be(R);\n          d.push(...S), V.push(...M);\n        }\n        for (const S of V) l.push(`${S}:${E}`);\n      }\n      const w = await this.client.core.crypto.generateSharedKey(c, a);\n      i.addTrace(Q.create_authenticated_session_topic);\n      let m;\n      if (d?.length > 0) {\n        m = {\n          topic: w,\n          acknowledged: !0,\n          self: {\n            publicKey: c,\n            metadata: this.client.metadata\n          },\n          peer: {\n            publicKey: a,\n            metadata: r.requester.metadata\n          },\n          controller: a,\n          expiry: b(H),\n          authentication: s,\n          requiredNamespaces: {},\n          optionalNamespaces: {},\n          relay: {\n            protocol: \"irn\"\n          },\n          pairingTopic: r.pairingTopic,\n          namespaces: We([...new Set(d)], [...new Set(l)]),\n          transportType: n\n        }, i.addTrace(Q.subscribing_authenticated_session_topic);\n        try {\n          await this.client.core.relayer.subscribe(w, {\n            transportType: n\n          });\n        } catch (y) {\n          throw i.setError(se.subscribe_authenticated_session_topic_failure), y;\n        }\n        i.addTrace(Q.subscribe_authenticated_session_topic_success), await this.client.session.set(w, m), i.addTrace(Q.store_authenticated_session), await this.client.core.pairing.updateMetadata({\n          topic: r.pairingTopic,\n          metadata: r.requester.metadata\n        });\n      }\n      i.addTrace(Q.publishing_authenticated_session_approve);\n      try {\n        await this.sendResult({\n          topic: h,\n          id: t,\n          result: {\n            cacaos: s,\n            responder: {\n              publicKey: c,\n              metadata: this.client.metadata\n            }\n          },\n          encodeOpts: p,\n          throwOnFailedPublish: !0,\n          appLink: this.getAppLinkIfEnabled(r.requester.metadata, n)\n        });\n      } catch (y) {\n        throw i.setError(se.authenticated_session_approve_publish_failure), y;\n      }\n      return await this.client.auth.requests.delete(t, {\n        message: \"fulfilled\",\n        code: 0\n      }), await this.client.core.pairing.activate({\n        topic: r.pairingTopic\n      }), this.client.core.eventClient.deleteEvent({\n        eventId: i.eventId\n      }), {\n        session: m\n      };\n    }, this.rejectSessionAuthenticate = async e => {\n      this.isInitialized();\n      const {\n          id: t,\n          reason: s\n        } = e,\n        i = this.getPendingAuthRequest(t);\n      if (!i) throw new Error(`Could not find pending auth request with id ${t}`);\n      i.transportType === f.relay && (await this.confirmOnlineStateOrThrow());\n      const r = i.requester.publicKey,\n        n = await this.client.core.crypto.generateKeyPair(),\n        a = Ne(r),\n        c = {\n          type: be,\n          receiverPublicKey: r,\n          senderPublicKey: n\n        };\n      await this.sendError({\n        id: t,\n        topic: a,\n        error: s,\n        encodeOpts: c,\n        rpcOpts: v.wc_sessionAuthenticate.reject,\n        appLink: this.getAppLinkIfEnabled(i.requester.metadata, i.transportType)\n      }), await this.client.auth.requests.delete(t, {\n        message: \"rejected\",\n        code: 0\n      }), await this.client.proposal.delete(t, P(\"USER_DISCONNECTED\"));\n    }, this.formatAuthMessage = e => {\n      this.isInitialized();\n      const {\n        request: t,\n        iss: s\n      } = e;\n      return $t(t, s);\n    }, this.processRelayMessageCache = () => {\n      setTimeout(async () => {\n        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0;) try {\n          const e = this.relayMessageCache.shift();\n          e && (await this.onRelayMessage(e));\n        } catch (e) {\n          this.client.logger.error(e);\n        }\n      }, 50);\n    }, this.cleanupDuplicatePairings = async e => {\n      if (e.pairingTopic) try {\n        const t = this.client.core.pairing.pairings.get(e.pairingTopic),\n          s = this.client.core.pairing.pairings.getAll().filter(i => {\n            var r, n;\n            return ((r = i.peerMetadata) == null ? void 0 : r.url) && ((n = i.peerMetadata) == null ? void 0 : n.url) === e.peer.metadata.url && i.topic && i.topic !== t.topic;\n          });\n        if (s.length === 0) return;\n        this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`), await Promise.all(s.map(i => this.client.core.pairing.disconnect({\n          topic: i.topic\n        }))), this.client.logger.info(\"Duplicate pairings clean up finished\");\n      } catch (t) {\n        this.client.logger.error(t);\n      }\n    }, this.deleteSession = async e => {\n      var t;\n      const {\n          topic: s,\n          expirerHasDeleted: i = !1,\n          emitEvent: r = !0,\n          id: n = 0\n        } = e,\n        {\n          self: a\n        } = this.client.session.get(s);\n      await this.client.core.relayer.unsubscribe(s), await this.client.session.delete(s, P(\"USER_DISCONNECTED\")), this.addToRecentlyDeleted(s, \"session\"), this.client.core.crypto.keychain.has(a.publicKey) && (await this.client.core.crypto.deleteKeyPair(a.publicKey)), this.client.core.crypto.keychain.has(s) && (await this.client.core.crypto.deleteSymKey(s)), i || this.client.core.expirer.del(s), this.client.core.storage.removeItem(De).catch(c => this.client.logger.warn(c)), this.getPendingSessionRequests().forEach(c => {\n        c.topic === s && this.deletePendingSessionRequest(c.id, P(\"USER_DISCONNECTED\"));\n      }), s === ((t = this.sessionRequestQueue.queue[0]) == null ? void 0 : t.topic) && (this.sessionRequestQueue.state = x.idle), r && this.client.events.emit(\"session_delete\", {\n        id: n,\n        topic: s\n      });\n    }, this.deleteProposal = async (e, t) => {\n      if (t) try {\n        const s = this.client.proposal.get(e),\n          i = this.client.core.eventClient.getEvent({\n            topic: s.pairingTopic\n          });\n        i?.setError(F.proposal_expired);\n      } catch {}\n      await Promise.all([this.client.proposal.delete(e, P(\"USER_DISCONNECTED\")), t ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, \"proposal\");\n    }, this.deletePendingSessionRequest = async (e, t, s = !1) => {\n      await Promise.all([this.client.pendingRequest.delete(e, t), s ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, \"request\"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter(i => i.id !== e), s && (this.sessionRequestQueue.state = x.idle, this.client.events.emit(\"session_request_expire\", {\n        id: e\n      }));\n    }, this.deletePendingAuthRequest = async (e, t, s = !1) => {\n      await Promise.all([this.client.auth.requests.delete(e, t), s ? Promise.resolve() : this.client.core.expirer.del(e)]);\n    }, this.setExpiry = async (e, t) => {\n      this.client.session.keys.includes(e) && (this.client.core.expirer.set(e, t), await this.client.session.update(e, {\n        expiry: t\n      }));\n    }, this.setProposal = async (e, t) => {\n      this.client.core.expirer.set(e, b(v.wc_sessionPropose.req.ttl)), await this.client.proposal.set(e, t);\n    }, this.setAuthRequest = async (e, t) => {\n      const {\n        request: s,\n        pairingTopic: i,\n        transportType: r = f.relay\n      } = t;\n      this.client.core.expirer.set(e, s.expiryTimestamp), await this.client.auth.requests.set(e, {\n        authPayload: s.authPayload,\n        requester: s.requester,\n        expiryTimestamp: s.expiryTimestamp,\n        id: e,\n        pairingTopic: i,\n        verifyContext: s.verifyContext,\n        transportType: r\n      });\n    }, this.setPendingSessionRequest = async e => {\n      const {\n          id: t,\n          topic: s,\n          params: i,\n          verifyContext: r\n        } = e,\n        n = i.request.expiryTimestamp || b(v.wc_sessionRequest.req.ttl);\n      this.client.core.expirer.set(t, n), await this.client.pendingRequest.set(t, {\n        id: t,\n        topic: s,\n        params: i,\n        verifyContext: r\n      });\n    }, this.sendRequest = async e => {\n      const {\n          topic: t,\n          method: s,\n          params: i,\n          expiry: r,\n          relayRpcId: n,\n          clientRpcId: a,\n          throwOnFailedPublish: c,\n          appLink: h\n        } = e,\n        p = ge(s, i, a);\n      let d;\n      const l = !!h;\n      try {\n        const y = l ? ie : de;\n        d = await this.client.core.crypto.encode(t, p, {\n          encoding: y\n        });\n      } catch (y) {\n        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t} failed`), y;\n      }\n      let w;\n      if (ct.includes(s)) {\n        const y = J(JSON.stringify(p)),\n          _ = J(d);\n        w = await this.client.core.verify.register({\n          id: _,\n          decryptedId: y\n        });\n      }\n      const m = v[s].req;\n      if (m.attestation = w, r && (m.ttl = r), n && (m.id = n), this.client.core.history.set(t, p), l) {\n        const y = he(h, t, d);\n        await global.Linking.openURL(y, this.client.name);\n      } else {\n        const y = v[s].req;\n        r && (y.ttl = r), n && (y.id = n), c ? (y.internal = D(I({}, y.internal), {\n          throwOnFailedPublish: !0\n        }), await this.client.core.relayer.publish(t, d, y)) : this.client.core.relayer.publish(t, d, y).catch(_ => this.client.logger.error(_));\n      }\n      return p.id;\n    }, this.sendResult = async e => {\n      const {\n          id: t,\n          topic: s,\n          result: i,\n          throwOnFailedPublish: r,\n          encodeOpts: n,\n          appLink: a\n        } = e,\n        c = rs(t, i);\n      let h;\n      const p = a && typeof (global == null ? void 0 : global.Linking) < \"u\";\n      try {\n        const l = p ? ie : de;\n        h = await this.client.core.crypto.encode(s, c, D(I({}, n || {}), {\n          encoding: l\n        }));\n      } catch (l) {\n        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`), l;\n      }\n      let d;\n      try {\n        d = await this.client.core.history.get(s, t);\n      } catch (l) {\n        throw this.client.logger.error(`sendResult() -> history.get(${s}, ${t}) failed`), l;\n      }\n      if (p) {\n        const l = he(a, s, h);\n        await global.Linking.openURL(l, this.client.name);\n      } else {\n        const l = v[d.request.method].res;\n        r ? (l.internal = D(I({}, l.internal), {\n          throwOnFailedPublish: !0\n        }), await this.client.core.relayer.publish(s, h, l)) : this.client.core.relayer.publish(s, h, l).catch(w => this.client.logger.error(w));\n      }\n      await this.client.core.history.resolve(c);\n    }, this.sendError = async e => {\n      const {\n          id: t,\n          topic: s,\n          error: i,\n          encodeOpts: r,\n          rpcOpts: n,\n          appLink: a\n        } = e,\n        c = ns(t, i);\n      let h;\n      const p = a && typeof (global == null ? void 0 : global.Linking) < \"u\";\n      try {\n        const l = p ? ie : de;\n        h = await this.client.core.crypto.encode(s, c, D(I({}, r || {}), {\n          encoding: l\n        }));\n      } catch (l) {\n        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`), l;\n      }\n      let d;\n      try {\n        d = await this.client.core.history.get(s, t);\n      } catch (l) {\n        throw this.client.logger.error(`sendError() -> history.get(${s}, ${t}) failed`), l;\n      }\n      if (p) {\n        const l = he(a, s, h);\n        await global.Linking.openURL(l, this.client.name);\n      } else {\n        const l = n || v[d.request.method].res;\n        this.client.core.relayer.publish(s, h, l);\n      }\n      await this.client.core.history.resolve(c);\n    }, this.cleanup = async () => {\n      const e = [],\n        t = [];\n      this.client.session.getAll().forEach(s => {\n        let i = !1;\n        B(s.expiry) && (i = !0), this.client.core.crypto.keychain.has(s.topic) || (i = !0), i && e.push(s.topic);\n      }), this.client.proposal.getAll().forEach(s => {\n        B(s.expiryTimestamp) && t.push(s.id);\n      }), await Promise.all([...e.map(s => this.deleteSession({\n        topic: s\n      })), ...t.map(s => this.deleteProposal(s))]);\n    }, this.onRelayEventRequest = async e => {\n      this.requestQueue.queue.push(e), await this.processRequestsQueue();\n    }, this.processRequestsQueue = async () => {\n      if (this.requestQueue.state === x.active) {\n        this.client.logger.info(\"Request queue already active, skipping...\");\n        return;\n      }\n      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0;) {\n        this.requestQueue.state = x.active;\n        const e = this.requestQueue.queue.shift();\n        if (e) try {\n          await this.processRequest(e);\n        } catch (t) {\n          this.client.logger.warn(t);\n        }\n      }\n      this.requestQueue.state = x.idle;\n    }, this.processRequest = async e => {\n      const {\n          topic: t,\n          payload: s,\n          attestation: i,\n          transportType: r,\n          encryptedId: n\n        } = e,\n        a = s.method;\n      if (!this.shouldIgnorePairingRequest({\n        topic: t,\n        requestMethod: a\n      })) switch (a) {\n        case \"wc_sessionPropose\":\n          return await this.onSessionProposeRequest({\n            topic: t,\n            payload: s,\n            attestation: i,\n            encryptedId: n\n          });\n        case \"wc_sessionSettle\":\n          return await this.onSessionSettleRequest(t, s);\n        case \"wc_sessionUpdate\":\n          return await this.onSessionUpdateRequest(t, s);\n        case \"wc_sessionExtend\":\n          return await this.onSessionExtendRequest(t, s);\n        case \"wc_sessionPing\":\n          return await this.onSessionPingRequest(t, s);\n        case \"wc_sessionDelete\":\n          return await this.onSessionDeleteRequest(t, s);\n        case \"wc_sessionRequest\":\n          return await this.onSessionRequest({\n            topic: t,\n            payload: s,\n            attestation: i,\n            encryptedId: n,\n            transportType: r\n          });\n        case \"wc_sessionEvent\":\n          return await this.onSessionEventRequest(t, s);\n        case \"wc_sessionAuthenticate\":\n          return await this.onSessionAuthenticateRequest({\n            topic: t,\n            payload: s,\n            attestation: i,\n            encryptedId: n,\n            transportType: r\n          });\n        default:\n          return this.client.logger.info(`Unsupported request method ${a}`);\n      }\n    }, this.onRelayEventResponse = async e => {\n      const {\n          topic: t,\n          payload: s,\n          transportType: i\n        } = e,\n        r = (await this.client.core.history.get(t, s.id)).request.method;\n      switch (r) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeResponse(t, s, i);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleResponse(t, s);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateResponse(t, s);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendResponse(t, s);\n        case \"wc_sessionPing\":\n          return this.onSessionPingResponse(t, s);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequestResponse(t, s);\n        case \"wc_sessionAuthenticate\":\n          return this.onSessionAuthenticateResponse(t, s);\n        default:\n          return this.client.logger.info(`Unsupported response method ${r}`);\n      }\n    }, this.onRelayEventUnknownPayload = e => {\n      const {\n          topic: t\n        } = e,\n        {\n          message: s\n        } = u(\"MISSING_OR_INVALID\", `Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);\n      throw new Error(s);\n    }, this.shouldIgnorePairingRequest = e => {\n      const {\n          topic: t,\n          requestMethod: s\n        } = e,\n        i = this.expectedPairingMethodMap.get(t);\n      return !i || i.includes(s) ? !1 : !!(i.includes(\"wc_sessionAuthenticate\") && this.client.events.listenerCount(\"session_authenticate\") > 0);\n    }, this.onSessionProposeRequest = async e => {\n      const {\n          topic: t,\n          payload: s,\n          attestation: i,\n          encryptedId: r\n        } = e,\n        {\n          params: n,\n          id: a\n        } = s;\n      try {\n        const c = this.client.core.eventClient.getEvent({\n          topic: t\n        });\n        this.client.events.listenerCount(\"session_proposal\") === 0 && (console.warn(\"No listener for session_proposal event\"), c?.setError(St.proposal_listener_not_found)), this.isValidConnect(I({}, s.params));\n        const h = n.expiryTimestamp || b(v.wc_sessionPropose.req.ttl),\n          p = I({\n            id: a,\n            pairingTopic: t,\n            expiryTimestamp: h\n          }, n);\n        await this.setProposal(a, p);\n        const d = await this.getVerifyContext({\n          attestationId: i,\n          hash: J(JSON.stringify(s)),\n          encryptedId: r,\n          metadata: p.proposer.metadata\n        });\n        c?.addTrace(It.emit_session_proposal), this.client.events.emit(\"session_proposal\", {\n          id: a,\n          params: p,\n          verifyContext: d\n        });\n      } catch (c) {\n        await this.sendError({\n          id: a,\n          topic: t,\n          error: c,\n          rpcOpts: v.wc_sessionPropose.autoReject\n        }), this.client.logger.error(c);\n      }\n    }, this.onSessionProposeResponse = async (e, t, s) => {\n      const {\n        id: i\n      } = t;\n      if (K(t)) {\n        const {\n          result: r\n        } = t;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          result: r\n        });\n        const n = this.client.proposal.get(i);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          proposal: n\n        });\n        const a = n.proposer.publicKey;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          selfPublicKey: a\n        });\n        const c = r.responderPublicKey;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          peerPublicKey: c\n        });\n        const h = await this.client.core.crypto.generateSharedKey(a, c);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          sessionTopic: h\n        });\n        const p = await this.client.core.relayer.subscribe(h, {\n          transportType: s\n        });\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          subscriptionId: p\n        }), await this.client.core.pairing.activate({\n          topic: e\n        });\n      } else if (U(t)) {\n        await this.client.proposal.delete(i, P(\"USER_DISCONNECTED\"));\n        const r = g(\"session_connect\");\n        if (this.events.listenerCount(r) === 0) throw new Error(`emitting ${r} without any listeners, 954`);\n        this.events.emit(g(\"session_connect\"), {\n          error: t.error\n        });\n      }\n    }, this.onSessionSettleRequest = async (e, t) => {\n      const {\n        id: s,\n        params: i\n      } = t;\n      try {\n        this.isValidSessionSettleRequest(i);\n        const {\n            relay: r,\n            controller: n,\n            expiry: a,\n            namespaces: c,\n            sessionProperties: h,\n            sessionConfig: p\n          } = t.params,\n          d = D(I(I({\n            topic: e,\n            relay: r,\n            expiry: a,\n            namespaces: c,\n            acknowledged: !0,\n            pairingTopic: \"\",\n            requiredNamespaces: {},\n            optionalNamespaces: {},\n            controller: n.publicKey,\n            self: {\n              publicKey: \"\",\n              metadata: this.client.metadata\n            },\n            peer: {\n              publicKey: n.publicKey,\n              metadata: n.metadata\n            }\n          }, h && {\n            sessionProperties: h\n          }), p && {\n            sessionConfig: p\n          }), {\n            transportType: f.relay\n          }),\n          l = g(\"session_connect\");\n        if (this.events.listenerCount(l) === 0) throw new Error(`emitting ${l} without any listeners 997`);\n        this.events.emit(g(\"session_connect\"), {\n          session: d\n        }), await this.sendResult({\n          id: t.id,\n          topic: e,\n          result: !0,\n          throwOnFailedPublish: !0\n        });\n      } catch (r) {\n        await this.sendError({\n          id: s,\n          topic: e,\n          error: r\n        }), this.client.logger.error(r);\n      }\n    }, this.onSessionSettleResponse = async (e, t) => {\n      const {\n        id: s\n      } = t;\n      K(t) ? (await this.client.session.update(e, {\n        acknowledged: !0\n      }), this.events.emit(g(\"session_approve\", s), {})) : U(t) && (await this.client.session.delete(e, P(\"USER_DISCONNECTED\")), this.events.emit(g(\"session_approve\", s), {\n        error: t.error\n      }));\n    }, this.onSessionUpdateRequest = async (e, t) => {\n      const {\n        params: s,\n        id: i\n      } = t;\n      try {\n        const r = `${e}_session_update`,\n          n = re.get(r);\n        if (n && this.isRequestOutOfSync(n, i)) {\n          this.client.logger.warn(`Discarding out of sync request - ${i}`), this.sendError({\n            id: i,\n            topic: e,\n            error: P(\"INVALID_UPDATE_REQUEST\")\n          });\n          return;\n        }\n        this.isValidUpdate(I({\n          topic: e\n        }, s));\n        try {\n          re.set(r, i), await this.client.session.update(e, {\n            namespaces: s.namespaces\n          }), await this.sendResult({\n            id: i,\n            topic: e,\n            result: !0,\n            throwOnFailedPublish: !0\n          });\n        } catch (a) {\n          throw re.delete(r), a;\n        }\n        this.client.events.emit(\"session_update\", {\n          id: i,\n          topic: e,\n          params: s\n        });\n      } catch (r) {\n        await this.sendError({\n          id: i,\n          topic: e,\n          error: r\n        }), this.client.logger.error(r);\n      }\n    }, this.isRequestOutOfSync = (e, t) => t.toString().slice(0, -3) < e.toString().slice(0, -3), this.onSessionUpdateResponse = (e, t) => {\n      const {\n          id: s\n        } = t,\n        i = g(\"session_update\", s);\n      if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);\n      K(t) ? this.events.emit(g(\"session_update\", s), {}) : U(t) && this.events.emit(g(\"session_update\", s), {\n        error: t.error\n      });\n    }, this.onSessionExtendRequest = async (e, t) => {\n      const {\n        id: s\n      } = t;\n      try {\n        this.isValidExtend({\n          topic: e\n        }), await this.setExpiry(e, b(H)), await this.sendResult({\n          id: s,\n          topic: e,\n          result: !0,\n          throwOnFailedPublish: !0\n        }), this.client.events.emit(\"session_extend\", {\n          id: s,\n          topic: e\n        });\n      } catch (i) {\n        await this.sendError({\n          id: s,\n          topic: e,\n          error: i\n        }), this.client.logger.error(i);\n      }\n    }, this.onSessionExtendResponse = (e, t) => {\n      const {\n          id: s\n        } = t,\n        i = g(\"session_extend\", s);\n      if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);\n      K(t) ? this.events.emit(g(\"session_extend\", s), {}) : U(t) && this.events.emit(g(\"session_extend\", s), {\n        error: t.error\n      });\n    }, this.onSessionPingRequest = async (e, t) => {\n      const {\n        id: s\n      } = t;\n      try {\n        this.isValidPing({\n          topic: e\n        }), await this.sendResult({\n          id: s,\n          topic: e,\n          result: !0,\n          throwOnFailedPublish: !0\n        }), this.client.events.emit(\"session_ping\", {\n          id: s,\n          topic: e\n        });\n      } catch (i) {\n        await this.sendError({\n          id: s,\n          topic: e,\n          error: i\n        }), this.client.logger.error(i);\n      }\n    }, this.onSessionPingResponse = (e, t) => {\n      const {\n          id: s\n        } = t,\n        i = g(\"session_ping\", s);\n      if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);\n      setTimeout(() => {\n        K(t) ? this.events.emit(g(\"session_ping\", s), {}) : U(t) && this.events.emit(g(\"session_ping\", s), {\n          error: t.error\n        });\n      }, 500);\n    }, this.onSessionDeleteRequest = async (e, t) => {\n      const {\n        id: s\n      } = t;\n      try {\n        this.isValidDisconnect({\n          topic: e,\n          reason: t.params\n        }), Promise.all([new Promise(i => {\n          this.client.core.relayer.once(Ge.publish, async () => {\n            i(await this.deleteSession({\n              topic: e,\n              id: s\n            }));\n          });\n        }), this.sendResult({\n          id: s,\n          topic: e,\n          result: !0,\n          throwOnFailedPublish: !0\n        }), this.cleanupPendingSentRequestsForTopic({\n          topic: e,\n          error: P(\"USER_DISCONNECTED\")\n        })]).catch(i => this.client.logger.error(i));\n      } catch (i) {\n        this.client.logger.error(i);\n      }\n    }, this.onSessionRequest = async e => {\n      var t, s, i;\n      const {\n          topic: r,\n          payload: n,\n          attestation: a,\n          encryptedId: c,\n          transportType: h\n        } = e,\n        {\n          id: p,\n          params: d\n        } = n;\n      try {\n        await this.isValidRequest(I({\n          topic: r\n        }, d));\n        const l = this.client.session.get(r),\n          w = await this.getVerifyContext({\n            attestationId: a,\n            hash: J(JSON.stringify(ge(\"wc_sessionRequest\", d, p))),\n            encryptedId: c,\n            metadata: l.peer.metadata,\n            transportType: h\n          }),\n          m = {\n            id: p,\n            topic: r,\n            params: d,\n            verifyContext: w\n          };\n        await this.setPendingSessionRequest(m), h === f.link_mode && (t = l.peer.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp((s = l.peer.metadata.redirect) == null ? void 0 : s.universal), (i = this.client.signConfig) != null && i.disableRequestQueue ? this.emitSessionRequest(m) : (this.addSessionRequestToSessionRequestQueue(m), this.processSessionRequestQueue());\n      } catch (l) {\n        await this.sendError({\n          id: p,\n          topic: r,\n          error: l\n        }), this.client.logger.error(l);\n      }\n    }, this.onSessionRequestResponse = (e, t) => {\n      const {\n          id: s\n        } = t,\n        i = g(\"session_request\", s);\n      if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);\n      K(t) ? this.events.emit(g(\"session_request\", s), {\n        result: t.result\n      }) : U(t) && this.events.emit(g(\"session_request\", s), {\n        error: t.error\n      });\n    }, this.onSessionEventRequest = async (e, t) => {\n      const {\n        id: s,\n        params: i\n      } = t;\n      try {\n        const r = `${e}_session_event_${i.event.name}`,\n          n = re.get(r);\n        if (n && this.isRequestOutOfSync(n, s)) {\n          this.client.logger.info(`Discarding out of sync request - ${s}`);\n          return;\n        }\n        this.isValidEmit(I({\n          topic: e\n        }, i)), this.client.events.emit(\"session_event\", {\n          id: s,\n          topic: e,\n          params: i\n        }), re.set(r, s);\n      } catch (r) {\n        await this.sendError({\n          id: s,\n          topic: e,\n          error: r\n        }), this.client.logger.error(r);\n      }\n    }, this.onSessionAuthenticateResponse = (e, t) => {\n      const {\n        id: s\n      } = t;\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionAuthenticateResponse\",\n        topic: e,\n        payload: t\n      }), K(t) ? this.events.emit(g(\"session_request\", s), {\n        result: t.result\n      }) : U(t) && this.events.emit(g(\"session_request\", s), {\n        error: t.error\n      });\n    }, this.onSessionAuthenticateRequest = async e => {\n      var t;\n      const {\n        topic: s,\n        payload: i,\n        attestation: r,\n        encryptedId: n,\n        transportType: a\n      } = e;\n      try {\n        const {\n            requester: c,\n            authPayload: h,\n            expiryTimestamp: p\n          } = i.params,\n          d = await this.getVerifyContext({\n            attestationId: r,\n            hash: J(JSON.stringify(i)),\n            encryptedId: n,\n            metadata: c.metadata,\n            transportType: a\n          }),\n          l = {\n            requester: c,\n            pairingTopic: s,\n            id: i.id,\n            authPayload: h,\n            verifyContext: d,\n            expiryTimestamp: p\n          };\n        await this.setAuthRequest(i.id, {\n          request: l,\n          pairingTopic: s,\n          transportType: a\n        }), a === f.link_mode && (t = c.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp(c.metadata.redirect.universal), this.client.events.emit(\"session_authenticate\", {\n          topic: s,\n          params: i.params,\n          id: i.id,\n          verifyContext: d\n        });\n      } catch (c) {\n        this.client.logger.error(c);\n        const h = i.params.requester.publicKey,\n          p = await this.client.core.crypto.generateKeyPair(),\n          d = this.getAppLinkIfEnabled(i.params.requester.metadata, a),\n          l = {\n            type: be,\n            receiverPublicKey: h,\n            senderPublicKey: p\n          };\n        await this.sendError({\n          id: i.id,\n          topic: s,\n          error: c,\n          encodeOpts: l,\n          rpcOpts: v.wc_sessionAuthenticate.autoReject,\n          appLink: d\n        });\n      }\n    }, this.addSessionRequestToSessionRequestQueue = e => {\n      this.sessionRequestQueue.queue.push(e);\n    }, this.cleanupAfterResponse = e => {\n      this.deletePendingSessionRequest(e.response.id, {\n        message: \"fulfilled\",\n        code: 0\n      }), setTimeout(() => {\n        this.sessionRequestQueue.state = x.idle, this.processSessionRequestQueue();\n      }, Te(this.requestQueueDelay));\n    }, this.cleanupPendingSentRequestsForTopic = ({\n      topic: e,\n      error: t\n    }) => {\n      const s = this.client.core.history.pending;\n      s.length > 0 && s.filter(i => i.topic === e && i.request.method === \"wc_sessionRequest\").forEach(i => {\n        const r = i.request.id,\n          n = g(\"session_request\", r);\n        if (this.events.listenerCount(n) === 0) throw new Error(`emitting ${n} without any listeners`);\n        this.events.emit(g(\"session_request\", i.request.id), {\n          error: t\n        });\n      });\n    }, this.processSessionRequestQueue = () => {\n      if (this.sessionRequestQueue.state === x.active) {\n        this.client.logger.info(\"session request queue is already active.\");\n        return;\n      }\n      const e = this.sessionRequestQueue.queue[0];\n      if (!e) {\n        this.client.logger.info(\"session request queue is empty.\");\n        return;\n      }\n      try {\n        this.sessionRequestQueue.state = x.active, this.emitSessionRequest(e);\n      } catch (t) {\n        this.client.logger.error(t);\n      }\n    }, this.emitSessionRequest = e => {\n      this.client.events.emit(\"session_request\", e);\n    }, this.onPairingCreated = e => {\n      if (e.methods && this.expectedPairingMethodMap.set(e.topic, e.methods), e.active) return;\n      const t = this.client.proposal.getAll().find(s => s.pairingTopic === e.topic);\n      t && this.onSessionProposeRequest({\n        topic: e.topic,\n        payload: ge(\"wc_sessionPropose\", {\n          requiredNamespaces: t.requiredNamespaces,\n          optionalNamespaces: t.optionalNamespaces,\n          relays: t.relays,\n          proposer: t.proposer,\n          sessionProperties: t.sessionProperties\n        }, t.id)\n      });\n    }, this.isValidConnect = async e => {\n      if (!L(e)) {\n        const {\n          message: a\n        } = u(\"MISSING_OR_INVALID\", `connect() params: ${JSON.stringify(e)}`);\n        throw new Error(a);\n      }\n      const {\n        pairingTopic: t,\n        requiredNamespaces: s,\n        optionalNamespaces: i,\n        sessionProperties: r,\n        relays: n\n      } = e;\n      if (ne(t) || (await this.isValidPairingTopic(t)), !Kt(n, !0)) {\n        const {\n          message: a\n        } = u(\"MISSING_OR_INVALID\", `connect() relays: ${n}`);\n        throw new Error(a);\n      }\n      !ne(s) && Ze(s) !== 0 && this.validateNamespaces(s, \"requiredNamespaces\"), !ne(i) && Ze(i) !== 0 && this.validateNamespaces(i, \"optionalNamespaces\"), ne(r) || this.validateSessionProps(r, \"sessionProperties\");\n    }, this.validateNamespaces = (e, t) => {\n      const s = Ut(e, \"connect()\", t);\n      if (s) throw new Error(s.message);\n    }, this.isValidApprove = async e => {\n      if (!L(e)) throw new Error(u(\"MISSING_OR_INVALID\", `approve() params: ${e}`).message);\n      const {\n        id: t,\n        namespaces: s,\n        relayProtocol: i,\n        sessionProperties: r\n      } = e;\n      this.checkRecentlyDeleted(t), await this.isValidProposalId(t);\n      const n = this.client.proposal.get(t),\n        a = Ae(s, \"approve()\");\n      if (a) throw new Error(a.message);\n      const c = et(n.requiredNamespaces, s, \"approve()\");\n      if (c) throw new Error(c.message);\n      if (!$(i, !0)) {\n        const {\n          message: h\n        } = u(\"MISSING_OR_INVALID\", `approve() relayProtocol: ${i}`);\n        throw new Error(h);\n      }\n      ne(r) || this.validateSessionProps(r, \"sessionProperties\");\n    }, this.isValidReject = async e => {\n      if (!L(e)) {\n        const {\n          message: i\n        } = u(\"MISSING_OR_INVALID\", `reject() params: ${e}`);\n        throw new Error(i);\n      }\n      const {\n        id: t,\n        reason: s\n      } = e;\n      if (this.checkRecentlyDeleted(t), await this.isValidProposalId(t), !Gt(s)) {\n        const {\n          message: i\n        } = u(\"MISSING_OR_INVALID\", `reject() reason: ${JSON.stringify(s)}`);\n        throw new Error(i);\n      }\n    }, this.isValidSessionSettleRequest = e => {\n      if (!L(e)) {\n        const {\n          message: c\n        } = u(\"MISSING_OR_INVALID\", `onSessionSettleRequest() params: ${e}`);\n        throw new Error(c);\n      }\n      const {\n        relay: t,\n        controller: s,\n        namespaces: i,\n        expiry: r\n      } = e;\n      if (!jt(t)) {\n        const {\n          message: c\n        } = u(\"MISSING_OR_INVALID\", \"onSessionSettleRequest() relay protocol should be a string\");\n        throw new Error(c);\n      }\n      const n = Ft(s, \"onSessionSettleRequest()\");\n      if (n) throw new Error(n.message);\n      const a = Ae(i, \"onSessionSettleRequest()\");\n      if (a) throw new Error(a.message);\n      if (B(r)) {\n        const {\n          message: c\n        } = u(\"EXPIRED\", \"onSessionSettleRequest()\");\n        throw new Error(c);\n      }\n    }, this.isValidUpdate = async e => {\n      if (!L(e)) {\n        const {\n          message: a\n        } = u(\"MISSING_OR_INVALID\", `update() params: ${e}`);\n        throw new Error(a);\n      }\n      const {\n        topic: t,\n        namespaces: s\n      } = e;\n      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);\n      const i = this.client.session.get(t),\n        r = Ae(s, \"update()\");\n      if (r) throw new Error(r.message);\n      const n = et(i.requiredNamespaces, s, \"update()\");\n      if (n) throw new Error(n.message);\n    }, this.isValidExtend = async e => {\n      if (!L(e)) {\n        const {\n          message: s\n        } = u(\"MISSING_OR_INVALID\", `extend() params: ${e}`);\n        throw new Error(s);\n      }\n      const {\n        topic: t\n      } = e;\n      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);\n    }, this.isValidRequest = async e => {\n      if (!L(e)) {\n        const {\n          message: a\n        } = u(\"MISSING_OR_INVALID\", `request() params: ${e}`);\n        throw new Error(a);\n      }\n      const {\n        topic: t,\n        request: s,\n        chainId: i,\n        expiry: r\n      } = e;\n      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);\n      const {\n        namespaces: n\n      } = this.client.session.get(t);\n      if (!tt(n, i)) {\n        const {\n          message: a\n        } = u(\"MISSING_OR_INVALID\", `request() chainId: ${i}`);\n        throw new Error(a);\n      }\n      if (!Qt(s)) {\n        const {\n          message: a\n        } = u(\"MISSING_OR_INVALID\", `request() ${JSON.stringify(s)}`);\n        throw new Error(a);\n      }\n      if (!zt(n, i, s.method)) {\n        const {\n          message: a\n        } = u(\"MISSING_OR_INVALID\", `request() method: ${s.method}`);\n        throw new Error(a);\n      }\n      if (r && !Ht(r, me)) {\n        const {\n          message: a\n        } = u(\"MISSING_OR_INVALID\", `request() expiry: ${r}. Expiry must be a number (in seconds) between ${me.min} and ${me.max}`);\n        throw new Error(a);\n      }\n    }, this.isValidRespond = async e => {\n      var t;\n      if (!L(e)) {\n        const {\n          message: r\n        } = u(\"MISSING_OR_INVALID\", `respond() params: ${e}`);\n        throw new Error(r);\n      }\n      const {\n        topic: s,\n        response: i\n      } = e;\n      try {\n        await this.isValidSessionTopic(s);\n      } catch (r) {\n        throw (t = e?.response) != null && t.id && this.cleanupAfterResponse(e), r;\n      }\n      if (!Yt(i)) {\n        const {\n          message: r\n        } = u(\"MISSING_OR_INVALID\", `respond() response: ${JSON.stringify(i)}`);\n        throw new Error(r);\n      }\n    }, this.isValidPing = async e => {\n      if (!L(e)) {\n        const {\n          message: s\n        } = u(\"MISSING_OR_INVALID\", `ping() params: ${e}`);\n        throw new Error(s);\n      }\n      const {\n        topic: t\n      } = e;\n      await this.isValidSessionOrPairingTopic(t);\n    }, this.isValidEmit = async e => {\n      if (!L(e)) {\n        const {\n          message: n\n        } = u(\"MISSING_OR_INVALID\", `emit() params: ${e}`);\n        throw new Error(n);\n      }\n      const {\n        topic: t,\n        event: s,\n        chainId: i\n      } = e;\n      await this.isValidSessionTopic(t);\n      const {\n        namespaces: r\n      } = this.client.session.get(t);\n      if (!tt(r, i)) {\n        const {\n          message: n\n        } = u(\"MISSING_OR_INVALID\", `emit() chainId: ${i}`);\n        throw new Error(n);\n      }\n      if (!Xt(s)) {\n        const {\n          message: n\n        } = u(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(s)}`);\n        throw new Error(n);\n      }\n      if (!Jt(r, i, s.name)) {\n        const {\n          message: n\n        } = u(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(s)}`);\n        throw new Error(n);\n      }\n    }, this.isValidDisconnect = async e => {\n      if (!L(e)) {\n        const {\n          message: s\n        } = u(\"MISSING_OR_INVALID\", `disconnect() params: ${e}`);\n        throw new Error(s);\n      }\n      const {\n        topic: t\n      } = e;\n      await this.isValidSessionOrPairingTopic(t);\n    }, this.isValidAuthenticate = e => {\n      const {\n        chains: t,\n        uri: s,\n        domain: i,\n        nonce: r\n      } = e;\n      if (!Array.isArray(t) || t.length === 0) throw new Error(\"chains is required and must be a non-empty array\");\n      if (!$(s, !1)) throw new Error(\"uri is required parameter\");\n      if (!$(i, !1)) throw new Error(\"domain is required parameter\");\n      if (!$(r, !1)) throw new Error(\"nonce is required parameter\");\n      if ([...new Set(t.map(a => Pe(a).namespace))].length > 1) throw new Error(\"Multi-namespace requests are not supported. Please request single namespace only.\");\n      const {\n        namespace: n\n      } = Pe(t[0]);\n      if (n !== \"eip155\") throw new Error(\"Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.\");\n    }, this.getVerifyContext = async e => {\n      const {\n          attestationId: t,\n          hash: s,\n          encryptedId: i,\n          metadata: r,\n          transportType: n\n        } = e,\n        a = {\n          verified: {\n            verifyUrl: r.verifyUrl || ft,\n            validation: \"UNKNOWN\",\n            origin: r.url || \"\"\n          }\n        };\n      try {\n        if (n === f.link_mode) {\n          const h = this.getAppLinkIfEnabled(r, n);\n          return a.verified.validation = h && new URL(h).origin === new URL(r.url).origin ? \"VALID\" : \"INVALID\", a;\n        }\n        const c = await this.client.core.verify.resolve({\n          attestationId: t,\n          hash: s,\n          encryptedId: i,\n          verifyUrl: r.verifyUrl\n        });\n        c && (a.verified.origin = c.origin, a.verified.isScam = c.isScam, a.verified.validation = c.origin === new URL(r.url).origin ? \"VALID\" : \"INVALID\");\n      } catch (c) {\n        this.client.logger.warn(c);\n      }\n      return this.client.logger.debug(`Verify context: ${JSON.stringify(a)}`), a;\n    }, this.validateSessionProps = (e, t) => {\n      Object.values(e).forEach(s => {\n        if (!$(s, !1)) {\n          const {\n            message: i\n          } = u(\"MISSING_OR_INVALID\", `${t} must be in Record<string, string> format. Received: ${JSON.stringify(s)}`);\n          throw new Error(i);\n        }\n      });\n    }, this.getPendingAuthRequest = e => {\n      const t = this.client.auth.requests.get(e);\n      return typeof t == \"object\" ? t : void 0;\n    }, this.addToRecentlyDeleted = (e, t) => {\n      if (this.recentlyDeletedMap.set(e, t), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {\n        let s = 0;\n        const i = this.recentlyDeletedLimit / 2;\n        for (const r of this.recentlyDeletedMap.keys()) {\n          if (s++ >= i) break;\n          this.recentlyDeletedMap.delete(r);\n        }\n      }\n    }, this.checkRecentlyDeleted = e => {\n      const t = this.recentlyDeletedMap.get(e);\n      if (t) {\n        const {\n          message: s\n        } = u(\"MISSING_OR_INVALID\", `Record was recently deleted - ${t}: ${e}`);\n        throw new Error(s);\n      }\n    }, this.isLinkModeEnabled = (e, t) => {\n      var s, i, r, n, a, c, h, p, d;\n      return !e || t !== f.link_mode ? !1 : ((i = (s = this.client.metadata) == null ? void 0 : s.redirect) == null ? void 0 : i.linkMode) === !0 && ((n = (r = this.client.metadata) == null ? void 0 : r.redirect) == null ? void 0 : n.universal) !== void 0 && ((c = (a = this.client.metadata) == null ? void 0 : a.redirect) == null ? void 0 : c.universal) !== \"\" && ((h = e?.redirect) == null ? void 0 : h.universal) !== void 0 && ((p = e?.redirect) == null ? void 0 : p.universal) !== \"\" && ((d = e?.redirect) == null ? void 0 : d.linkMode) === !0 && this.client.core.linkModeSupportedApps.includes(e.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < \"u\";\n    }, this.getAppLinkIfEnabled = (e, t) => {\n      var s;\n      return this.isLinkModeEnabled(e, t) ? (s = e?.redirect) == null ? void 0 : s.universal : void 0;\n    }, this.handleLinkModeMessage = ({\n      url: e\n    }) => {\n      if (!e || !e.includes(\"wc_ev\") || !e.includes(\"topic\")) return;\n      const t = st(e, \"topic\") || \"\",\n        s = decodeURIComponent(st(e, \"wc_ev\") || \"\"),\n        i = this.client.session.keys.includes(t);\n      i && this.client.session.update(t, {\n        transportType: f.link_mode\n      }), this.client.core.dispatchEnvelope({\n        topic: t,\n        message: s,\n        sessionExists: i\n      });\n    }, this.registerLinkModeListeners = async () => {\n      var e;\n      if (Bt() || Wt() && (e = this.client.metadata.redirect) != null && e.linkMode) {\n        const t = global == null ? void 0 : global.Linking;\n        if (typeof t < \"u\") {\n          t.addEventListener(\"url\", this.handleLinkModeMessage, this.client.name);\n          const s = await t.getInitialURL();\n          s && setTimeout(() => {\n            this.handleLinkModeMessage({\n              url: s\n            });\n          }, 50);\n        }\n      }\n    };\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: o\n      } = u(\"NOT_INITIALIZED\", this.name);\n      throw new Error(o);\n    }\n  }\n  async confirmOnlineStateOrThrow() {\n    await this.client.core.relayer.confirmOnlineStateOrThrow();\n  }\n  registerRelayerEvents() {\n    this.client.core.relayer.on(Ge.message, o => {\n      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(o) : this.onRelayMessage(o);\n    });\n  }\n  async onRelayMessage(o) {\n    const {\n        topic: e,\n        message: t,\n        attestation: s,\n        transportType: i\n      } = o,\n      {\n        publicKey: r\n      } = this.client.auth.authKeys.keys.includes(ae) ? this.client.auth.authKeys.get(ae) : {\n        responseTopic: void 0,\n        publicKey: void 0\n      },\n      n = await this.client.core.crypto.decode(e, t, {\n        receiverPublicKey: r,\n        encoding: i === f.link_mode ? ie : de\n      });\n    try {\n      os(n) ? (this.client.core.history.set(e, n), this.onRelayEventRequest({\n        topic: e,\n        payload: n,\n        attestation: s,\n        transportType: i,\n        encryptedId: J(t)\n      })) : as(n) ? (await this.client.core.history.resolve(n), await this.onRelayEventResponse({\n        topic: e,\n        payload: n,\n        transportType: i\n      }), this.client.core.history.delete(e, n.id)) : this.onRelayEventUnknownPayload({\n        topic: e,\n        payload: n,\n        transportType: i\n      });\n    } catch (a) {\n      this.client.logger.error(a);\n    }\n  }\n  registerExpirerEvents() {\n    this.client.core.expirer.on(vt.expired, async o => {\n      const {\n        topic: e,\n        id: t\n      } = Zt(o.target);\n      if (t && this.client.pendingRequest.keys.includes(t)) return await this.deletePendingSessionRequest(t, u(\"EXPIRED\"), !0);\n      if (t && this.client.auth.requests.keys.includes(t)) return await this.deletePendingAuthRequest(t, u(\"EXPIRED\"), !0);\n      e ? this.client.session.keys.includes(e) && (await this.deleteSession({\n        topic: e,\n        expirerHasDeleted: !0\n      }), this.client.events.emit(\"session_expire\", {\n        topic: e\n      })) : t && (await this.deleteProposal(t, !0), this.client.events.emit(\"proposal_expire\", {\n        id: t\n      }));\n    });\n  }\n  registerPairingEvents() {\n    this.client.core.pairing.events.on(je.create, o => this.onPairingCreated(o)), this.client.core.pairing.events.on(je.delete, o => {\n      this.addToRecentlyDeleted(o.topic, \"pairing\");\n    });\n  }\n  isValidPairingTopic(o) {\n    if (!$(o, !1)) {\n      const {\n        message: e\n      } = u(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${o}`);\n      throw new Error(e);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(o)) {\n      const {\n        message: e\n      } = u(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${o}`);\n      throw new Error(e);\n    }\n    if (B(this.client.core.pairing.pairings.get(o).expiry)) {\n      const {\n        message: e\n      } = u(\"EXPIRED\", `pairing topic: ${o}`);\n      throw new Error(e);\n    }\n  }\n  async isValidSessionTopic(o) {\n    if (!$(o, !1)) {\n      const {\n        message: e\n      } = u(\"MISSING_OR_INVALID\", `session topic should be a string: ${o}`);\n      throw new Error(e);\n    }\n    if (this.checkRecentlyDeleted(o), !this.client.session.keys.includes(o)) {\n      const {\n        message: e\n      } = u(\"NO_MATCHING_KEY\", `session topic doesn't exist: ${o}`);\n      throw new Error(e);\n    }\n    if (B(this.client.session.get(o).expiry)) {\n      await this.deleteSession({\n        topic: o\n      });\n      const {\n        message: e\n      } = u(\"EXPIRED\", `session topic: ${o}`);\n      throw new Error(e);\n    }\n    if (!this.client.core.crypto.keychain.has(o)) {\n      const {\n        message: e\n      } = u(\"MISSING_OR_INVALID\", `session topic does not exist in keychain: ${o}`);\n      throw await this.deleteSession({\n        topic: o\n      }), new Error(e);\n    }\n  }\n  async isValidSessionOrPairingTopic(o) {\n    if (this.checkRecentlyDeleted(o), this.client.session.keys.includes(o)) await this.isValidSessionTopic(o);else if (this.client.core.pairing.pairings.keys.includes(o)) this.isValidPairingTopic(o);else if ($(o, !1)) {\n      const {\n        message: e\n      } = u(\"NO_MATCHING_KEY\", `session or pairing topic doesn't exist: ${o}`);\n      throw new Error(e);\n    } else {\n      const {\n        message: e\n      } = u(\"MISSING_OR_INVALID\", `session or pairing topic should be a string: ${o}`);\n      throw new Error(e);\n    }\n  }\n  async isValidProposalId(o) {\n    if (!es(o)) {\n      const {\n        message: e\n      } = u(\"MISSING_OR_INVALID\", `proposal id should be a number: ${o}`);\n      throw new Error(e);\n    }\n    if (!this.client.proposal.keys.includes(o)) {\n      const {\n        message: e\n      } = u(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${o}`);\n      throw new Error(e);\n    }\n    if (B(this.client.proposal.get(o).expiryTimestamp)) {\n      await this.deleteProposal(o);\n      const {\n        message: e\n      } = u(\"EXPIRED\", `proposal id: ${o}`);\n      throw new Error(e);\n    }\n  }\n}\nclass Ss extends Y {\n  constructor(o, e) {\n    super(o, e, it, ye), this.core = o, this.logger = e;\n  }\n}\nclass wt extends Y {\n  constructor(o, e) {\n    super(o, e, nt, ye), this.core = o, this.logger = e;\n  }\n}\nclass Is extends Y {\n  constructor(o, e) {\n    super(o, e, at, ye, t => t.id), this.core = o, this.logger = e;\n  }\n}\nclass fs extends Y {\n  constructor(o, e) {\n    super(o, e, ht, oe, () => ae), this.core = o, this.logger = e;\n  }\n}\nclass vs extends Y {\n  constructor(o, e) {\n    super(o, e, dt, oe), this.core = o, this.logger = e;\n  }\n}\nclass qs extends Y {\n  constructor(o, e) {\n    super(o, e, ut, oe, t => t.id), this.core = o, this.logger = e;\n  }\n}\nclass Ts {\n  constructor(o, e) {\n    this.core = o, this.logger = e, this.authKeys = new fs(this.core, this.logger), this.pairingTopics = new vs(this.core, this.logger), this.requests = new qs(this.core, this.logger);\n  }\n  async init() {\n    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();\n  }\n}\nclass _e extends bt {\n  constructor(o) {\n    super(o), this.protocol = Ce, this.version = Le, this.name = we.name, this.events = new is(), this.on = (t, s) => this.events.on(t, s), this.once = (t, s) => this.events.once(t, s), this.off = (t, s) => this.events.off(t, s), this.removeListener = (t, s) => this.events.removeListener(t, s), this.removeAllListeners = t => this.events.removeAllListeners(t), this.connect = async t => {\n      try {\n        return await this.engine.connect(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.pair = async t => {\n      try {\n        return await this.engine.pair(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.approve = async t => {\n      try {\n        return await this.engine.approve(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.reject = async t => {\n      try {\n        return await this.engine.reject(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.update = async t => {\n      try {\n        return await this.engine.update(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.extend = async t => {\n      try {\n        return await this.engine.extend(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.request = async t => {\n      try {\n        return await this.engine.request(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.respond = async t => {\n      try {\n        return await this.engine.respond(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.ping = async t => {\n      try {\n        return await this.engine.ping(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.emit = async t => {\n      try {\n        return await this.engine.emit(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.disconnect = async t => {\n      try {\n        return await this.engine.disconnect(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.find = t => {\n      try {\n        return this.engine.find(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.getPendingSessionRequests = () => {\n      try {\n        return this.engine.getPendingSessionRequests();\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.authenticate = async (t, s) => {\n      try {\n        return await this.engine.authenticate(t, s);\n      } catch (i) {\n        throw this.logger.error(i.message), i;\n      }\n    }, this.formatAuthMessage = t => {\n      try {\n        return this.engine.formatAuthMessage(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.approveSessionAuthenticate = async t => {\n      try {\n        return await this.engine.approveSessionAuthenticate(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.rejectSessionAuthenticate = async t => {\n      try {\n        return await this.engine.rejectSessionAuthenticate(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.name = o?.name || we.name, this.metadata = o?.metadata || ts(), this.signConfig = o?.signConfig;\n    const e = typeof o?.logger < \"u\" && typeof o?.logger != \"string\" ? o.logger : Tt(Nt({\n      level: o?.logger || we.logger\n    }));\n    this.core = o?.core || new qt(o), this.logger = Pt(e, this.name), this.session = new wt(this.core, this.logger), this.proposal = new Ss(this.core, this.logger), this.pendingRequest = new Is(this.core, this.logger), this.engine = new Rs(this), this.auth = new Ts(this.core, this.logger);\n  }\n  static async init(o) {\n    const e = new _e(o);\n    return await e.initialize(), e;\n  }\n  get context() {\n    return Ot(this.logger);\n  }\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info(\"SignClient Initialization Success\"), setTimeout(() => {\n        this.engine.processRelayMessageCache();\n      }, Te(ze));\n    } catch (o) {\n      throw this.logger.info(\"SignClient Initialization Failure\"), this.logger.error(o.message), o;\n    }\n  }\n}\nconst Ns = wt,\n  Ps = _e;\nexport { pt as AUTH_CONTEXT, ht as AUTH_KEYS_CONTEXT, dt as AUTH_PAIRING_TOPIC_CONTEXT, lt as AUTH_PROTOCOL, ae as AUTH_PUBLIC_KEY_NAME, ut as AUTH_REQUEST_CONTEXT, oe as AUTH_STORAGE_PREFIX, gs as AUTH_VERSION, ot as ENGINE_CONTEXT, x as ENGINE_QUEUE_STATES, v as ENGINE_RPC_OPTS, hs as HISTORY_CONTEXT, ps as HISTORY_EVENTS, ds as HISTORY_STORAGE_VERSION, ct as METHODS_TO_VERIFY, it as PROPOSAL_CONTEXT, us as PROPOSAL_EXPIRY, rt as PROPOSAL_EXPIRY_MESSAGE, at as REQUEST_CONTEXT, nt as SESSION_CONTEXT, H as SESSION_EXPIRY, me as SESSION_REQUEST_EXPIRY_BOUNDARIES, xe as SIGN_CLIENT_CONTEXT, we as SIGN_CLIENT_DEFAULT, cs as SIGN_CLIENT_EVENTS, Ce as SIGN_CLIENT_PROTOCOL, ls as SIGN_CLIENT_STORAGE_OPTIONS, ye as SIGN_CLIENT_STORAGE_PREFIX, Le as SIGN_CLIENT_VERSION, Ns as SessionStore, Ps as SignClient, De as WALLETCONNECT_DEEPLINK_CHOICE, _e as default };\n//# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}