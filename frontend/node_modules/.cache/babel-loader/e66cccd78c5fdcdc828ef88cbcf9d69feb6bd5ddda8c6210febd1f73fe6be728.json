{"ast":null,"code":"/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha256';\nimport { createCurve } from './_shortw_utils.js';\nimport { createHasher } from './abstract/hash-to-curve.js';\nimport { Field } from './abstract/modular.js';\nimport { mapToCurveSimpleSWU } from './abstract/weierstrass.js';\n// NIST secp256r1 aka p256\n// https://www.secg.org/sec2-v2.pdf, https://neuromancer.sk/std/nist/P-256\nconst Fp256 = Field(BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'));\nconst CURVE_A = Fp256.create(BigInt('-3'));\nconst CURVE_B = BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b');\n// prettier-ignore\nexport const p256 = createCurve({\n  a: CURVE_A,\n  // Equation params: a, b\n  b: CURVE_B,\n  Fp: Fp256,\n  // Field: 2n**224n * (2n**32n-1n) + 2n**192n + 2n**96n-1n\n  // Curve order, total count of valid points in the field\n  n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),\n  // Base (generator) point (x, y)\n  Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),\n  Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),\n  h: BigInt(1),\n  lowS: false\n}, sha256);\nexport const secp256r1 = p256;\nconst mapSWU = /* @__PURE__ */(() => mapToCurveSimpleSWU(Fp256, {\n  A: CURVE_A,\n  B: CURVE_B,\n  Z: Fp256.create(BigInt('-10'))\n}))();\nconst htf = /* @__PURE__ */(() => createHasher(secp256r1.ProjectivePoint, scalars => mapSWU(scalars[0]), {\n  DST: 'P256_XMD:SHA-256_SSWU_RO_',\n  encodeDST: 'P256_XMD:SHA-256_SSWU_NU_',\n  p: Fp256.ORDER,\n  m: 1,\n  k: 128,\n  expand: 'xmd',\n  hash: sha256\n}))();\nexport const hashToCurve = /* @__PURE__ */(() => htf.hashToCurve)();\nexport const encodeToCurve = /* @__PURE__ */(() => htf.encodeToCurve)();\n//# sourceMappingURL=p256.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}