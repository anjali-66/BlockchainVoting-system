{"ast":null,"code":"import { NAME, VERSION } from '../sdk-info.js';\nimport { standardErrors } from '../core/error/errors.js';\nexport async function fetchRPCRequest(request, rpcUrl) {\n  const requestBody = Object.assign(Object.assign({}, request), {\n    jsonrpc: '2.0',\n    id: crypto.randomUUID()\n  });\n  const res = await window.fetch(rpcUrl, {\n    method: 'POST',\n    body: JSON.stringify(requestBody),\n    mode: 'cors',\n    headers: {\n      'Content-Type': 'application/json',\n      'X-Cbw-Sdk-Version': VERSION,\n      'X-Cbw-Sdk-Platform': NAME\n    }\n  });\n  const {\n    result,\n    error\n  } = await res.json();\n  if (error) throw error;\n  return result;\n}\nfunction getCoinbaseInjectedLegacyProvider() {\n  const window = globalThis;\n  return window.coinbaseWalletExtension;\n}\nfunction getInjectedEthereum() {\n  var _a, _b;\n  try {\n    const window = globalThis;\n    return (_a = window.ethereum) !== null && _a !== void 0 ? _a : (_b = window.top) === null || _b === void 0 ? void 0 : _b.ethereum;\n  } catch (_c) {\n    return undefined;\n  }\n}\nexport function getCoinbaseInjectedProvider({\n  metadata,\n  preference\n}) {\n  var _a, _b;\n  const {\n    appName,\n    appLogoUrl,\n    appChainIds\n  } = metadata;\n  if (preference.options !== 'smartWalletOnly') {\n    const extension = getCoinbaseInjectedLegacyProvider();\n    if (extension) {\n      (_a = extension.setAppInfo) === null || _a === void 0 ? void 0 : _a.call(extension, appName, appLogoUrl, appChainIds, preference);\n      return extension;\n    }\n  }\n  const ethereum = getInjectedEthereum();\n  if (ethereum === null || ethereum === void 0 ? void 0 : ethereum.isCoinbaseBrowser) {\n    (_b = ethereum.setAppInfo) === null || _b === void 0 ? void 0 : _b.call(ethereum, appName, appLogoUrl, appChainIds, preference);\n    return ethereum;\n  }\n  return undefined;\n}\n/**\n * Validates the arguments for an invalid request and returns an error if any validation fails.\n * Valid request args are defined here: https://eips.ethereum.org/EIPS/eip-1193#request\n * @param args The request arguments to validate.\n * @returns An error object if the arguments are invalid, otherwise undefined.\n */\nexport function checkErrorForInvalidRequestArgs(args) {\n  if (!args || typeof args !== 'object' || Array.isArray(args)) {\n    throw standardErrors.rpc.invalidParams({\n      message: 'Expected a single, non-array, object argument.',\n      data: args\n    });\n  }\n  const {\n    method,\n    params\n  } = args;\n  if (typeof method !== 'string' || method.length === 0) {\n    throw standardErrors.rpc.invalidParams({\n      message: \"'args.method' must be a non-empty string.\",\n      data: args\n    });\n  }\n  if (params !== undefined && !Array.isArray(params) && (typeof params !== 'object' || params === null)) {\n    throw standardErrors.rpc.invalidParams({\n      message: \"'args.params' must be an object or array if provided.\",\n      data: args\n    });\n  }\n  switch (method) {\n    case 'eth_sign':\n    case 'eth_signTypedData_v2':\n    case 'eth_subscribe':\n    case 'eth_unsubscribe':\n      throw standardErrors.provider.unsupportedMethod();\n  }\n}\n//# sourceMappingURL=provider.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}