{"ast":null,"code":"// Copyright (c) 2018-2024 Coinbase, Inc. <https://www.coinbase.com/>\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\nimport eip712 from '../../vendor-js/eth-eip712-util/index.cjs';\nimport { LOCAL_STORAGE_ADDRESSES_KEY } from './relay/constants.js';\nimport { isErrorResponse } from './relay/type/Web3Response.js';\nimport { WalletLinkRelay } from './relay/WalletLinkRelay.js';\nimport { WALLETLINK_URL } from '../../core/constants.js';\nimport { standardErrors } from '../../core/error/errors.js';\nimport { ScopedLocalStorage } from '../../core/storage/ScopedLocalStorage.js';\nimport { encodeToHexString, ensureAddressString, ensureBigInt, ensureBuffer, ensureIntNumber, ensureParsedJSONObject, hexStringFromBuffer, hexStringFromNumber } from '../../core/type/util.js';\nimport { fetchRPCRequest } from '../../util/provider.js';\nconst DEFAULT_CHAIN_ID_KEY = 'DefaultChainId';\nconst DEFAULT_JSON_RPC_URL = 'DefaultJsonRpcUrl';\n// original source: https://github.com/coinbase/coinbase-wallet-sdk/blob/v3.7.1/packages/wallet-sdk/src/provider/CoinbaseWalletProvider.ts\nexport class WalletLinkSigner {\n  constructor(options) {\n    this._relay = null;\n    this._addresses = [];\n    this.metadata = options.metadata;\n    this._storage = new ScopedLocalStorage('walletlink', WALLETLINK_URL);\n    this.callback = options.callback || null;\n    const cachedAddresses = this._storage.getItem(LOCAL_STORAGE_ADDRESSES_KEY);\n    if (cachedAddresses) {\n      const addresses = cachedAddresses.split(' ');\n      if (addresses[0] !== '') {\n        this._addresses = addresses.map(address => ensureAddressString(address));\n      }\n    }\n    this.initializeRelay();\n  }\n  getSession() {\n    const relay = this.initializeRelay();\n    const {\n      id,\n      secret\n    } = relay.getWalletLinkSession();\n    return {\n      id,\n      secret\n    };\n  }\n  async handshake() {\n    await this._eth_requestAccounts();\n  }\n  get selectedAddress() {\n    return this._addresses[0] || undefined;\n  }\n  get jsonRpcUrl() {\n    var _a;\n    return (_a = this._storage.getItem(DEFAULT_JSON_RPC_URL)) !== null && _a !== void 0 ? _a : undefined;\n  }\n  set jsonRpcUrl(value) {\n    this._storage.setItem(DEFAULT_JSON_RPC_URL, value);\n  }\n  updateProviderInfo(jsonRpcUrl, chainId) {\n    var _a;\n    this.jsonRpcUrl = jsonRpcUrl;\n    // emit chainChanged event if necessary\n    const originalChainId = this.getChainId();\n    this._storage.setItem(DEFAULT_CHAIN_ID_KEY, chainId.toString(10));\n    const chainChanged = ensureIntNumber(chainId) !== originalChainId;\n    if (chainChanged) {\n      (_a = this.callback) === null || _a === void 0 ? void 0 : _a.call(this, 'chainChanged', hexStringFromNumber(chainId));\n    }\n  }\n  async watchAsset(params) {\n    const request = Array.isArray(params) ? params[0] : params;\n    if (!request.type) {\n      throw standardErrors.rpc.invalidParams('Type is required');\n    }\n    if ((request === null || request === void 0 ? void 0 : request.type) !== 'ERC20') {\n      throw standardErrors.rpc.invalidParams(`Asset of type '${request.type}' is not supported`);\n    }\n    if (!(request === null || request === void 0 ? void 0 : request.options)) {\n      throw standardErrors.rpc.invalidParams('Options are required');\n    }\n    if (!(request === null || request === void 0 ? void 0 : request.options.address)) {\n      throw standardErrors.rpc.invalidParams('Address is required');\n    }\n    const chainId = this.getChainId();\n    const {\n      address,\n      symbol,\n      image,\n      decimals\n    } = request.options;\n    const relay = this.initializeRelay();\n    const result = await relay.watchAsset(request.type, address, symbol, decimals, image, chainId === null || chainId === void 0 ? void 0 : chainId.toString());\n    if (isErrorResponse(result)) return false;\n    return !!result.result;\n  }\n  async addEthereumChain(params) {\n    var _a, _b;\n    const request = params[0];\n    if (((_a = request.rpcUrls) === null || _a === void 0 ? void 0 : _a.length) === 0) {\n      throw standardErrors.rpc.invalidParams('please pass in at least 1 rpcUrl');\n    }\n    if (!request.chainName || request.chainName.trim() === '') {\n      throw standardErrors.rpc.invalidParams('chainName is a required field');\n    }\n    if (!request.nativeCurrency) {\n      throw standardErrors.rpc.invalidParams('nativeCurrency is a required field');\n    }\n    const chainIdNumber = Number.parseInt(request.chainId, 16);\n    if (chainIdNumber === this.getChainId()) {\n      return false;\n    }\n    const relay = this.initializeRelay();\n    const {\n      rpcUrls = [],\n      blockExplorerUrls = [],\n      chainName,\n      iconUrls = [],\n      nativeCurrency\n    } = request;\n    const res = await relay.addEthereumChain(chainIdNumber.toString(), rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency);\n    if (isErrorResponse(res)) return false;\n    if (((_b = res.result) === null || _b === void 0 ? void 0 : _b.isApproved) === true) {\n      this.updateProviderInfo(rpcUrls[0], chainIdNumber);\n      return null;\n    }\n    throw standardErrors.rpc.internal('unable to add ethereum chain');\n  }\n  async switchEthereumChain(params) {\n    const request = params[0];\n    const chainId = Number.parseInt(request.chainId, 16);\n    const relay = this.initializeRelay();\n    const res = await relay.switchEthereumChain(chainId.toString(10), this.selectedAddress || undefined);\n    if (isErrorResponse(res)) throw res;\n    const switchResponse = res.result;\n    if (switchResponse.isApproved && switchResponse.rpcUrl.length > 0) {\n      this.updateProviderInfo(switchResponse.rpcUrl, chainId);\n    }\n    return null;\n  }\n  async cleanup() {\n    this.callback = null;\n    if (this._relay) {\n      this._relay.resetAndReload();\n    }\n    this._storage.clear();\n  }\n  _setAddresses(addresses, _) {\n    var _a;\n    if (!Array.isArray(addresses)) {\n      throw new Error('addresses is not an array');\n    }\n    const newAddresses = addresses.map(address => ensureAddressString(address));\n    if (JSON.stringify(newAddresses) === JSON.stringify(this._addresses)) {\n      return;\n    }\n    this._addresses = newAddresses;\n    (_a = this.callback) === null || _a === void 0 ? void 0 : _a.call(this, 'accountsChanged', newAddresses);\n    this._storage.setItem(LOCAL_STORAGE_ADDRESSES_KEY, newAddresses.join(' '));\n  }\n  async request(request) {\n    const params = request.params || [];\n    switch (request.method) {\n      case 'eth_accounts':\n        return [...this._addresses];\n      case 'eth_coinbase':\n        return this.selectedAddress || null;\n      case 'net_version':\n        return this.getChainId().toString(10);\n      case 'eth_chainId':\n        return hexStringFromNumber(this.getChainId());\n      case 'eth_requestAccounts':\n        return this._eth_requestAccounts();\n      case 'eth_ecRecover':\n      case 'personal_ecRecover':\n        return this.ecRecover(request);\n      case 'personal_sign':\n        return this.personalSign(request);\n      case 'eth_signTransaction':\n        return this._eth_signTransaction(params);\n      case 'eth_sendRawTransaction':\n        return this._eth_sendRawTransaction(params);\n      case 'eth_sendTransaction':\n        return this._eth_sendTransaction(params);\n      case 'eth_signTypedData_v1':\n      case 'eth_signTypedData_v3':\n      case 'eth_signTypedData_v4':\n      case 'eth_signTypedData':\n        return this.signTypedData(request);\n      case 'wallet_addEthereumChain':\n        return this.addEthereumChain(params);\n      case 'wallet_switchEthereumChain':\n        return this.switchEthereumChain(params);\n      case 'wallet_watchAsset':\n        return this.watchAsset(params);\n      default:\n        if (!this.jsonRpcUrl) throw standardErrors.rpc.internal('No RPC URL set for chain');\n        return fetchRPCRequest(request, this.jsonRpcUrl);\n    }\n  }\n  _ensureKnownAddress(addressString) {\n    const addressStr = ensureAddressString(addressString);\n    const lowercaseAddresses = this._addresses.map(address => ensureAddressString(address));\n    if (!lowercaseAddresses.includes(addressStr)) {\n      throw new Error('Unknown Ethereum address');\n    }\n  }\n  _prepareTransactionParams(tx) {\n    const fromAddress = tx.from ? ensureAddressString(tx.from) : this.selectedAddress;\n    if (!fromAddress) {\n      throw new Error('Ethereum address is unavailable');\n    }\n    this._ensureKnownAddress(fromAddress);\n    const toAddress = tx.to ? ensureAddressString(tx.to) : null;\n    const weiValue = tx.value != null ? ensureBigInt(tx.value) : BigInt(0);\n    const data = tx.data ? ensureBuffer(tx.data) : Buffer.alloc(0);\n    const nonce = tx.nonce != null ? ensureIntNumber(tx.nonce) : null;\n    const gasPriceInWei = tx.gasPrice != null ? ensureBigInt(tx.gasPrice) : null;\n    const maxFeePerGas = tx.maxFeePerGas != null ? ensureBigInt(tx.maxFeePerGas) : null;\n    const maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? ensureBigInt(tx.maxPriorityFeePerGas) : null;\n    const gasLimit = tx.gas != null ? ensureBigInt(tx.gas) : null;\n    const chainId = tx.chainId ? ensureIntNumber(tx.chainId) : this.getChainId();\n    return {\n      fromAddress,\n      toAddress,\n      weiValue,\n      data,\n      nonce,\n      gasPriceInWei,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      gasLimit,\n      chainId\n    };\n  }\n  async ecRecover(request) {\n    const {\n      method,\n      params\n    } = request;\n    if (!Array.isArray(params)) throw standardErrors.rpc.invalidParams();\n    const relay = this.initializeRelay();\n    const res = await relay.sendRequest({\n      method: 'ethereumAddressFromSignedMessage',\n      params: {\n        message: encodeToHexString(params[0]),\n        signature: encodeToHexString(params[1]),\n        addPrefix: method === 'personal_ecRecover'\n      }\n    });\n    if (isErrorResponse(res)) throw res;\n    return res.result;\n  }\n  getChainId() {\n    var _a;\n    return Number.parseInt((_a = this._storage.getItem(DEFAULT_CHAIN_ID_KEY)) !== null && _a !== void 0 ? _a : '1', 10);\n  }\n  async _eth_requestAccounts() {\n    var _a, _b;\n    if (this._addresses.length > 0) {\n      (_a = this.callback) === null || _a === void 0 ? void 0 : _a.call(this, 'connect', {\n        chainId: hexStringFromNumber(this.getChainId())\n      });\n      return this._addresses;\n    }\n    const relay = this.initializeRelay();\n    const res = await relay.requestEthereumAccounts();\n    if (isErrorResponse(res)) throw res;\n    if (!res.result) {\n      throw new Error('accounts received is empty');\n    }\n    this._setAddresses(res.result);\n    (_b = this.callback) === null || _b === void 0 ? void 0 : _b.call(this, 'connect', {\n      chainId: hexStringFromNumber(this.getChainId())\n    });\n    return this._addresses;\n  }\n  async personalSign({\n    params\n  }) {\n    if (!Array.isArray(params)) throw standardErrors.rpc.invalidParams();\n    const address = params[1];\n    const rawData = params[0];\n    this._ensureKnownAddress(address);\n    const relay = this.initializeRelay();\n    const res = await relay.sendRequest({\n      method: 'signEthereumMessage',\n      params: {\n        address: ensureAddressString(address),\n        message: encodeToHexString(rawData),\n        addPrefix: true,\n        typedDataJson: null\n      }\n    });\n    if (isErrorResponse(res)) throw res;\n    return res.result;\n  }\n  async _eth_signTransaction(params) {\n    const tx = this._prepareTransactionParams(params[0] || {});\n    const relay = this.initializeRelay();\n    const res = await relay.signEthereumTransaction(tx);\n    if (isErrorResponse(res)) throw res;\n    return res.result;\n  }\n  async _eth_sendRawTransaction(params) {\n    const signedTransaction = ensureBuffer(params[0]);\n    const relay = this.initializeRelay();\n    const res = await relay.submitEthereumTransaction(signedTransaction, this.getChainId());\n    if (isErrorResponse(res)) throw res;\n    return res.result;\n  }\n  async _eth_sendTransaction(params) {\n    const tx = this._prepareTransactionParams(params[0] || {});\n    const relay = this.initializeRelay();\n    const res = await relay.signAndSubmitEthereumTransaction(tx);\n    if (isErrorResponse(res)) throw res;\n    return res.result;\n  }\n  async signTypedData(request) {\n    const {\n      method,\n      params\n    } = request;\n    if (!Array.isArray(params)) throw standardErrors.rpc.invalidParams();\n    const encode = input => {\n      const hashFuncMap = {\n        eth_signTypedData_v1: eip712.hashForSignTypedDataLegacy,\n        eth_signTypedData_v3: eip712.hashForSignTypedData_v3,\n        eth_signTypedData_v4: eip712.hashForSignTypedData_v4,\n        eth_signTypedData: eip712.hashForSignTypedData_v4\n      };\n      return hexStringFromBuffer(hashFuncMap[method]({\n        data: ensureParsedJSONObject(input)\n      }), true);\n    };\n    const address = params[method === 'eth_signTypedData_v1' ? 1 : 0];\n    const rawData = params[method === 'eth_signTypedData_v1' ? 0 : 1];\n    this._ensureKnownAddress(address);\n    const relay = this.initializeRelay();\n    const res = await relay.sendRequest({\n      method: 'signEthereumMessage',\n      params: {\n        address: ensureAddressString(address),\n        message: encode(rawData),\n        typedDataJson: JSON.stringify(rawData, null, 2),\n        addPrefix: false\n      }\n    });\n    if (isErrorResponse(res)) throw res;\n    return res.result;\n  }\n  initializeRelay() {\n    if (!this._relay) {\n      this._relay = new WalletLinkRelay({\n        linkAPIUrl: WALLETLINK_URL,\n        storage: this._storage,\n        metadata: this.metadata,\n        accountsCallback: this._setAddresses.bind(this),\n        chainCallback: this.updateProviderInfo.bind(this)\n      });\n    }\n    return this._relay;\n  }\n}\n//# sourceMappingURL=WalletLinkSigner.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}