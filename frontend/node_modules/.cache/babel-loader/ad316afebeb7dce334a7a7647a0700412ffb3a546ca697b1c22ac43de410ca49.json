{"ast":null,"code":"import { generateMnemonic, mnemonicToSeedSync, validateMnemonic } from '@scure/bip39';\nimport * as Bytes from './Bytes.js';\nimport * as HdKey from './HdKey.js';\nexport { path } from './HdKey.js';\nexport { english, czech, french, italian, japanese, korean, portuguese, simplifiedChinese, spanish, traditionalChinese } from './internal/mnemonic/wordlists.js';\n/**\n * Generates a random mnemonic.\n *\n * @example\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * // @log: 'buyer zoo end danger ice capable shrug naive twist relief mass bonus'\n * ```\n *\n * @param wordlist - The wordlist to use.\n * @param options - Generation options.\n * @returns The mnemonic.\n */\nexport function random(wordlist, options = {}) {\n  const {\n    strength = 128\n  } = options;\n  return generateMnemonic(wordlist, strength);\n}\n/**\n * Converts a mnemonic to a HD Key.\n *\n * @example\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * const hdKey = Mnemonic.toHdKey(mnemonic)\n * ```\n *\n * @example\n * ### Path Derivation\n *\n * You can derive a HD Key at a specific path using `derive`:\n *\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * const hdKey = Mnemonic.toHdKey(mnemonic).derive(Mnemonic.path({ index: 1 }))\n * ```\n *\n * @param mnemonic - The mnemonic to convert.\n * @param options - Conversion options.\n * @returns The HD Key.\n */\nexport function toHdKey(mnemonic, options = {}) {\n  const {\n    passphrase\n  } = options;\n  const seed = toSeed(mnemonic, {\n    passphrase\n  });\n  return HdKey.fromSeed(seed);\n}\n/**\n * Converts a mnemonic to a private key.\n *\n * @example\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * const privateKey = Mnemonic.toPrivateKey(mnemonic)\n * // @log: '0x...'\n * ```\n *\n * @example\n * ### Paths\n *\n * You can derive a private key at a specific path using the `path` option.\n *\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * const privateKey = Mnemonic.toPrivateKey(mnemonic, {\n *   path: Mnemonic.path({ index: 1 }) // 'm/44'/60'/0'/0/1' // [!code focus]\n * })\n * // @log: '0x...'\n * ```\n *\n * @param mnemonic - The mnemonic to convert.\n * @param options - Conversion options.\n * @returns The private key.\n */\nexport function toPrivateKey(mnemonic, options = {}) {\n  const {\n    path = HdKey.path(),\n    passphrase\n  } = options;\n  const hdKey = toHdKey(mnemonic, {\n    passphrase\n  }).derive(path);\n  if (options.as === 'Bytes') return Bytes.from(hdKey.privateKey);\n  return hdKey.privateKey;\n}\n/**\n * Converts a mnemonic to a master seed.\n *\n * @example\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.random(Mnemonic.english)\n * const seed = Mnemonic.toSeed(mnemonic)\n * // @log: Uint8Array [...64 bytes]\n * ```\n *\n * @param mnemonic - The mnemonic to convert.\n * @param options - Conversion options.\n * @returns The master seed.\n */\nexport function toSeed(mnemonic, options = {}) {\n  const {\n    passphrase\n  } = options;\n  const seed = mnemonicToSeedSync(mnemonic, passphrase);\n  if (options.as === 'Hex') return Bytes.toHex(seed);\n  return seed;\n}\n/**\n * Checks if a mnemonic is valid, given a wordlist.\n *\n * @example\n * ```ts twoslash\n * import { Mnemonic } from 'ox'\n *\n * const mnemonic = Mnemonic.validate(\n *   'buyer zoo end danger ice capable shrug naive twist relief mass bonus',\n *   Mnemonic.english\n * )\n * // @log: true\n * ```\n *\n * @param mnemonic - The mnemonic to validate.\n * @param wordlist - The wordlist to use.\n * @returns Whether the mnemonic is valid.\n */\nexport function validate(mnemonic, wordlist) {\n  return validateMnemonic(mnemonic, wordlist);\n}\n//# sourceMappingURL=Mnemonic.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}