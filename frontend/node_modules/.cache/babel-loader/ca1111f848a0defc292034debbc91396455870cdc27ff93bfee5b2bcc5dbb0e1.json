{"ast":null,"code":"// original source: https://github.com/kriszyp/cbor-x/blob/master/decode.js\n// heavily modified to remove all non-essential code\n// TODO: re-enable typescript and properly type this\n// @ts-nocheck - TODO: re-enable typescript and properly type this\nlet src;\nlet srcEnd;\nlet position = 0;\nconst EMPTY_ARRAY = [];\nlet strings = EMPTY_ARRAY;\nlet stringPosition = 0;\nlet currentDecoder = {};\nlet currentStructures;\nlet srcString;\nconst srcStringStart = 0;\nlet srcStringEnd = 0;\nlet bundledStrings;\nlet referenceMap;\nconst currentExtensions = [];\nlet packedValues;\nlet dataView;\nconst defaultOptions = {\n  useRecords: false,\n  mapsAsObjects: true\n};\nfunction readFixedString(length) {\n  let result;\n  if (length < 16) {\n    if (result = shortStringInJS(length)) return result;\n  }\n  if (length > 64 && decoder) return decoder.decode(src.subarray(position, position += length));\n  const end = position + length;\n  const units = [];\n  result = '';\n  while (position < end) {\n    const byte1 = src[position++];\n    if ((byte1 & 0x80) === 0) {\n      // 1 byte\n      units.push(byte1);\n    } else if ((byte1 & 0xe0) === 0xc0) {\n      // 2 bytes\n      const byte2 = src[position++] & 0x3f;\n      units.push((byte1 & 0x1f) << 6 | byte2);\n    } else if ((byte1 & 0xf0) === 0xe0) {\n      // 3 bytes\n      const byte2 = src[position++] & 0x3f;\n      const byte3 = src[position++] & 0x3f;\n      units.push((byte1 & 0x1f) << 12 | byte2 << 6 | byte3);\n    } else if ((byte1 & 0xf8) === 0xf0) {\n      // 4 bytes\n      const byte2 = src[position++] & 0x3f;\n      const byte3 = src[position++] & 0x3f;\n      const byte4 = src[position++] & 0x3f;\n      let unit = (byte1 & 0x07) << 0x12 | byte2 << 0x0c | byte3 << 0x06 | byte4;\n      if (unit > 0xffff) {\n        unit -= 0x10000;\n        units.push(unit >>> 10 & 0x3ff | 0xd800);\n        unit = 0xdc00 | unit & 0x3ff;\n      }\n      units.push(unit);\n    } else {\n      units.push(byte1);\n    }\n    if (units.length >= 0x1000) {\n      result += fromCharCode.apply(String, units);\n      units.length = 0;\n    }\n  }\n  if (units.length > 0) {\n    result += fromCharCode.apply(String, units);\n  }\n  return result;\n}\nclass Decoder {\n  constructor() {\n    Object.assign(this, defaultOptions);\n  }\n  decodeKey(key) {\n    return key;\n  }\n  decode(source, end = -1) {\n    srcEnd = end > -1 ? end : source.length;\n    position = 0;\n    stringPosition = 0;\n    srcStringEnd = 0;\n    srcString = null;\n    strings = EMPTY_ARRAY;\n    bundledStrings = null;\n    src = source;\n    // this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n    // technique for getting data from a database where it can be copied into an existing buffer instead of creating\n    // new ones\n    try {\n      dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));\n    } catch (error) {\n      // if it doesn't have a buffer, maybe it is the wrong type of object\n      src = null;\n      if (source instanceof Uint8Array) {\n        throw error;\n      }\n      throw new Error(`Source must be a Uint8Array or Buffer but was a ${source && typeof source === \"object\" ? source.constructor.name : typeof source}`);\n    }\n    if (this instanceof Decoder) {\n      currentDecoder = this;\n      packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);\n      if (!currentStructures || currentStructures.length > 0) {\n        currentStructures = [];\n      }\n    } else {\n      currentDecoder = defaultOptions;\n      if (!currentStructures || currentStructures.length > 0) {\n        currentStructures = [];\n      }\n      packedValues = null;\n    }\n    return checkedRead();\n  }\n}\nfunction checkedRead() {\n  try {\n    const result = read();\n    if (bundledStrings) {\n      if (position >= bundledStrings.postBundlePosition) {\n        const error = new Error(\"Unexpected bundle position\");\n        error.incomplete = true;\n        throw error;\n      }\n      // bundled strings to skip past\n      position = bundledStrings.postBundlePosition;\n      bundledStrings = null;\n    }\n    if (position === srcEnd) {\n      // finished reading this source, cleanup references\n      currentStructures = null;\n      src = null;\n      if (referenceMap) {\n        referenceMap = null;\n      }\n    } else if (position > srcEnd) {\n      // over read\n      const error = new Error(\"Unexpected end of CBOR data\");\n      error.incomplete = true;\n      throw error;\n    } else {\n      throw new Error(\"Data read, but end of buffer not reached\");\n    }\n    // else more to read, but we are reading sequentially, so don't clear source yet\n    return result;\n  } catch (error) {\n    clearSource();\n    if (error instanceof RangeError || error.message.startsWith(\"Unexpected end of buffer\")) {\n      error.incomplete = true;\n    }\n    throw error;\n  }\n}\nfunction read() {\n  let token = src[position++];\n  const majorType = token >> 5;\n  token = token & 0x1f;\n  if (token > 0x17) {\n    switch (token) {\n      case 0x18:\n        token = src[position++];\n        break;\n      default:\n        throw new Error(`Unknown token ${token}`);\n    }\n  }\n  switch (majorType) {\n    case 0:\n      // positive int\n      return token;\n    case 1:\n      // negative int\n      return ~token;\n    case 2:\n      // buffer\n      return readBin(token);\n    case 3:\n      // string\n      if (srcStringEnd >= position) {\n        return srcString.slice(position - srcStringStart, (position += token) - srcStringStart);\n      }\n      if (srcStringEnd === 0 && srcEnd < 140 && token < 32) {\n        // for small blocks, avoiding the overhead of the extract call is helpful\n        const string = token < 16 ? shortStringInJS(token) : longStringInJS(token);\n        if (string !== null) {\n          return string;\n        }\n      }\n      return readFixedString(token);\n    case 4:\n      {\n        // array\n        const array = new Array(token);\n        for (let i = 0; i < token; i++) {\n          array[i] = read();\n        }\n        return array;\n      }\n    case 5:\n      {\n        // map\n        const object = {};\n        for (let i = 0; i < token; i++) {\n          object[safeKey(read())] = read();\n        }\n        return object;\n      }\n    default:\n      // negative int\n      if (Number.isNaN(token)) {\n        const error = new Error(\"Unexpected end of CBOR data\");\n        error.incomplete = true;\n        throw error;\n      }\n      throw new Error(`Unknown CBOR token ${token}`);\n  }\n}\nfunction safeKey(key) {\n  // protect against prototype pollution\n  if (typeof key === \"string\") {\n    return key === \"__proto__\" ? \"__proto_\" : key;\n  }\n  if (typeof key !== \"object\") {\n    return key.toString();\n  }\n  // protect against expensive (DoS) string conversions\n  throw new Error(`Invalid property name type ${typeof key}`);\n}\nconst fromCharCode = String.fromCharCode;\nfunction longStringInJS(length) {\n  const start = position;\n  const bytes = new Array(length);\n  for (let i = 0; i < length; i++) {\n    const byte = src[position++];\n    if ((byte & 0x80) > 0) {\n      position = start;\n      return;\n    }\n    bytes[i] = byte;\n  }\n  return fromCharCode.apply(String, bytes);\n}\nfunction shortStringInJS(length) {\n  if (length < 4) {\n    if (length < 2) {\n      if (length === 0) {\n        return \"\";\n      }\n      const a = src[position++];\n      if ((a & 0x80) > 1) {\n        position -= 1;\n        return;\n      }\n      return fromCharCode(a);\n    }\n    const a = src[position++];\n    const b = src[position++];\n    if ((a & 0x80) > 0 || (b & 0x80) > 0) {\n      position -= 2;\n      return;\n    }\n    if (length < 3) {\n      return fromCharCode(a, b);\n    }\n    const c = src[position++];\n    if ((c & 0x80) > 0) {\n      position -= 3;\n      return;\n    }\n    return fromCharCode(a, b, c);\n  }\n  const a = src[position++];\n  const b = src[position++];\n  const c = src[position++];\n  const d = src[position++];\n  if ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n    position -= 4;\n    return;\n  }\n  if (length < 6) {\n    if (length === 4) {\n      return fromCharCode(a, b, c, d);\n    }\n    const e = src[position++];\n    if ((e & 0x80) > 0) {\n      position -= 5;\n      return;\n    }\n    return fromCharCode(a, b, c, d, e);\n  }\n  if (length < 8) {\n    const e = src[position++];\n    const f = src[position++];\n    if ((e & 0x80) > 0 || (f & 0x80) > 0) {\n      position -= 6;\n      return;\n    }\n    if (length < 7) {\n      return fromCharCode(a, b, c, d, e, f);\n    }\n    const g = src[position++];\n    if ((g & 0x80) > 0) {\n      position -= 7;\n      return;\n    }\n    return fromCharCode(a, b, c, d, e, f, g);\n  }\n  const e = src[position++];\n  const f = src[position++];\n  const g = src[position++];\n  const h = src[position++];\n  if ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n    position -= 8;\n    return;\n  }\n  if (length < 10) {\n    if (length === 8) {\n      return fromCharCode(a, b, c, d, e, f, g, h);\n    }\n    const i = src[position++];\n    if ((i & 0x80) > 0) {\n      position -= 9;\n      return;\n    }\n    return fromCharCode(a, b, c, d, e, f, g, h, i);\n  }\n  if (length < 12) {\n    const i = src[position++];\n    const j = src[position++];\n    if ((i & 0x80) > 0 || (j & 0x80) > 0) {\n      position -= 10;\n      return;\n    }\n    if (length < 11) {\n      return fromCharCode(a, b, c, d, e, f, g, h, i, j);\n    }\n    const k = src[position++];\n    if ((k & 0x80) > 0) {\n      position -= 11;\n      return;\n    }\n    return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);\n  }\n  const i = src[position++];\n  const j = src[position++];\n  const k = src[position++];\n  const l = src[position++];\n  if ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n    position -= 12;\n    return;\n  }\n  if (length < 14) {\n    if (length === 12) {\n      return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);\n    }\n    const m = src[position++];\n    if ((m & 0x80) > 0) {\n      position -= 13;\n      return;\n    }\n    return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);\n  }\n  const m = src[position++];\n  const n = src[position++];\n  if ((m & 0x80) > 0 || (n & 0x80) > 0) {\n    position -= 14;\n    return;\n  }\n  if (length < 15) {\n    return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);\n  }\n  const o = src[position++];\n  if ((o & 0x80) > 0) {\n    position -= 15;\n    return;\n  }\n  return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);\n}\nfunction readBin(length) {\n  return currentDecoder.copyBuffers ?\n  // specifically use the copying slice (not the node one)\n  Uint8Array.prototype.slice.call(src, position, position += length) : src.subarray(position, position += length);\n}\nconst glbl = {\n  Error,\n  RegExp\n};\ncurrentExtensions[27] = data => {\n  // http://cbor.schmorp.de/generic-object\n  return (glbl[data[0]] || Error)(data[1], data[2]);\n};\nconst packedTable = read_ => {\n  if (src[position++] !== 0x84) {\n    const error = new Error(\"Packed values structure must be followed by a 4 element array\");\n    if (src.length < position) {\n      error.incomplete = true;\n    }\n    throw error;\n  }\n  const newPackedValues = read_(); // packed values\n  if (!newPackedValues || !newPackedValues.length) {\n    const error = new Error(\"Packed values structure must be followed by a 4 element array\");\n    error.incomplete = true;\n    throw error;\n  }\n  packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;\n  packedValues.prefixes = read_();\n  packedValues.suffixes = read_();\n  return read_(); // read the rump\n};\npackedTable.handlesRead = true;\ncurrentExtensions[28] = read_ => {\n  // shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n  if (!referenceMap) {\n    referenceMap = new Map();\n    referenceMap.id = 0;\n  }\n  const id = referenceMap.id++;\n  const token = src[position];\n  let target;\n  // TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n  // ahead past references to record structure definitions\n  if (token >> 5 === 4) {\n    target = [];\n  } else {\n    target = {};\n  }\n  const refEntry = {\n    target\n  }; // a placeholder object\n  referenceMap.set(id, refEntry);\n  const targetProperties = read_(); // read the next value as the target object to id\n  if (refEntry.used) {\n    // there is a cycle, so we have to assign properties to original target\n    return Object.assign(target, targetProperties);\n  }\n  refEntry.target = targetProperties; // the placeholder wasn't used, replace with the deserialized one\n  return targetProperties; // no cycle, can just use the returned read object\n};\nfunction clearSource() {\n  src = null;\n  referenceMap = null;\n  currentStructures = null;\n}\nconst mult10 = new Array(147); // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n  mult10[i] = /* @__PURE__ */(() => Number(`1e${Math.floor(45.15 - i * 0.30103)}`))();\n}\nconst defaultDecoder = new Decoder();\nexport const decode = defaultDecoder.decode;\n//# sourceMappingURL=cbor-decode.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}