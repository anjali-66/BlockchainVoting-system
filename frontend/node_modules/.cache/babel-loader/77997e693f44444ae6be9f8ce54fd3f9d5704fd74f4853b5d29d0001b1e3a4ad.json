{"ast":null,"code":"import { formatTransactionRequest } from \"viem\";\nimport { roundUpGas } from \"../../gas/op-gas-fee-reducer.js\";\nimport { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport { extractError } from \"../extract-error.js\";\nconst cache = new WeakMap();\n/**\n * Estimates the gas required to execute a transaction. The gas is returned as a `bigint` and in gwei units.\n * @param options - The options for estimating gas.\n * @returns A promise that resolves to the estimated gas as a bigint.\n * @transaction\n * @example\n * ```ts\n * import { estimateGas } from \"thirdweb\";\n * const gas = await estimateGas({\n *  transaction,\n *  from: \"0x...\",\n * });\n * ```\n */\nexport async function estimateGas(options) {\n  // from is:\n  // 1. the user specified from address\n  // 2. the passed in account address\n  // 3. the passed in wallet's account address\n  const from = options.from ?? options.account?.address ?? undefined;\n  const txWithFrom = {\n    ...options.transaction,\n    from\n  };\n  if (cache.has(txWithFrom)) {\n    // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set\n    return cache.get(txWithFrom);\n  }\n  const {\n    account\n  } = options;\n  const promise = (async () => {\n    const predefinedGas = await resolvePromisedValue(options.transaction.gas);\n    // if we have a predefined gas value in the TX -> always use that\n    if (predefinedGas !== undefined) {\n      return predefinedGas;\n    }\n    // if the wallet itself overrides the estimateGas function, use that\n    if (account?.estimateGas) {\n      try {\n        let gas = await account.estimateGas(options.transaction);\n        if (options.transaction.chain.experimental?.increaseZeroByteCount) {\n          gas = roundUpGas(gas);\n        }\n        return gas;\n      } catch (error) {\n        throw await extractError({\n          error,\n          contract: options.transaction.__contract\n        });\n      }\n    }\n    // load up encode function if we need it\n    const {\n      encode\n    } = await import(\"./encode.js\");\n    const [encodedData, toAddress, value] = await Promise.all([encode(options.transaction), resolvePromisedValue(options.transaction.to), resolvePromisedValue(options.transaction.value)]);\n    // load up the rpc client and the estimateGas function if we need it\n    const [{\n      getRpcClient\n    }, {\n      eth_estimateGas\n    }] = await Promise.all([import(\"../../rpc/rpc.js\"), import(\"../../rpc/actions/eth_estimateGas.js\")]);\n    const rpcRequest = getRpcClient(options.transaction);\n    try {\n      let gas = await eth_estimateGas(rpcRequest, formatTransactionRequest({\n        to: toAddress,\n        data: encodedData,\n        from,\n        value\n      }));\n      if (options.transaction.chain.experimental?.increaseZeroByteCount) {\n        gas = roundUpGas(gas);\n      }\n      return gas;\n    } catch (error) {\n      throw await extractError({\n        error,\n        contract: options.transaction.__contract\n      });\n    }\n  })();\n  cache.set(txWithFrom, promise);\n  return promise;\n}\n//# sourceMappingURL=estimate-gas.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}