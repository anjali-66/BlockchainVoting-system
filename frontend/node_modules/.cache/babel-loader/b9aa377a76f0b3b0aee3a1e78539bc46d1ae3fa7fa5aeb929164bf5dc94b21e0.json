{"ast":null,"code":"import * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\nimport * as Kzg from './Kzg.js';\nimport * as Cursor from './internal/cursor.js';\n/** Blob limit per transaction. */\nconst blobsPerTransaction = 6;\n/** The number of bytes in a BLS scalar field element. */\nexport const bytesPerFieldElement = 32;\n/** The number of field elements in a blob. */\nexport const fieldElementsPerBlob = 4096;\n/** The number of bytes in a blob. */\nexport const bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;\n/** Blob bytes limit per transaction. */\nexport const maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction -\n// terminator byte (0x80).\n1 -\n// zero byte (0x00) appended to each field element.\n1 * fieldElementsPerBlob * blobsPerTransaction;\n/**\n * Transform a list of Commitments to Blob Versioned Hashes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentsToVersionedHashes(commitments) // [!code focus]\n * // @log: ['0x...', '0x...']\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Versioned Hashes with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentsToVersionedHashes(commitments, {\n *   as: 'Bytes', // [!code focus]\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @example\n * ### Versioning Hashes\n *\n * It is possible to configure the version for the Versioned Hashes with the `version` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentsToVersionedHashes(commitments, {\n *   version: 2, // [!code focus]\n * })\n * ```\n *\n * @param commitments - A list of commitments.\n * @param options - Options.\n * @returns A list of Blob Versioned Hashes.\n */\nexport function commitmentsToVersionedHashes(commitments, options = {}) {\n  const {\n    version\n  } = options;\n  const as = options.as ?? (typeof commitments[0] === 'string' ? 'Hex' : 'Bytes');\n  const hashes = [];\n  for (const commitment of commitments) {\n    hashes.push(commitmentToVersionedHash(commitment, {\n      as,\n      version\n    }));\n  }\n  return hashes;\n}\n/**\n * Transform a Commitment to its Blob Versioned Hash.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const [commitment] = Blobs.toCommitments(blobs, { kzg })\n * const versionedHash = Blobs.commitmentToVersionedHash(commitment) // [!code focus]\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Versioned Hash with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const [commitment] = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentToVersionedHash(commitment, {\n *   as: 'Bytes', // [!code focus]\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @example\n * ### Versioning Hashes\n *\n * It is possible to configure the version for the Versioned Hash with the `version` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const [commitment] = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentToVersionedHash(commitment, {\n *   version: 2, // [!code focus]\n * })\n * ```\n *\n * @param commitment - The commitment.\n * @param options - Options.\n * @returns The Blob Versioned Hash.\n */\nexport function commitmentToVersionedHash(commitment, options = {}) {\n  const {\n    version = 1\n  } = options;\n  const as = options.as ?? (typeof commitment === 'string' ? 'Hex' : 'Bytes');\n  const versionedHash = Hash.sha256(commitment, {\n    as: 'Bytes'\n  });\n  versionedHash.set([version], 0);\n  return as === 'Bytes' ? versionedHash : Hex.fromBytes(versionedHash);\n}\n/**\n * Transforms arbitrary data to {@link ox#Blobs.Blobs}.\n *\n * @example\n * ```ts twoslash\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * ```\n *\n * @example\n * ### Creating Blobs from a String\n *\n * An example of creating Blobs from a string using  {@link ox#Hex.(from:function)}:\n *\n * ```ts twoslash\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from(Hex.fromString('Hello world!'))\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Blobs with the `as` option.\n *\n * ```ts twoslash\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef', { as: 'Bytes' })\n * //    ^?\n *\n *\n * ```\n *\n * @param data - The data to convert to {@link ox#Blobs.Blobs}.\n * @param options - Options.\n * @returns The {@link ox#Blobs.Blobs}.\n */\nexport function from(data, options = {}) {\n  const as = options.as ?? (typeof data === 'string' ? 'Hex' : 'Bytes');\n  const data_ = typeof data === 'string' ? Bytes.fromHex(data) : data;\n  const size_ = Bytes.size(data_);\n  if (!size_) throw new EmptyBlobError();\n  if (size_ > maxBytesPerTransaction) throw new BlobSizeTooLargeError({\n    maxSize: maxBytesPerTransaction,\n    size: size_\n  });\n  const blobs = [];\n  let active = true;\n  let position = 0;\n  while (active) {\n    const blob = Cursor.create(new Uint8Array(bytesPerBlob));\n    let size = 0;\n    while (size < fieldElementsPerBlob) {\n      const bytes = data_.slice(position, position + (bytesPerFieldElement - 1));\n      // Push a zero byte so the field element doesn't overflow the BLS modulus.\n      blob.pushByte(0x00);\n      // Push the current segment of data bytes.\n      blob.pushBytes(bytes);\n      // If we detect that the current segment of data bytes is less than 31 bytes,\n      // we can stop processing and push a terminator byte to indicate the end of the blob.\n      if (bytes.length < 31) {\n        blob.pushByte(0x80);\n        active = false;\n        break;\n      }\n      size++;\n      position += 31;\n    }\n    blobs.push(blob);\n  }\n  return as === 'Bytes' ? blobs.map(x => x.bytes) : blobs.map(x => Hex.fromBytes(x.bytes));\n}\n/**\n * Transforms a list of {@link ox#Blobs.BlobSidecars} to their Blob Versioned Hashes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const versionedHashes = Blobs.sidecarsToVersionedHashes(sidecars) // [!code focus]\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Versioned Hashes with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const versionedHashes = Blobs.sidecarsToVersionedHashes(sidecars, {\n *   as: 'Bytes', // [!code focus]\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @example\n * ### Versioning Hashes\n *\n * It is possible to configure the version for the Versioned Hashes with the `version` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const versionedHashes = Blobs.sidecarsToVersionedHashes(sidecars, {\n *   version: 2, // [!code focus]\n * })\n * ```\n *\n * @param sidecars - The {@link ox#Blobs.BlobSidecars} to transform to Blob Versioned Hashes.\n * @param options - Options.\n * @returns The versioned hashes.\n */\nexport function sidecarsToVersionedHashes(sidecars, options = {}) {\n  const {\n    version\n  } = options;\n  const as = options.as ?? (typeof sidecars[0].blob === 'string' ? 'Hex' : 'Bytes');\n  const hashes = [];\n  for (const {\n    commitment\n  } of sidecars) {\n    hashes.push(commitmentToVersionedHash(commitment, {\n      as,\n      version\n    }));\n  }\n  return hashes;\n}\n/**\n * Transforms Ox-shaped {@link ox#Blobs.Blobs} into the originating data.\n *\n * @example\n * ```ts twoslash\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.to(blobs) // [!code focus]\n * // @log: '0xdeadbeef'\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type with second argument.\n *\n * ```ts twoslash\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.to(blobs, 'Bytes')\n * // @log: Uint8Array [ 13, 174, 190, 239 ]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform.\n * @param to - The type to transform to.\n * @returns The originating data.\n */\nexport function to(blobs, to) {\n  const to_ = to ?? (typeof blobs[0] === 'string' ? 'Hex' : 'Bytes');\n  const blobs_ = typeof blobs[0] === 'string' ? blobs.map(x => Bytes.fromHex(x)) : blobs;\n  const length = blobs_.reduce((length, blob) => length + blob.length, 0);\n  const data = Cursor.create(new Uint8Array(length));\n  let active = true;\n  for (const blob of blobs_) {\n    const cursor = Cursor.create(blob);\n    while (active && cursor.position < blob.length) {\n      // First byte will be a zero 0x00 byte – we can skip.\n      cursor.incrementPosition(1);\n      let consume = 31;\n      if (blob.length - cursor.position < 31) consume = blob.length - cursor.position;\n      for (const _ in Array.from({\n        length: consume\n      })) {\n        const byte = cursor.readByte();\n        const isTerminator = byte === 0x80 && !cursor.inspectBytes(cursor.remaining).includes(0x80);\n        if (isTerminator) {\n          active = false;\n          break;\n        }\n        data.pushByte(byte);\n      }\n    }\n  }\n  const trimmedData = data.bytes.slice(0, data.position);\n  return to_ === 'Hex' ? Hex.fromBytes(trimmedData) : trimmedData;\n}\n/**\n * Transforms Ox-shaped {@link ox#Blobs.Blobs} into the originating data.\n *\n * @example\n * ```ts twoslash\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.toHex(blobs) // [!code focus]\n * // @log: '0xdeadbeef'\n * ```\n */\nexport function toHex(blobs) {\n  return to(blobs, 'Hex');\n}\n/**\n * Transforms Ox-shaped {@link ox#Blobs.Blobs} into the originating data.\n *\n * @example\n * ```ts\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.toBytes(blobs) // [!code focus]\n * // @log: Uint8Array [ 13, 174, 190, 239 ]\n * ```\n */\nexport function toBytes(blobs) {\n  return to(blobs, 'Bytes');\n}\n/**\n * Compute commitments from a list of {@link ox#Blobs.Blobs}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg }) // [!code focus]\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, {\n *   as: 'Bytes', // [!code focus]\n *   kzg,\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform to commitments.\n * @param options - Options.\n * @returns The commitments.\n */\nexport function toCommitments(blobs, options) {\n  const {\n    kzg\n  } = options;\n  const as = options.as ?? (typeof blobs[0] === 'string' ? 'Hex' : 'Bytes');\n  const blobs_ = typeof blobs[0] === 'string' ? blobs.map(x => Bytes.fromHex(x)) : blobs;\n  const commitments = [];\n  for (const blob of blobs_) commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));\n  return as === 'Bytes' ? commitments : commitments.map(x => Hex.fromBytes(x));\n}\n/**\n * Compute the proofs for a list of {@link ox#Blobs.Blobs} and their commitments.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const proofs = Blobs.toProofs(blobs, { commitments, kzg }) // [!code focus]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to compute proofs for.\n * @param options - Options.\n * @returns The Blob proofs.\n */\nexport function toProofs(blobs, options) {\n  const {\n    kzg\n  } = options;\n  const as = options.as ?? (typeof blobs[0] === 'string' ? 'Hex' : 'Bytes');\n  const blobs_ = typeof blobs[0] === 'string' ? blobs.map(x => Bytes.fromHex(x)) : blobs;\n  const commitments = typeof options.commitments[0] === 'string' ? options.commitments.map(x => Bytes.fromHex(x)) : options.commitments;\n  const proofs = [];\n  for (let i = 0; i < blobs_.length; i++) {\n    const blob = blobs_[i];\n    const commitment = commitments[i];\n    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));\n  }\n  return as === 'Bytes' ? proofs : proofs.map(x => Hex.fromBytes(x));\n}\n/**\n * Transforms {@link ox#Blobs.Blobs} into a {@link ox#Blobs.BlobSidecars} array.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg }) // [!code focus]\n * ```\n *\n * @example\n * You can also provide your own commitments and proofs if you do not want `toSidecars`\n * to compute them.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const proofs = Blobs.toProofs(blobs, { commitments, kzg })\n *\n * const sidecars = Blobs.toSidecars(blobs, { commitments, kzg, proofs }) // [!code focus]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform into {@link ox#Blobs.BlobSidecars}.\n * @param options - Options.\n * @returns The {@link ox#Blobs.BlobSidecars}.\n */\nexport function toSidecars(blobs, options) {\n  const {\n    kzg\n  } = options;\n  const commitments = options.commitments ?? toCommitments(blobs, {\n    kzg: kzg\n  });\n  const proofs = options.proofs ?? toProofs(blobs, {\n    commitments: commitments,\n    kzg: kzg\n  });\n  const sidecars = [];\n  for (let i = 0; i < blobs.length; i++) sidecars.push({\n    blob: blobs[i],\n    commitment: commitments[i],\n    proof: proofs[i]\n  });\n  return sidecars;\n}\n/**\n * Compute Blob Versioned Hashes from a list of {@link ox#Blobs.Blobs}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const versionedHashes = Blobs.toVersionedHashes(blobs, { kzg }) // [!code focus]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform into Blob Versioned Hashes.\n * @param options - Options.\n * @returns The Blob Versioned Hashes.\n */\nexport function toVersionedHashes(blobs, options) {\n  const commitments = toCommitments(blobs, options);\n  return commitmentsToVersionedHashes(commitments, options);\n}\n/** Thrown when the blob size is too large. */\nexport class BlobSizeTooLargeError extends Errors.BaseError {\n  constructor({\n    maxSize,\n    size\n  }) {\n    super('Blob size is too large.', {\n      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size} bytes`]\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Blobs.BlobSizeTooLargeError'\n    });\n  }\n}\n/** Thrown when the blob is empty. */\nexport class EmptyBlobError extends Errors.BaseError {\n  constructor() {\n    super('Blob data must not be empty.');\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Blobs.EmptyBlobError'\n    });\n  }\n}\n/** Thrown when the blob versioned hashes are empty. */\nexport class EmptyBlobVersionedHashesError extends Errors.BaseError {\n  constructor() {\n    super('Blob versioned hashes must not be empty.');\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Blobs.EmptyBlobVersionedHashesError'\n    });\n  }\n}\n/** Thrown when the blob versioned hash size is invalid. */\nexport class InvalidVersionedHashSizeError extends Errors.BaseError {\n  constructor({\n    hash,\n    size\n  }) {\n    super(`Versioned hash \"${hash}\" size is invalid.`, {\n      metaMessages: ['Expected: 32', `Received: ${size}`]\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Blobs.InvalidVersionedHashSizeError'\n    });\n  }\n}\n/** Thrown when the blob versioned hash version is invalid. */\nexport class InvalidVersionedHashVersionError extends Errors.BaseError {\n  constructor({\n    hash,\n    version\n  }) {\n    super(`Versioned hash \"${hash}\" version is invalid.`, {\n      metaMessages: [`Expected: ${Kzg.versionedHashVersion}`, `Received: ${version}`]\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Blobs.InvalidVersionedHashVersionError'\n    });\n  }\n}\n//# sourceMappingURL=Blobs.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}