{"ast":null,"code":"// Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>\nimport { APP_VERSION_KEY, WALLET_USER_NAME_KEY } from '../constants.js';\nimport { WalletLinkCipher } from './WalletLinkCipher.js';\nimport { WalletLinkHTTP } from './WalletLinkHTTP.js';\nimport { ConnectionState, WalletLinkWebSocket } from './WalletLinkWebSocket.js';\nimport { IntNumber } from '../../../../core/type/index.js';\nconst HEARTBEAT_INTERVAL = 10000;\nconst REQUEST_TIMEOUT = 60000;\n/**\n * Coinbase Wallet Connection\n */\nexport class WalletLinkConnection {\n  /**\n   * Constructor\n   * @param session Session\n   * @param linkAPIUrl Coinbase Wallet link server URL\n   * @param listener WalletLinkConnectionUpdateListener\n   * @param [WebSocketClass] Custom WebSocket implementation\n   */\n  constructor({\n    session,\n    linkAPIUrl,\n    listener\n  }) {\n    this.destroyed = false;\n    this.lastHeartbeatResponse = 0;\n    this.nextReqId = IntNumber(1);\n    /**\n     * true if connected and authenticated, else false\n     * runs listener when connected status changes\n     */\n    this._connected = false;\n    /**\n     * true if linked (a guest has joined before)\n     * runs listener when linked status changes\n     */\n    this._linked = false;\n    this.shouldFetchUnseenEventsOnConnect = false;\n    this.requestResolutions = new Map();\n    this.handleSessionMetadataUpdated = metadata => {\n      if (!metadata) return;\n      // Map of metadata key to handler function\n      const handlers = new Map([['__destroyed', this.handleDestroyed], ['EthereumAddress', this.handleAccountUpdated], ['WalletUsername', this.handleWalletUsernameUpdated], ['AppVersion', this.handleAppVersionUpdated], ['ChainId',\n      // ChainId and JsonRpcUrl are always updated together\n      v => metadata.JsonRpcUrl && this.handleChainUpdated(v, metadata.JsonRpcUrl)]]);\n      // call handler for each metadata key if value is defined\n      handlers.forEach((handler, key) => {\n        const value = metadata[key];\n        if (value === undefined) return;\n        handler(value);\n      });\n    };\n    this.handleDestroyed = __destroyed => {\n      var _a;\n      if (__destroyed !== '1') return;\n      (_a = this.listener) === null || _a === void 0 ? void 0 : _a.resetAndReload();\n    };\n    this.handleAccountUpdated = async encryptedEthereumAddress => {\n      var _a;\n      const address = await this.cipher.decrypt(encryptedEthereumAddress);\n      (_a = this.listener) === null || _a === void 0 ? void 0 : _a.accountUpdated(address);\n    };\n    this.handleMetadataUpdated = async (key, encryptedMetadataValue) => {\n      var _a;\n      const decryptedValue = await this.cipher.decrypt(encryptedMetadataValue);\n      (_a = this.listener) === null || _a === void 0 ? void 0 : _a.metadataUpdated(key, decryptedValue);\n    };\n    this.handleWalletUsernameUpdated = async walletUsername => {\n      this.handleMetadataUpdated(WALLET_USER_NAME_KEY, walletUsername);\n    };\n    this.handleAppVersionUpdated = async appVersion => {\n      this.handleMetadataUpdated(APP_VERSION_KEY, appVersion);\n    };\n    this.handleChainUpdated = async (encryptedChainId, encryptedJsonRpcUrl) => {\n      var _a;\n      const chainId = await this.cipher.decrypt(encryptedChainId);\n      const jsonRpcUrl = await this.cipher.decrypt(encryptedJsonRpcUrl);\n      (_a = this.listener) === null || _a === void 0 ? void 0 : _a.chainUpdated(chainId, jsonRpcUrl);\n    };\n    this.session = session;\n    this.cipher = new WalletLinkCipher(session.secret);\n    this.listener = listener;\n    const ws = new WalletLinkWebSocket(`${linkAPIUrl}/rpc`, WebSocket);\n    ws.setConnectionStateListener(async state => {\n      // attempt to reconnect every 5 seconds when disconnected\n      let connected = false;\n      switch (state) {\n        case ConnectionState.DISCONNECTED:\n          // if DISCONNECTED and not destroyed\n          if (!this.destroyed) {\n            const connect = async () => {\n              // wait 5 seconds\n              await new Promise(resolve => setTimeout(resolve, 5000));\n              // check whether it's destroyed again\n              if (!this.destroyed) {\n                // reconnect\n                ws.connect().catch(() => {\n                  connect();\n                });\n              }\n            };\n            connect();\n          }\n          break;\n        case ConnectionState.CONNECTED:\n          // perform authentication upon connection\n          // if CONNECTED, authenticate, and then check link status\n          connected = await this.handleConnected();\n          // send heartbeat every n seconds while connected\n          // if CONNECTED, start the heartbeat timer\n          // first timer event updates lastHeartbeat timestamp\n          // subsequent calls send heartbeat message\n          this.updateLastHeartbeat();\n          setInterval(() => {\n            this.heartbeat();\n          }, HEARTBEAT_INTERVAL);\n          // check for unseen events\n          if (this.shouldFetchUnseenEventsOnConnect) {\n            this.fetchUnseenEventsAPI();\n          }\n          break;\n        case ConnectionState.CONNECTING:\n          break;\n      }\n      // distinctUntilChanged\n      if (this.connected !== connected) {\n        this.connected = connected;\n      }\n    });\n    ws.setIncomingDataListener(m => {\n      var _a;\n      switch (m.type) {\n        // handle server's heartbeat responses\n        case 'Heartbeat':\n          this.updateLastHeartbeat();\n          return;\n        // handle link status updates\n        case 'IsLinkedOK':\n        case 'Linked':\n          {\n            const linked = m.type === 'IsLinkedOK' ? m.linked : undefined;\n            this.linked = linked || m.onlineGuests > 0;\n            break;\n          }\n        // handle session config updates\n        case 'GetSessionConfigOK':\n        case 'SessionConfigUpdated':\n          {\n            this.handleSessionMetadataUpdated(m.metadata);\n            break;\n          }\n        case 'Event':\n          {\n            this.handleIncomingEvent(m);\n            break;\n          }\n      }\n      // resolve request promises\n      if (m.id !== undefined) {\n        (_a = this.requestResolutions.get(m.id)) === null || _a === void 0 ? void 0 : _a(m);\n      }\n    });\n    this.ws = ws;\n    this.http = new WalletLinkHTTP(linkAPIUrl, session.id, session.key);\n  }\n  /**\n   * Make a connection to the server\n   */\n  connect() {\n    if (this.destroyed) {\n      throw new Error('instance is destroyed');\n    }\n    this.ws.connect();\n  }\n  /**\n   * Terminate connection, and mark as destroyed. To reconnect, create a new\n   * instance of WalletSDKConnection\n   */\n  async destroy() {\n    if (this.destroyed) return;\n    await this.makeRequest({\n      type: 'SetSessionConfig',\n      id: IntNumber(this.nextReqId++),\n      sessionId: this.session.id,\n      metadata: {\n        __destroyed: '1'\n      }\n    }, {\n      timeout: 1000\n    });\n    this.destroyed = true;\n    this.ws.disconnect();\n    this.listener = undefined;\n  }\n  get connected() {\n    return this._connected;\n  }\n  set connected(connected) {\n    this._connected = connected;\n  }\n  get linked() {\n    return this._linked;\n  }\n  set linked(linked) {\n    var _a, _b;\n    this._linked = linked;\n    if (linked) (_a = this.onceLinked) === null || _a === void 0 ? void 0 : _a.call(this);\n    (_b = this.listener) === null || _b === void 0 ? void 0 : _b.linkedUpdated(linked);\n  }\n  setOnceLinked(callback) {\n    return new Promise(resolve => {\n      if (this.linked) {\n        callback().then(resolve);\n      } else {\n        this.onceLinked = () => {\n          callback().then(resolve);\n          this.onceLinked = undefined;\n        };\n      }\n    });\n  }\n  async handleIncomingEvent(m) {\n    var _a;\n    if (m.type !== 'Event' || m.event !== 'Web3Response') {\n      return;\n    }\n    const decryptedData = await this.cipher.decrypt(m.data);\n    const message = JSON.parse(decryptedData);\n    if (message.type !== 'WEB3_RESPONSE') return;\n    const {\n      id,\n      response\n    } = message;\n    (_a = this.listener) === null || _a === void 0 ? void 0 : _a.handleWeb3ResponseMessage(id, response);\n  }\n  async checkUnseenEvents() {\n    if (!this.connected) {\n      this.shouldFetchUnseenEventsOnConnect = true;\n      return;\n    }\n    await new Promise(resolve => setTimeout(resolve, 250));\n    try {\n      await this.fetchUnseenEventsAPI();\n    } catch (e) {\n      console.error('Unable to check for unseen events', e);\n    }\n  }\n  async fetchUnseenEventsAPI() {\n    this.shouldFetchUnseenEventsOnConnect = false;\n    const responseEvents = await this.http.fetchUnseenEvents();\n    responseEvents.forEach(e => this.handleIncomingEvent(e));\n  }\n  /**\n   * Publish an event and emit event ID when successful\n   * @param event event name\n   * @param unencryptedData unencrypted event data\n   * @param callWebhook whether the webhook should be invoked\n   * @returns a Promise that emits event ID when successful\n   */\n  async publishEvent(event, unencryptedData, callWebhook = false) {\n    const data = await this.cipher.encrypt(JSON.stringify(Object.assign(Object.assign({}, unencryptedData), {\n      origin: location.origin,\n      location: location.href,\n      relaySource: 'coinbaseWalletExtension' in window && window.coinbaseWalletExtension ? 'injected_sdk' : 'sdk'\n    })));\n    const message = {\n      type: 'PublishEvent',\n      id: IntNumber(this.nextReqId++),\n      sessionId: this.session.id,\n      event,\n      data,\n      callWebhook\n    };\n    return this.setOnceLinked(async () => {\n      const res = await this.makeRequest(message);\n      if (res.type === 'Fail') {\n        throw new Error(res.error || 'failed to publish event');\n      }\n      return res.eventId;\n    });\n  }\n  sendData(message) {\n    this.ws.sendData(JSON.stringify(message));\n  }\n  updateLastHeartbeat() {\n    this.lastHeartbeatResponse = Date.now();\n  }\n  heartbeat() {\n    if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {\n      this.ws.disconnect();\n      return;\n    }\n    try {\n      this.ws.sendData('h');\n    } catch (_a) {\n      // noop\n    }\n  }\n  async makeRequest(message, options = {\n    timeout: REQUEST_TIMEOUT\n  }) {\n    const reqId = message.id;\n    this.sendData(message);\n    // await server message with corresponding id\n    let timeoutId;\n    return Promise.race([new Promise((_, reject) => {\n      timeoutId = window.setTimeout(() => {\n        reject(new Error(`request ${reqId} timed out`));\n      }, options.timeout);\n    }), new Promise(resolve => {\n      this.requestResolutions.set(reqId, m => {\n        clearTimeout(timeoutId); // clear the timeout\n        resolve(m);\n        this.requestResolutions.delete(reqId);\n      });\n    })]);\n  }\n  async handleConnected() {\n    const res = await this.makeRequest({\n      type: 'HostSession',\n      id: IntNumber(this.nextReqId++),\n      sessionId: this.session.id,\n      sessionKey: this.session.key\n    });\n    if (res.type === 'Fail') return false;\n    this.sendData({\n      type: 'IsLinked',\n      id: IntNumber(this.nextReqId++),\n      sessionId: this.session.id\n    });\n    this.sendData({\n      type: 'GetSessionConfig',\n      id: IntNumber(this.nextReqId++),\n      sessionId: this.session.id\n    });\n    return true;\n  }\n}\n//# sourceMappingURL=WalletLinkConnection.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}