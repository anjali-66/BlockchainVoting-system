{"ast":null,"code":"import * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as Hex from './Hex.js';\nimport * as Cursor from './internal/cursor.js';\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toBytes('0x8b68656c6c6f20776f726c64')\n * // Uint8Array([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Bytes.Bytes} value.\n */\nexport function toBytes(value) {\n  return to(value, 'Bytes');\n}\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toHex('0x8b68656c6c6f20776f726c64')\n * // 0x68656c6c6f20776f726c64\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Hex.Hex} value.\n */\nexport function toHex(value) {\n  return to(value, 'Hex');\n}\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\n/** @internal */\nexport function to(value, to) {\n  const to_ = to ?? (typeof value === 'string' ? 'Hex' : 'Bytes');\n  const bytes = (() => {\n    if (typeof value === 'string') {\n      if (value.length > 3 && value.length % 2 !== 0) throw new Hex.InvalidLengthError(value);\n      return Bytes.fromHex(value);\n    }\n    return value;\n  })();\n  const cursor = Cursor.create(bytes, {\n    recursiveReadLimit: Number.POSITIVE_INFINITY\n  });\n  const result = decodeRlpCursor(cursor, to_);\n  return result;\n}\n/** @internal */\n/** @internal */\nexport function decodeRlpCursor(cursor, to = 'Hex') {\n  if (cursor.bytes.length === 0) return to === 'Hex' ? Hex.fromBytes(cursor.bytes) : cursor.bytes;\n  const prefix = cursor.readByte();\n  if (prefix < 0x80) cursor.decrementPosition(1);\n  // bytes\n  if (prefix < 0xc0) {\n    const length = readLength(cursor, prefix, 0x80);\n    const bytes = cursor.readBytes(length);\n    return to === 'Hex' ? Hex.fromBytes(bytes) : bytes;\n  }\n  // list\n  const length = readLength(cursor, prefix, 0xc0);\n  return readList(cursor, length, to);\n}\n/** @internal */\nexport function readLength(cursor, prefix, offset) {\n  if (offset === 0x80 && prefix < 0x80) return 1;\n  if (prefix <= offset + 55) return prefix - offset;\n  if (prefix === offset + 55 + 1) return cursor.readUint8();\n  if (prefix === offset + 55 + 2) return cursor.readUint16();\n  if (prefix === offset + 55 + 3) return cursor.readUint24();\n  if (prefix === offset + 55 + 4) return cursor.readUint32();\n  throw new Errors.BaseError('Invalid RLP prefix');\n}\n/** @internal */\nexport function readList(cursor, length, to) {\n  const position = cursor.position;\n  const value = [];\n  while (cursor.position - position < length) value.push(decodeRlpCursor(cursor, to));\n  return value;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.from('0x68656c6c6f20776f726c64', { as: 'Hex' })\n * // @log: 0x8b68656c6c6f20776f726c64\n *\n * Rlp.from(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]), { as: 'Bytes' })\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nexport function from(value, options) {\n  const {\n    as\n  } = options;\n  const encodable = getEncodable(value);\n  const cursor = Cursor.create(new Uint8Array(encodable.length));\n  encodable.encode(cursor);\n  if (as === 'Hex') return Hex.fromBytes(cursor.bytes);\n  return cursor.bytes;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.fromBytes(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]))\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nexport function fromBytes(bytes, options = {}) {\n  const {\n    as = 'Bytes'\n  } = options;\n  return from(bytes, {\n    as\n  });\n}\n/**\n * Encodes a {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n *\n * Rlp.fromHex('0x68656c6c6f20776f726c64')\n * // @log: 0x8b68656c6c6f20776f726c64\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nexport function fromHex(hex, options = {}) {\n  const {\n    as = 'Hex'\n  } = options;\n  return from(hex, {\n    as\n  });\n}\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\nfunction getEncodable(bytes) {\n  if (Array.isArray(bytes)) return getEncodableList(bytes.map(x => getEncodable(x)));\n  return getEncodableBytes(bytes);\n}\nfunction getEncodableList(list) {\n  const bodyLength = list.reduce((acc, x) => acc + x.length, 0);\n  const sizeOfBodyLength = getSizeOfLength(bodyLength);\n  const length = (() => {\n    if (bodyLength <= 55) return 1 + bodyLength;\n    return 1 + sizeOfBodyLength + bodyLength;\n  })();\n  return {\n    length,\n    encode(cursor) {\n      if (bodyLength <= 55) {\n        cursor.pushByte(0xc0 + bodyLength);\n      } else {\n        cursor.pushByte(0xc0 + 55 + sizeOfBodyLength);\n        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength);else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength);else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength);else cursor.pushUint32(bodyLength);\n      }\n      for (const {\n        encode\n      } of list) {\n        encode(cursor);\n      }\n    }\n  };\n}\nfunction getEncodableBytes(bytesOrHex) {\n  const bytes = typeof bytesOrHex === 'string' ? Bytes.fromHex(bytesOrHex) : bytesOrHex;\n  const sizeOfBytesLength = getSizeOfLength(bytes.length);\n  const length = (() => {\n    if (bytes.length === 1 && bytes[0] < 0x80) return 1;\n    if (bytes.length <= 55) return 1 + bytes.length;\n    return 1 + sizeOfBytesLength + bytes.length;\n  })();\n  return {\n    length,\n    encode(cursor) {\n      if (bytes.length === 1 && bytes[0] < 0x80) {\n        cursor.pushBytes(bytes);\n      } else if (bytes.length <= 55) {\n        cursor.pushByte(0x80 + bytes.length);\n        cursor.pushBytes(bytes);\n      } else {\n        cursor.pushByte(0x80 + 55 + sizeOfBytesLength);\n        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length);else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length);else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length);else cursor.pushUint32(bytes.length);\n        cursor.pushBytes(bytes);\n      }\n    }\n  };\n}\nfunction getSizeOfLength(length) {\n  if (length < 2 ** 8) return 1;\n  if (length < 2 ** 16) return 2;\n  if (length < 2 ** 24) return 3;\n  if (length < 2 ** 32) return 4;\n  throw new Errors.BaseError('Length is too large.');\n}\n//# sourceMappingURL=Rlp.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}