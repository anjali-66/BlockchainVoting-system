{"ast":null,"code":"/**\n * This mixin function is designed to be applied to a class that inherits\n * from HTMLElement. It makes it easy for a custom element to coordinate with\n * the :focus-visible polyfill.\n *\n * NOTE(cdata): The code here was adapted from an example proposed with the\n * introduction of ShadowDOM support in the :focus-visible polyfill.\n *\n * @see https://github.com/WICG/focus-visible/pull/196\n * @param {Function} SuperClass The base class implementation to decorate with\n * implementation that coordinates with the :focus-visible polyfill\n */\nexport const FocusVisiblePolyfillMixin = SuperClass => {\n  var _a;\n  const coordinateWithPolyfill = instance => {\n    // If there is no shadow root, there is no need to coordinate with\n    // the polyfill. If we already coordinated with the polyfill, we can\n    // skip subsequent invocations:\n    if (instance.shadowRoot == null || instance.hasAttribute('data-js-focus-visible')) {\n      return () => {};\n    }\n    // The polyfill might already be loaded. If so, we can apply it to\n    // the shadow root immediately:\n    if (self.applyFocusVisiblePolyfill) {\n      self.applyFocusVisiblePolyfill(instance.shadowRoot);\n    } else {\n      const coordinationHandler = () => {\n        self.applyFocusVisiblePolyfill(instance.shadowRoot);\n      };\n      // Otherwise, wait for the polyfill to be loaded lazily. It might\n      // never be loaded, but if it is then we can apply it to the\n      // shadow root at the appropriate time by waiting for the ready\n      // event:\n      self.addEventListener('focus-visible-polyfill-ready', coordinationHandler, {\n        once: true\n      });\n      return () => {\n        self.removeEventListener('focus-visible-polyfill-ready', coordinationHandler);\n      };\n    }\n    return () => {};\n  };\n  const $endPolyfillCoordination = Symbol('endPolyfillCoordination');\n  // IE11 doesn't natively support custom elements or JavaScript class\n  // syntax The mixin implementation assumes that the user will take the\n  // appropriate steps to support both:\n  class FocusVisibleCoordinator extends SuperClass {\n    constructor() {\n      super(...arguments);\n      this[_a] = null;\n    }\n    // Attempt to coordinate with the polyfill when connected to the\n    // document:\n    connectedCallback() {\n      super.connectedCallback && super.connectedCallback();\n      if (this[$endPolyfillCoordination] == null) {\n        this[$endPolyfillCoordination] = coordinateWithPolyfill(this);\n      }\n    }\n    disconnectedCallback() {\n      super.disconnectedCallback && super.disconnectedCallback();\n      // It's important to remove the polyfill event listener when we\n      // disconnect, otherwise we will leak the whole element via window:\n      if (this[$endPolyfillCoordination] != null) {\n        this[$endPolyfillCoordination]();\n        this[$endPolyfillCoordination] = null;\n      }\n    }\n  }\n  _a = $endPolyfillCoordination;\n  ;\n  return FocusVisibleCoordinator;\n};\n//# sourceMappingURL=focus-visible.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}