{"ast":null,"code":"import { NATIVE_TOKEN_ADDRESS, isNativeTokenAddress } from \"../../../../constants/addresses.js\";\nimport { getContract } from \"../../../../contract/contract.js\";\nimport { eth_getBlockByNumber } from \"../../../../rpc/actions/eth_getBlockByNumber.js\";\nimport { getRpcClient } from \"../../../../rpc/rpc.js\";\nimport { toUnits } from \"../../../../utils/units.js\";\nimport { isERC721 } from \"../../../erc721/read/isERC721.js\";\nimport { isERC1155 } from \"../../../erc1155/read/isERC1155.js\";\nimport * as CreateListing from \"../../__generated__/IDirectListings/write/createListing.js\";\n/**\n * Creates a direct listing.\n * @param options The options for creating the direct listing.\n * @returns The result of creating the direct listing.\n * @extension MARKETPLACE\n * @example\n * ```typescript\n * import { createListing } from \"thirdweb/extensions/marketplace\";\n * import { sendTransaction } from \"thirdweb\";\n *\n * const transaction = createListing({\n *   assetContractAddress: \"0x...\", // the NFT contract address that you want to sell\n *   tokenId={0n}, // the token id you want to sell\n *   pricePerToken=\"0.1\" // sell for 0.1 <native token>\n * });\n *\n * await sendTransaction({ transaction, account });\n * ```\n */\nexport function createListing(options) {\n  return CreateListing.createListing({\n    contract: options.contract,\n    asyncParams: async () => {\n      const assetContract = getContract({\n        ...options.contract,\n        address: options.assetContractAddress\n      });\n      const rpcClient = getRpcClient(options.contract);\n      const [assetIsERC721, assetIsERC1155, lastestBlock] = await Promise.all([isERC721({\n        contract: assetContract\n      }), isERC1155({\n        contract: assetContract\n      }), eth_getBlockByNumber(rpcClient, {\n        blockTag: \"latest\"\n      })]);\n      // validate valid asset\n      if (!assetIsERC721 && !assetIsERC1155) {\n        throw new Error(\"AssetContract must implement ERC 1155 or ERC 721.\");\n      }\n      // validate the timestamps\n      let startTimestamp = BigInt(Math.floor((options.startTimestamp ?? new Date()).getTime() / 1000));\n      const endTimestamp = BigInt(Math.floor((options.endTimestamp ?? new Date(Date.now() + 10 * 365 * 24 * 60 * 60 * 1000)).getTime() / 1000));\n      if (startTimestamp <= lastestBlock.timestamp) {\n        // set the start time to the next block if it is in the past\n        startTimestamp = lastestBlock.timestamp + 1n;\n      }\n      if (startTimestamp >= endTimestamp) {\n        throw new Error(\"Start time must be before end time.\");\n      }\n      // valdiate quantity\n      let quantity;\n      if (assetIsERC721) {\n        // force quantity to 1 for ERC721s\n        quantity = 1n;\n      } else {\n        // otherwise use the provided quantity or default to 1\n        quantity = options.quantity ?? 1n;\n      }\n      // validate price\n      const currencyAddress = options.currencyContractAddress ?? NATIVE_TOKEN_ADDRESS;\n      let pricePerToken;\n      if (\"pricePerToken\" in options) {\n        // for native token, we know decimals are 18\n        if (isNativeTokenAddress(currencyAddress)) {\n          pricePerToken = toUnits(options.pricePerToken, 18);\n        } else {\n          // otherwise get the decimals of the currency\n          const currencyContract = getContract({\n            ...options.contract,\n            address: currencyAddress\n          });\n          const {\n            decimals\n          } = await import(\"../../../erc20/read/decimals.js\");\n          const currencyDecimals = await decimals({\n            contract: currencyContract\n          });\n          pricePerToken = toUnits(options.pricePerToken, currencyDecimals);\n        }\n      } else {\n        pricePerToken = BigInt(options.pricePerTokenWei);\n      }\n      return {\n        params: {\n          assetContract: options.assetContractAddress,\n          tokenId: options.tokenId,\n          currency: options.currencyContractAddress ?? NATIVE_TOKEN_ADDRESS,\n          quantity,\n          pricePerToken,\n          startTimestamp,\n          endTimestamp,\n          reserved: options.isReservedListing ?? false\n        },\n        overrides: {\n          extraGas: 50000n // add extra gas to account for router call\n        }\n      };\n    }\n  });\n}\n/**\n * Checks if the `createListing` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `createListing` method is supported.\n * @extension MARKETPLACE\n * @example\n * ```ts\n * import { isCreateAuctionSupported } from \"thirdweb/extensions/marketplace\";\n *\n * const supported = isCreateAuctionSupported([\"0x...\"]);\n * ```\n */\nexport function isCreateListingSupported(availableSelectors) {\n  return CreateListing.isCreateListingSupported(availableSelectors);\n}\n//# sourceMappingURL=createListing.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}