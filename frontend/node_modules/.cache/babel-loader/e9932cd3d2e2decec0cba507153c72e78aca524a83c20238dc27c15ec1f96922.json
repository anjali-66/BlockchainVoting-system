{"ast":null,"code":"import { Bytes } from '../../index.js';\nimport * as Ens from '../Ens.js';\nimport * as Hex from '../Hex.js';\n/**\n * @internal\n * Encodes a [DNS packet](https://docs.ens.domains/resolution/names#dns) into a ByteArray containing a UDP payload.\n */\nexport function packetToBytes(packet) {\n  // strip leading and trailing `.`\n  const value = packet.replace(/^\\.|\\.$/gm, '');\n  if (value.length === 0) return new Uint8Array(1);\n  const bytes = new Uint8Array(Bytes.fromString(value).byteLength + 2);\n  let offset = 0;\n  const list = value.split('.');\n  for (let i = 0; i < list.length; i++) {\n    let encoded = Bytes.fromString(list[i]);\n    // if the length is > 255, make the encoded label value a labelhash\n    // this is compatible with the universal resolver\n    if (encoded.byteLength > 255) encoded = Bytes.fromString(wrapLabelhash(Ens.labelhash(list[i])));\n    bytes[offset] = encoded.length;\n    bytes.set(encoded, offset + 1);\n    offset += encoded.length + 1;\n  }\n  if (bytes.byteLength !== offset + 1) return bytes.slice(0, offset + 1);\n  return bytes;\n}\n/** @internal */\nexport function wrapLabelhash(hash) {\n  return `[${hash.slice(2)}]`;\n}\n/** @internal */\nexport function unwrapLabelhash(label) {\n  if (label.length !== 66) return null;\n  if (label.indexOf('[') !== 0) return null;\n  if (label.indexOf(']') !== 65) return null;\n  const hash = `0x${label.slice(1, 65)}`;\n  if (!Hex.validate(hash, {\n    strict: true\n  })) return null;\n  return hash;\n}\n//# sourceMappingURL=ens.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}