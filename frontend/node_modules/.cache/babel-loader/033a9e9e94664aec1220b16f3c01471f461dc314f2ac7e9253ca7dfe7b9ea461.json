{"ast":null,"code":"import { hexStringToUint8Array, uint8ArrayToHex } from '../core/type/util.js';\nexport async function generateKeyPair() {\n  return crypto.subtle.generateKey({\n    name: 'ECDH',\n    namedCurve: 'P-256'\n  }, true, ['deriveKey']);\n}\nexport async function deriveSharedSecret(ownPrivateKey, peerPublicKey) {\n  return crypto.subtle.deriveKey({\n    name: 'ECDH',\n    public: peerPublicKey\n  }, ownPrivateKey, {\n    name: 'AES-GCM',\n    length: 256\n  }, false, ['encrypt', 'decrypt']);\n}\nexport async function encrypt(sharedSecret, plainText) {\n  const iv = crypto.getRandomValues(new Uint8Array(12));\n  const cipherText = await crypto.subtle.encrypt({\n    name: 'AES-GCM',\n    iv\n  }, sharedSecret, new TextEncoder().encode(plainText));\n  return {\n    iv,\n    cipherText\n  };\n}\nexport async function decrypt(sharedSecret, {\n  iv,\n  cipherText\n}) {\n  const plainText = await crypto.subtle.decrypt({\n    name: 'AES-GCM',\n    iv\n  }, sharedSecret, cipherText);\n  return new TextDecoder().decode(plainText);\n}\nfunction getFormat(keyType) {\n  switch (keyType) {\n    case 'public':\n      return 'spki';\n    case 'private':\n      return 'pkcs8';\n  }\n}\nexport async function exportKeyToHexString(type, key) {\n  const format = getFormat(type);\n  const exported = await crypto.subtle.exportKey(format, key);\n  return uint8ArrayToHex(new Uint8Array(exported));\n}\nexport async function importKeyFromHexString(type, hexString) {\n  const format = getFormat(type);\n  const arrayBuffer = hexStringToUint8Array(hexString).buffer;\n  return await crypto.subtle.importKey(format, new Uint8Array(arrayBuffer), {\n    name: 'ECDH',\n    namedCurve: 'P-256'\n  }, true, type === 'private' ? ['deriveKey'] : []);\n}\nexport async function encryptContent(content, sharedSecret) {\n  const serialized = JSON.stringify(content, (_, value) => {\n    if (!(value instanceof Error)) return value;\n    const error = value;\n    return Object.assign(Object.assign({}, error.code ? {\n      code: error.code\n    } : {}), {\n      message: error.message\n    });\n  });\n  return encrypt(sharedSecret, serialized);\n}\nexport async function decryptContent(encryptedData, sharedSecret) {\n  return JSON.parse(await decrypt(sharedSecret, encryptedData));\n}\n//# sourceMappingURL=cipher.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}