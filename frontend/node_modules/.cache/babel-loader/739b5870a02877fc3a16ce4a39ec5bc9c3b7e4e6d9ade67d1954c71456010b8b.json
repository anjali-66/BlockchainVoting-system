{"ast":null,"code":"import { getCachedChain } from \"../../chains/utils.js\";\nimport { getContract } from \"../../contract/contract.js\";\nimport { allowance } from \"../../extensions/erc20/__generated__/IERC20/read/allowance.js\";\nimport { approve } from \"../../extensions/erc20/write/approve.js\";\nimport { toSerializableTransaction } from \"../../transaction/actions/to-serializable-transaction.js\";\nimport { populateEip712Transaction, signEip712Transaction } from \"../../transaction/actions/zksync/send-eip712-transaction.js\";\nimport { readContract } from \"../../transaction/read-contract.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { isZkSyncChain } from \"../../utils/any-evm/zksync/isZkSyncChain.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parse-typed-data.js\";\nimport { maxUint96 } from \"../../utils/types.js\";\nimport { broadcastZkTransaction, bundleUserOp, getZkPaymasterData } from \"./lib/bundler.js\";\nimport { predictAddress, prepareBatchExecute, prepareExecute } from \"./lib/calls.js\";\nimport { ENTRYPOINT_ADDRESS_v0_6, ENTRYPOINT_ADDRESS_v0_7, getDefaultAccountFactory, getEntryPointVersion } from \"./lib/constants.js\";\nimport { clearAccountDeploying, createUnsignedUserOp, signUserOp, waitForUserOpReceipt } from \"./lib/userop.js\";\n/**\n * Checks if the provided wallet is a smart wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is a smart wallet, false otherwise.\n */\nexport function isSmartWallet(wallet) {\n  return wallet.id === \"smart\";\n}\n/**\n * We can get the personal account for given smart account but not the other way around - this map gives us the reverse lookup\n * @internal\n */\nconst personalAccountToSmartAccountMap = new WeakMap();\nconst smartWalletToPersonalAccountMap = new WeakMap();\n/**\n * @internal\n */\nexport async function connectSmartWallet(wallet, connectionOptions, creationOptions) {\n  const {\n    personalAccount,\n    client,\n    chain: connectChain\n  } = connectionOptions;\n  if (!personalAccount) {\n    throw new Error(\"Personal wallet does not have an account\");\n  }\n  const options = creationOptions;\n  const chain = connectChain ?? options.chain;\n  // if factory is passed, but no entrypoint, try to resolve entrypoint from factory\n  if (options.factoryAddress && !options.overrides?.entrypointAddress) {\n    const entrypointAddress = await getEntrypointFromFactory(options.factoryAddress, client, chain);\n    if (entrypointAddress) {\n      options.overrides = {\n        ...options.overrides,\n        entrypointAddress\n      };\n    }\n  }\n  if (options.overrides?.tokenPaymaster && !options.overrides?.entrypointAddress) {\n    // if token paymaster is set, but no entrypoint address, set the entrypoint address to v0.7\n    options.overrides = {\n      ...options.overrides,\n      entrypointAddress: ENTRYPOINT_ADDRESS_v0_7\n    };\n  }\n  const factoryAddress = options.factoryAddress ?? getDefaultAccountFactory(options.overrides?.entrypointAddress);\n  const sponsorGas = \"gasless\" in options ? options.gasless : options.sponsorGas;\n  if (await isZkSyncChain(chain)) {\n    return [createZkSyncAccount({\n      creationOptions,\n      connectionOptions,\n      chain,\n      sponsorGas\n    }), chain];\n  }\n  const factoryContract = getContract({\n    client: client,\n    address: factoryAddress,\n    chain: chain\n  });\n  const accountAddress = await predictAddress({\n    factoryContract,\n    adminAddress: personalAccount.address,\n    predictAddressOverride: options.overrides?.predictAddress,\n    accountSalt: options.overrides?.accountSalt,\n    accountAddress: options.overrides?.accountAddress\n  }).then(address => address).catch(err => {\n    throw new Error(`Failed to get account address with factory contract ${factoryContract.address} on chain ID ${chain.id}: ${err?.message || \"unknown error\"}`, {\n      cause: err\n    });\n  });\n  const accountContract = getContract({\n    client,\n    address: accountAddress,\n    chain\n  });\n  const account = await createSmartAccount({\n    ...options,\n    chain,\n    sponsorGas,\n    personalAccount,\n    accountContract,\n    factoryContract,\n    client\n  });\n  personalAccountToSmartAccountMap.set(personalAccount, wallet);\n  smartWalletToPersonalAccountMap.set(wallet, personalAccount);\n  return [account, chain];\n}\n/**\n * @internal\n */\nexport async function disconnectSmartWallet(wallet) {\n  // look up the personalAccount for the smart wallet\n  const personalAccount = smartWalletToPersonalAccountMap.get(wallet);\n  if (personalAccount) {\n    // remove the mappings\n    personalAccountToSmartAccountMap.delete(personalAccount);\n    smartWalletToPersonalAccountMap.delete(wallet);\n  }\n}\nasync function createSmartAccount(options) {\n  const erc20Paymaster = options.overrides?.tokenPaymaster;\n  if (erc20Paymaster) {\n    if (getEntryPointVersion(options.overrides?.entrypointAddress || ENTRYPOINT_ADDRESS_v0_6) !== \"v0.7\") {\n      throw new Error(\"Token paymaster is only supported for entrypoint version v0.7\");\n    }\n  }\n  const {\n    accountContract\n  } = options;\n  const account = {\n    address: getAddress(accountContract.address),\n    async sendTransaction(transaction) {\n      // if erc20 paymaster - check allowance and approve if needed\n      let paymasterOverride = undefined;\n      if (erc20Paymaster) {\n        await approveERC20({\n          accountContract,\n          erc20Paymaster,\n          options\n        });\n        const paymasterCallback = async () => {\n          return {\n            paymaster: erc20Paymaster.paymasterAddress,\n            paymasterData: \"0x\"\n          };\n        };\n        paymasterOverride = options.overrides?.paymaster || paymasterCallback;\n      } else {\n        paymasterOverride = options.overrides?.paymaster;\n      }\n      const executeTx = prepareExecute({\n        accountContract,\n        transaction,\n        executeOverride: options.overrides?.execute\n      });\n      return _sendUserOp({\n        executeTx,\n        options: {\n          ...options,\n          overrides: {\n            ...options.overrides,\n            paymaster: paymasterOverride\n          }\n        }\n      });\n    },\n    async sendBatchTransaction(transactions) {\n      const executeTx = prepareBatchExecute({\n        accountContract,\n        transactions,\n        executeBatchOverride: options.overrides?.executeBatch\n      });\n      return _sendUserOp({\n        executeTx,\n        options\n      });\n    },\n    async signMessage({\n      message\n    }) {\n      if (options.overrides?.signMessage) {\n        return options.overrides.signMessage({\n          adminAccount: options.personalAccount,\n          factoryContract: options.factoryContract,\n          accountContract,\n          message\n        });\n      }\n      const {\n        deployAndSignMessage\n      } = await import(\"./lib/signing.js\");\n      return deployAndSignMessage({\n        accountContract,\n        factoryContract: options.factoryContract,\n        options,\n        message\n      });\n    },\n    async signTypedData(typedData) {\n      if (options.overrides?.signTypedData) {\n        return options.overrides.signTypedData({\n          adminAccount: options.personalAccount,\n          factoryContract: options.factoryContract,\n          accountContract,\n          typedData\n        });\n      }\n      const {\n        deployAndSignTypedData\n      } = await import(\"./lib/signing.js\");\n      return deployAndSignTypedData({\n        accountContract,\n        factoryContract: options.factoryContract,\n        options,\n        typedData\n      });\n    },\n    async onTransactionRequested(transaction) {\n      return options.personalAccount.onTransactionRequested?.(transaction);\n    }\n  };\n  return account;\n}\nasync function approveERC20(args) {\n  const {\n    accountContract,\n    erc20Paymaster,\n    options\n  } = args;\n  const tokenAddress = erc20Paymaster.tokenAddress;\n  const tokenContract = getContract({\n    address: tokenAddress,\n    chain: accountContract.chain,\n    client: accountContract.client\n  });\n  const accountAllowance = await allowance({\n    contract: tokenContract,\n    owner: accountContract.address,\n    spender: erc20Paymaster.paymasterAddress\n  });\n  if (accountAllowance > 0n) {\n    return;\n  }\n  const approveTx = approve({\n    contract: tokenContract,\n    spender: erc20Paymaster.paymasterAddress,\n    amountWei: maxUint96 - 1n\n  });\n  const transaction = await toSerializableTransaction({\n    transaction: approveTx,\n    from: accountContract.address\n  });\n  const executeTx = prepareExecute({\n    accountContract,\n    transaction,\n    executeOverride: options.overrides?.execute\n  });\n  await _sendUserOp({\n    executeTx,\n    options: {\n      ...options,\n      overrides: {\n        ...options.overrides,\n        tokenPaymaster: undefined\n      }\n    }\n  });\n}\nfunction createZkSyncAccount(args) {\n  const {\n    creationOptions,\n    connectionOptions,\n    chain\n  } = args;\n  const account = {\n    address: connectionOptions.personalAccount.address,\n    async sendTransaction(transaction) {\n      // override passed tx, we have to refetch gas and fees always\n      const prepTx = {\n        data: transaction.data,\n        to: transaction.to ?? undefined,\n        value: transaction.value ?? 0n,\n        chain: getCachedChain(transaction.chainId),\n        client: connectionOptions.client,\n        eip712: transaction.eip712\n      };\n      let serializableTransaction = await populateEip712Transaction({\n        account,\n        transaction: prepTx\n      });\n      if (args.sponsorGas && !serializableTransaction.paymaster) {\n        // get paymaster input\n        const pmData = await getZkPaymasterData({\n          options: {\n            client: connectionOptions.client,\n            chain,\n            bundlerUrl: creationOptions.overrides?.bundlerUrl,\n            entrypointAddress: creationOptions.overrides?.entrypointAddress\n          },\n          transaction: serializableTransaction\n        });\n        serializableTransaction = {\n          ...serializableTransaction,\n          ...pmData\n        };\n      }\n      // sign\n      const signedTransaction = await signEip712Transaction({\n        account,\n        chainId: chain.id,\n        eip712Transaction: serializableTransaction\n      });\n      // broadcast via bundler\n      const txHash = await broadcastZkTransaction({\n        options: {\n          client: connectionOptions.client,\n          chain,\n          bundlerUrl: creationOptions.overrides?.bundlerUrl,\n          entrypointAddress: creationOptions.overrides?.entrypointAddress\n        },\n        transaction: serializableTransaction,\n        signedTransaction\n      });\n      return {\n        transactionHash: txHash.transactionHash,\n        client: connectionOptions.client,\n        chain: chain\n      };\n    },\n    async signMessage({\n      message\n    }) {\n      return connectionOptions.personalAccount.signMessage({\n        message\n      });\n    },\n    async signTypedData(_typedData) {\n      const typedData = parseTypedData(_typedData);\n      return connectionOptions.personalAccount.signTypedData(typedData);\n    },\n    async onTransactionRequested(transaction) {\n      return connectionOptions.personalAccount.onTransactionRequested?.(transaction);\n    }\n  };\n  return account;\n}\nasync function _sendUserOp(args) {\n  const {\n    executeTx,\n    options\n  } = args;\n  const unsignedUserOp = await createUnsignedUserOp({\n    transaction: executeTx,\n    factoryContract: options.factoryContract,\n    accountContract: options.accountContract,\n    adminAddress: options.personalAccount.address,\n    sponsorGas: options.sponsorGas,\n    overrides: options.overrides\n  });\n  const signedUserOp = await signUserOp({\n    client: options.client,\n    chain: options.chain,\n    adminAccount: options.personalAccount,\n    entrypointAddress: options.overrides?.entrypointAddress,\n    userOp: unsignedUserOp\n  });\n  const bundlerOptions = {\n    chain: options.chain,\n    client: options.client,\n    bundlerUrl: options.overrides?.bundlerUrl,\n    entrypointAddress: options.overrides?.entrypointAddress\n  };\n  const userOpHash = await bundleUserOp({\n    options: bundlerOptions,\n    userOp: signedUserOp\n  });\n  // wait for tx receipt rather than return the userOp hash\n  const receipt = await waitForUserOpReceipt({\n    ...bundlerOptions,\n    userOpHash\n  });\n  // reset the isDeploying flag after every transaction\n  clearAccountDeploying(options.accountContract);\n  return {\n    client: options.client,\n    chain: options.chain,\n    transactionHash: receipt.transactionHash\n  };\n}\nasync function getEntrypointFromFactory(factoryAddress, client, chain) {\n  const factoryContract = getContract({\n    address: factoryAddress,\n    client,\n    chain\n  });\n  try {\n    const entrypointAddress = await readContract({\n      contract: factoryContract,\n      method: \"function entrypoint() public view returns (address)\"\n    });\n    return entrypointAddress;\n  } catch {\n    return undefined;\n  }\n}\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}