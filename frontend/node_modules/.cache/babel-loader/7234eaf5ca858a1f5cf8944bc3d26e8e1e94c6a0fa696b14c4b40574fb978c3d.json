{"ast":null,"code":"import * as Address from './Address.js';\nimport * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\nimport * as Rlp from './Rlp.js';\nimport * as Signature from './Signature.js';\nimport * as TransactionEnvelope from './TransactionEnvelope.js';\nexport const type = 'legacy';\n/**\n * Asserts a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * TransactionEnvelopeLegacy.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: GasPriceTooHighError:\n * // @error: The gas price (`gasPrice` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nexport function assert(envelope) {\n  const {\n    chainId,\n    gasPrice,\n    to\n  } = envelope;\n  if (to) Address.assert(to, {\n    strict: false\n  });\n  if (typeof chainId !== 'undefined' && chainId <= 0) throw new TransactionEnvelope.InvalidChainIdError({\n    chainId\n  });\n  if (gasPrice && BigInt(gasPrice) > 2n ** 256n - 1n) throw new TransactionEnvelope.GasPriceTooHighError({\n    gasPrice\n  });\n}\n/**\n * Deserializes a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.deserialize('0x01ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   type: 'legacy',\n * // @log:   nonce: 785n,\n * // @log:   gasPrice: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nexport function deserialize(serialized) {\n  const tuple = Rlp.toHex(serialized);\n  const [nonce, gasPrice, gas, to, value, data, chainIdOrV_, r, s] = tuple;\n  if (!(tuple.length === 6 || tuple.length === 9)) throw new TransactionEnvelope.InvalidSerializedError({\n    attributes: {\n      nonce,\n      gasPrice,\n      gas,\n      to,\n      value,\n      data,\n      ...(tuple.length > 6 ? {\n        v: chainIdOrV_,\n        r,\n        s\n      } : {})\n    },\n    serialized,\n    type\n  });\n  const transaction = {\n    type\n  };\n  if (Hex.validate(to) && to !== '0x') transaction.to = to;\n  if (Hex.validate(gas) && gas !== '0x') transaction.gas = BigInt(gas);\n  if (Hex.validate(data) && data !== '0x') transaction.data = data;\n  if (Hex.validate(nonce) && nonce !== '0x') transaction.nonce = BigInt(nonce);\n  if (Hex.validate(value) && value !== '0x') transaction.value = BigInt(value);\n  if (Hex.validate(gasPrice) && gasPrice !== '0x') transaction.gasPrice = BigInt(gasPrice);\n  if (tuple.length === 6) return transaction;\n  const chainIdOrV = Hex.validate(chainIdOrV_) && chainIdOrV_ !== '0x' ? Number(chainIdOrV_) : 0;\n  if (s === '0x' && r === '0x') {\n    if (chainIdOrV > 0) transaction.chainId = Number(chainIdOrV);\n    return transaction;\n  }\n  const v = chainIdOrV;\n  const chainId = Math.floor((v - 35) / 2);\n  if (chainId > 0) transaction.chainId = chainId;else if (v !== 27 && v !== 28) throw new Signature.InvalidVError({\n    value: v\n  });\n  transaction.yParity = Signature.vToYParity(v);\n  transaction.v = v;\n  transaction.s = s === '0x' ? 0n : BigInt(s);\n  transaction.r = r === '0x' ? 0n : BigInt(r);\n  assert(transaction);\n  return transaction;\n}\n/**\n * Converts an arbitrary transaction object into a legacy Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeLegacy.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip7702',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an legacy Transaction Envelope from a {@link ox#TransactionEnvelopeLegacy.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from('0xf858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'legacy',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns A legacy Transaction Envelope.\n */\nexport function from(envelope, options = {}) {\n  const {\n    signature\n  } = options;\n  const envelope_ = typeof envelope === 'string' ? deserialize(envelope) : envelope;\n  assert(envelope_);\n  const signature_ = (() => {\n    if (!signature) return {};\n    const s = Signature.from(signature);\n    s.v = Signature.yParityToV(s.yParity);\n    return s;\n  })();\n  return {\n    ...envelope_,\n    ...signature_,\n    type: 'legacy'\n  };\n}\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeLegacy.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nexport function getSignPayload(envelope) {\n  return hash(envelope, {\n    presign: true\n  });\n}\n/**\n * Hashes a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeLegacy.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeLegacy.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The Legacy Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nexport function hash(envelope, options = {}) {\n  const {\n    presign\n  } = options;\n  return Hash.keccak256(serialize({\n    ...envelope,\n    ...(presign ? {\n      r: undefined,\n      s: undefined,\n      yParity: undefined,\n      v: undefined\n    } : {})\n  }));\n}\n/**\n * Serializes a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeLegacy.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeLegacy.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nexport function serialize(envelope, options = {}) {\n  const {\n    chainId = 0,\n    gas,\n    data,\n    input,\n    nonce,\n    to,\n    value,\n    gasPrice\n  } = envelope;\n  assert(envelope);\n  let serialized = [nonce ? Hex.fromNumber(nonce) : '0x', gasPrice ? Hex.fromNumber(gasPrice) : '0x', gas ? Hex.fromNumber(gas) : '0x', to ?? '0x', value ? Hex.fromNumber(value) : '0x', data ?? input ?? '0x'];\n  const signature = (() => {\n    if (options.signature) return {\n      r: options.signature.r,\n      s: options.signature.s,\n      v: Signature.yParityToV(options.signature.yParity)\n    };\n    if (typeof envelope.r === 'undefined' || typeof envelope.s === 'undefined') return undefined;\n    return {\n      r: envelope.r,\n      s: envelope.s,\n      v: envelope.v\n    };\n  })();\n  if (signature) {\n    const v = (() => {\n      // EIP-155 (inferred chainId)\n      if (signature.v >= 35) {\n        const inferredChainId = Math.floor((signature.v - 35) / 2);\n        if (inferredChainId > 0) return signature.v;\n        return 27 + (signature.v === 35 ? 0 : 1);\n      }\n      // EIP-155 (explicit chainId)\n      if (chainId > 0) return chainId * 2 + 35 + signature.v - 27;\n      // Pre-EIP-155 (no chainId)\n      const v = 27 + (signature.v === 27 ? 0 : 1);\n      if (signature.v !== v) throw new Signature.InvalidVError({\n        value: signature.v\n      });\n      return v;\n    })();\n    serialized = [...serialized, Hex.fromNumber(v), signature.r === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(signature.r)), signature.s === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(signature.s))];\n  } else if (chainId > 0) serialized = [...serialized, Hex.fromNumber(chainId), '0x', '0x'];\n  return Rlp.fromHex(serialized);\n}\n/**\n * Converts an {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy} to an {@link ox#TransactionEnvelopeLegacy.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeLegacy.toRpc(envelope) // [!code focus]\n *\n * const request = RpcRequest.from({\n *   id: 0,\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @param envelope - The legacy transaction envelope to convert.\n * @returns An RPC-formatted legacy transaction envelope.\n */\nexport function toRpc(envelope) {\n  const signature = Signature.extract(envelope);\n  return {\n    ...envelope,\n    chainId: typeof envelope.chainId === 'number' ? Hex.fromNumber(envelope.chainId) : undefined,\n    data: envelope.data ?? envelope.input,\n    type: '0x0',\n    ...(typeof envelope.gas === 'bigint' ? {\n      gas: Hex.fromNumber(envelope.gas)\n    } : {}),\n    ...(typeof envelope.nonce === 'bigint' ? {\n      nonce: Hex.fromNumber(envelope.nonce)\n    } : {}),\n    ...(typeof envelope.value === 'bigint' ? {\n      value: Hex.fromNumber(envelope.value)\n    } : {}),\n    ...(typeof envelope.gasPrice === 'bigint' ? {\n      gasPrice: Hex.fromNumber(envelope.gasPrice)\n    } : {}),\n    ...(signature ? {\n      ...Signature.toRpc(signature),\n      v: signature.yParity === 0 ? '0x1b' : '0x1c'\n    } : {})\n  };\n}\n/**\n * Validates a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeLegacy.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nexport function validate(envelope) {\n  try {\n    assert(envelope);\n    return true;\n  } catch {\n    return false;\n  }\n}\n//# sourceMappingURL=TransactionEnvelopeLegacy.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}