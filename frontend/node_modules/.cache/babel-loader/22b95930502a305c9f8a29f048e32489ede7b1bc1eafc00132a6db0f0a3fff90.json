{"ast":null,"code":"import { SwitchChainError, UserRejectedRequestError, getTypesForEIP712Domain, serializeTypedData, validateTypedData } from \"viem\";\nimport { trackTransaction } from \"../../analytics/track/transaction.js\";\nimport { getCachedChain, getChainMetadata, getRpcUrlForChain } from \"../../chains/utils.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { numberToHex, stringToHex, uint8ArrayToHex } from \"../../utils/encoding/hex.js\";\nimport { stringify } from \"../../utils/json.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parse-typed-data.js\";\nimport { getSavedConnectParamsFromStorage, saveConnectParamsToStorage } from \"../../utils/storage/walletStorage.js\";\nimport { formatWalletConnectUrl } from \"../../utils/url.js\";\nimport { getWalletInfo } from \"../__generated__/getWalletInfo.js\";\nimport { getValidPublicRPCUrl } from \"../utils/chains.js\";\nimport { getDefaultAppMetadata } from \"../utils/defaultDappMetadata.js\";\nimport { normalizeChainId } from \"../utils/normalizeChainId.js\";\nimport { DEFAULT_PROJECT_ID, NAMESPACE } from \"./constants.js\";\nconst ADD_ETH_CHAIN_METHOD = \"wallet_addEthereumChain\";\nconst defaultShowQrModal = true;\nconst storageKeys = {\n  requestedChains: \"tw.wc.requestedChains\",\n  lastUsedChainId: \"tw.wc.lastUsedChainId\"\n};\n/**\n * Checks if the provided wallet is a Wallet Connect wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is a Wallet Connect wallet, false otherwise.\n */\nexport function isWalletConnect(wallet) {\n  return wallet.id === \"walletConnect\";\n}\n/**\n * @internal\n */\nexport async function connectWC(options, emitter, walletId, storage, sessionHandler) {\n  const provider = await initProvider(options, walletId, sessionHandler);\n  const wcOptions = options.walletConnect;\n  let {\n    onDisplayUri\n  } = wcOptions || {};\n  // use default sessionHandler unless onDisplayUri is explicitly provided\n  if (!onDisplayUri && sessionHandler && walletId !== \"walletConnect\") {\n    const walletInfo = await getWalletInfo(walletId);\n    const deeplinkHandler = uri => {\n      const appUrl = walletInfo.mobile.native || walletInfo.mobile.universal;\n      if (!appUrl) {\n        throw new Error(\"No app url found for wallet connect to redirect to.\");\n      }\n      const fullUrl = formatWalletConnectUrl(appUrl, uri).redirect;\n      sessionHandler(fullUrl);\n    };\n    onDisplayUri = deeplinkHandler;\n  }\n  if (onDisplayUri) {\n    provider.events.addListener(\"display_uri\", onDisplayUri);\n  }\n  let optionalChains = wcOptions?.optionalChains;\n  let chainToRequest = options.chain;\n  // ignore the given options chains - and set the safe supported chains\n  if (walletId === \"global.safe\") {\n    optionalChains = chainsToRequestForSafe.map(getCachedChain);\n    if (chainToRequest && !optionalChains.includes(chainToRequest)) {\n      chainToRequest = undefined;\n    }\n  }\n  const {\n    rpcMap,\n    requiredChain,\n    optionalChains: chainsToRequest\n  } = getChainsToRequest({\n    client: options.client,\n    chain: chainToRequest,\n    optionalChains: optionalChains\n  });\n  if (provider.session) {\n    await provider.connect({\n      ...(wcOptions?.pairingTopic ? {\n        pairingTopic: wcOptions?.pairingTopic\n      } : {}),\n      optionalChains: chainsToRequest,\n      chains: requiredChain ? [requiredChain.id] : undefined,\n      rpcMap: rpcMap\n    });\n  }\n  setRequestedChainsIds(chainsToRequest, storage);\n  // If session exists and chains are authorized, enable provider for required chain\n  const addresses = await provider.enable();\n  const address = addresses[0];\n  if (!address) {\n    throw new Error(\"No accounts found on provider.\");\n  }\n  const providerChainId = normalizeChainId(provider.chainId);\n  const chain = options.chain && options.chain.id === providerChainId ? options.chain : getCachedChain(providerChainId);\n  if (options) {\n    const savedParams = {\n      optionalChains: options.walletConnect?.optionalChains,\n      chain: options.chain,\n      pairingTopic: options.walletConnect?.pairingTopic\n    };\n    if (storage) {\n      saveConnectParamsToStorage(storage, walletId, savedParams);\n    }\n  }\n  if (wcOptions?.onDisplayUri) {\n    provider.events.removeListener(\"display_uri\", wcOptions.onDisplayUri);\n  }\n  return onConnect(address, chain, provider, emitter, storage, options.client);\n}\n/**\n * Auto connect to already connected wallet connect session.\n * @internal\n */\nexport async function autoConnectWC(options, emitter, walletId, storage, sessionHandler) {\n  const savedConnectParams = storage ? await getSavedConnectParamsFromStorage(storage, walletId) : null;\n  const provider = await initProvider(savedConnectParams ? {\n    chain: savedConnectParams.chain,\n    client: options.client,\n    walletConnect: {\n      pairingTopic: savedConnectParams.pairingTopic,\n      optionalChains: savedConnectParams.optionalChains\n    }\n  } : {\n    client: options.client,\n    walletConnect: {}\n  }, walletId, sessionHandler, true);\n  const address = provider.accounts[0];\n  if (!address) {\n    throw new Error(\"No accounts found on provider.\");\n  }\n  const providerChainId = normalizeChainId(provider.chainId);\n  const chain = options.chain && options.chain.id === providerChainId ? options.chain : getCachedChain(providerChainId);\n  return onConnect(address, chain, provider, emitter, storage, options.client);\n}\n// Connection utils -----------------------------------------------------------------------------------------------\nasync function initProvider(options, walletId, sessionRequestHandler, isAutoConnect = false) {\n  const walletInfo = await getWalletInfo(walletId);\n  const wcOptions = options.walletConnect;\n  const {\n    EthereumProvider,\n    OPTIONAL_EVENTS,\n    OPTIONAL_METHODS\n  } = await import(\"@walletconnect/ethereum-provider\");\n  let optionalChains = wcOptions?.optionalChains;\n  let chainToRequest = options.chain;\n  // ignore the given options chains - and set the safe supported chains\n  if (walletId === \"global.safe\") {\n    optionalChains = chainsToRequestForSafe.map(getCachedChain);\n    if (chainToRequest && !optionalChains.includes(chainToRequest)) {\n      chainToRequest = undefined;\n    }\n  }\n  const {\n    rpcMap,\n    requiredChain,\n    optionalChains: chainsToRequest\n  } = getChainsToRequest({\n    client: options.client,\n    chain: chainToRequest,\n    optionalChains: optionalChains\n  });\n  const provider = await EthereumProvider.init({\n    showQrModal: wcOptions?.showQrModal === undefined ? sessionRequestHandler ? false : defaultShowQrModal : wcOptions.showQrModal,\n    projectId: wcOptions?.projectId || DEFAULT_PROJECT_ID,\n    optionalMethods: OPTIONAL_METHODS,\n    optionalEvents: OPTIONAL_EVENTS,\n    optionalChains: chainsToRequest,\n    chains: requiredChain ? [requiredChain.id] : undefined,\n    metadata: {\n      name: wcOptions?.appMetadata?.name || getDefaultAppMetadata().name,\n      description: wcOptions?.appMetadata?.description || getDefaultAppMetadata().description,\n      url: wcOptions?.appMetadata?.url || getDefaultAppMetadata().url,\n      icons: [wcOptions?.appMetadata?.logoUrl || getDefaultAppMetadata().logoUrl]\n    },\n    rpcMap: rpcMap,\n    qrModalOptions: wcOptions?.qrModalOptions,\n    disableProviderPing: true\n  });\n  provider.events.setMaxListeners(Number.POSITIVE_INFINITY);\n  // disconnect the provider if chains are stale when (if not auto connecting)\n  if (!isAutoConnect) {\n    // const isStale = await isChainsStale(provider, chainsToRequest);\n    if (provider.session) {\n      await provider.disconnect();\n    }\n  }\n  if (walletId !== \"walletConnect\") {\n    async function handleSessionRequest() {\n      const walletLinkToOpen = provider.session?.peer?.metadata?.redirect?.native || walletInfo.mobile.native || walletInfo.mobile.universal;\n      if (sessionRequestHandler && walletLinkToOpen) {\n        // TODO: propagate error when this fails\n        await sessionRequestHandler(walletLinkToOpen);\n      }\n    }\n    provider.signer.client.on(\"session_request_sent\", handleSessionRequest);\n    provider.events.addListener(\"disconnect\", () => {\n      provider.signer.client.off(\"session_request_sent\", handleSessionRequest);\n    });\n  }\n  return provider;\n}\nfunction createAccount({\n  provider,\n  address,\n  client\n}) {\n  const account = {\n    address: address,\n    async sendTransaction(tx) {\n      const transactionHash = await provider.request({\n        method: \"eth_sendTransaction\",\n        params: [{\n          gas: tx.gas ? numberToHex(tx.gas) : undefined,\n          value: tx.value ? numberToHex(tx.value) : undefined,\n          from: getAddress(address),\n          to: tx.to,\n          data: tx.data\n        }]\n      });\n      trackTransaction({\n        client: client,\n        walletAddress: getAddress(address),\n        walletType: \"walletConnect\",\n        transactionHash,\n        chainId: tx.chainId,\n        contractAddress: tx.to ?? undefined,\n        gasPrice: tx.gasPrice\n      });\n      return {\n        transactionHash\n      };\n    },\n    async signMessage({\n      message\n    }) {\n      const messageToSign = (() => {\n        if (typeof message === \"string\") {\n          return stringToHex(message);\n        }\n        if (message.raw instanceof Uint8Array) {\n          return uint8ArrayToHex(message.raw);\n        }\n        return message.raw;\n      })();\n      return provider.request({\n        method: \"personal_sign\",\n        params: [messageToSign, this.address]\n      });\n    },\n    async signTypedData(_data) {\n      const data = parseTypedData(_data);\n      const {\n        domain,\n        message,\n        primaryType\n      } = data;\n      const types = {\n        EIP712Domain: getTypesForEIP712Domain({\n          domain\n        }),\n        ...data.types\n      };\n      // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n      // as we can't statically check this with TypeScript.\n      validateTypedData({\n        domain,\n        message,\n        primaryType,\n        types\n      });\n      const typedData = serializeTypedData({\n        domain: domain ?? {},\n        message,\n        primaryType,\n        types\n      });\n      return await provider.request({\n        method: \"eth_signTypedData_v4\",\n        params: [this.address, typedData]\n      });\n    }\n  };\n  return account;\n}\nfunction onConnect(address, chain, provider, emitter, storage, client) {\n  const account = createAccount({\n    provider,\n    address,\n    client\n  });\n  async function disconnect() {\n    provider.removeListener(\"accountsChanged\", onAccountsChanged);\n    provider.removeListener(\"chainChanged\", onChainChanged);\n    provider.removeListener(\"disconnect\", onDisconnect);\n    await provider.disconnect();\n  }\n  function onDisconnect() {\n    setRequestedChainsIds([], storage);\n    storage?.removeItem(storageKeys.lastUsedChainId);\n    disconnect();\n    emitter.emit(\"disconnect\", undefined);\n  }\n  function onAccountsChanged(accounts) {\n    if (accounts[0]) {\n      const newAccount = createAccount({\n        provider,\n        address: getAddress(accounts[0]),\n        client\n      });\n      emitter.emit(\"accountChanged\", newAccount);\n      emitter.emit(\"accountsChanged\", accounts);\n    } else {\n      onDisconnect();\n    }\n  }\n  function onChainChanged(newChainId) {\n    const newChain = getCachedChain(normalizeChainId(newChainId));\n    emitter.emit(\"chainChanged\", newChain);\n    storage?.setItem(storageKeys.lastUsedChainId, String(newChainId));\n  }\n  provider.on(\"accountsChanged\", onAccountsChanged);\n  provider.on(\"chainChanged\", onChainChanged);\n  provider.on(\"disconnect\", onDisconnect);\n  provider.on(\"session_delete\", onDisconnect);\n  return [account, chain, disconnect, newChain => switchChainWC(provider, newChain, storage)];\n}\n// Storage utils  -----------------------------------------------------------------------------------------------\nfunction getNamespaceMethods(provider) {\n  return provider.session?.namespaces[NAMESPACE]?.methods || [];\n}\nfunction getNamespaceChainsIds(provider) {\n  const chainIds = provider.session?.namespaces[NAMESPACE]?.chains?.map(chain => Number.parseInt(chain.split(\":\")[1] || \"\"));\n  return chainIds ?? [];\n}\nasync function switchChainWC(provider, chain, storage) {\n  const chainId = chain.id;\n  try {\n    const namespaceChains = getNamespaceChainsIds(provider);\n    const namespaceMethods = getNamespaceMethods(provider);\n    const isChainApproved = namespaceChains.includes(chainId);\n    if (!isChainApproved && namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {\n      const apiChain = await getChainMetadata(chain);\n      const blockExplorerUrls = [...new Set([...(chain.blockExplorers?.map(x => x.url) || []), ...(apiChain.explorers?.map(x => x.url) || [])])];\n      await provider.request({\n        method: ADD_ETH_CHAIN_METHOD,\n        params: [{\n          chainId: numberToHex(apiChain.chainId),\n          chainName: apiChain.name,\n          nativeCurrency: apiChain.nativeCurrency,\n          rpcUrls: getValidPublicRPCUrl(apiChain),\n          // no clientId on purpose\n          blockExplorerUrls: blockExplorerUrls.length > 0 ? blockExplorerUrls : undefined\n        }]\n      });\n      const requestedChains = await getRequestedChainsIds(storage);\n      requestedChains.push(chainId);\n      setRequestedChainsIds(requestedChains, storage);\n    }\n    await provider.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{\n        chainId: numberToHex(chainId)\n      }]\n    });\n  } catch (error) {\n    const message = typeof error === \"string\" ? error : error?.message;\n    if (/user rejected request/i.test(message)) {\n      throw new UserRejectedRequestError(error);\n    }\n    throw new SwitchChainError(error);\n  }\n}\n/**\n * Set the requested chains to the storage.\n * @internal\n */\nfunction setRequestedChainsIds(chains, storage) {\n  storage?.setItem(storageKeys.requestedChains, stringify(chains));\n}\n/**\n * Get the last requested chains from the storage.\n * @internal\n */\nasync function getRequestedChainsIds(storage) {\n  const data = await storage.getItem(storageKeys.requestedChains);\n  return data ? JSON.parse(data) : [];\n}\nfunction getChainsToRequest(options) {\n  const rpcMap = {};\n  if (options.chain) {\n    rpcMap[options.chain.id] = getRpcUrlForChain({\n      chain: options.chain,\n      client: options.client\n    });\n  }\n  // limit optional chains to 10\n  const optionalChains = (options?.optionalChains || []).slice(0, 10);\n  for (const chain of optionalChains) {\n    rpcMap[chain.id] = getRpcUrlForChain({\n      chain: chain,\n      client: options.client\n    });\n  }\n  if (!options.chain && optionalChains.length === 0) {\n    rpcMap[1] = getCachedChain(1).rpc;\n  }\n  return {\n    rpcMap,\n    requiredChain: options.chain ? options.chain : undefined,\n    optionalChains: optionalChains.length > 0 ? optionalChains.map(x => x.id) : [1]\n  };\n}\nconst chainsToRequestForSafe = [1,\n// Ethereum Mainnet\n11155111,\n// Sepolia Testnet\n42161,\n// Arbitrum One Mainnet\n43114,\n// Avalanche Mainnet\n8453,\n// Base Mainnet\n1313161554,\n// Aurora Mainnet\n84532,\n// Base Sepolia Testnet\n56,\n// Binance Smart Chain Mainnet\n42220,\n// Celo Mainnet\n100,\n// Gnosis Mainnet\n10,\n// Optimism Mainnet\n137,\n// Polygon Mainnet\n1101,\n// Polygon zkEVM Mainnet\n324,\n// zkSync Era mainnet\n534352 // Scroll mainnet\n];\n//# sourceMappingURL=controller.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}