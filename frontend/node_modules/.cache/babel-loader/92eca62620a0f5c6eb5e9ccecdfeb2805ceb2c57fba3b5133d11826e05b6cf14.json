{"ast":null,"code":"\"use client\";\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { getChainMetadata } from \"../../../../../chains/utils.js\";\nimport { NATIVE_TOKEN_ADDRESS } from \"../../../../../constants/addresses.js\";\nimport { getContract } from \"../../../../../contract/contract.js\";\nimport { getContractMetadata } from \"../../../../../extensions/common/read/getContractMetadata.js\";\nimport { symbol } from \"../../../../../extensions/common/read/symbol.js\";\nimport { getFunctionId } from \"../../../../../utils/function-id.js\";\nimport { useTokenContext } from \"./provider.js\";\n/**\n * This component fetches then shows the symbol of a token. For ERC20 tokens, it calls the `symbol` function in the ERC20 contract.\n * It inherits all the attributes of a HTML <span> component, hence you can style it just like how you would style a normal <span>\n *\n *\n * @example\n * ### Basic usage\n * ```tsx\n * import { TokenProvider, TokenSymbol } from \"thirdweb/react\";\n * import { ethereum } from \"thirdweb/chains\";\n *\n * <TokenProvider {...props}>\n *   <TokenSymbol  />\n * </TokenProvider>\n * ```\n * Result:\n * ```html\n * <span>ETH</span>\n * ```\n *\n * ### Custom symbol resolver\n * By default, TokenSymbol calls the `symbol` function of your contract,\n * however, if your token as an unconventional way to fetch the symbol, you can pass the custom logic to the `symbolResolver` prop.\n * It can either be a string or a function (async) that returns or resolves to a string.\n * ```tsx\n * async function getSymbol() {\n *   // your own fetching logic\n *   return \"the symbol\";\n * }\n *\n * <TokenSymbol symbolResolver={getSymbol} />\n * ```\n * Alternatively, you can pass in a string directly:\n * ```tsx\n * <TokenSymbol symbolResolver=\"USDC.e\" />\n * ```\n *\n * ### Format the symbol (capitalize, truncate, etc.)\n * The TokenSymbol component accepts a `formatFn` which takes in a string and outputs a string\n * The function is used to modify the symbol of the token\n *\n * ```tsx\n * const concatStr = (str: string):string => str + \"Token\"\n *\n * <TokenSymbol formatFn={concatStr} />\n * ```\n *\n * Result:\n * ```html\n * <span>Ether Token</span>\n * ```\n *\n * ### Show a loading sign when the symbol is being fetched\n * ```tsx\n * import { TokenProvider, TokenSymbol } from \"thirdweb/react\";\n *\n * <TokenProvider address=\"0x...\">\n *   <TokenSymbol loadingComponent={<Spinner />} />\n * </TokenProvider>\n * ```\n *\n * ### Fallback to something when the symbol fails to resolve\n * ```tsx\n * <TokenProvider address=\"0x...\">\n *   <TokenSymbol fallbackComponent={\"Failed to load\"} />\n * </TokenProvider>\n * ```\n *\n * ### Custom query options for useQuery\n * This component uses `@tanstack-query`'s useQuery internally.\n * You can use the `queryOptions` prop for more fine-grained control\n * ```tsx\n * <TokenSymbol queryOptions={{\n *     enabled: isEnabled,\n *     retry: 4,\n *   }}\n * />\n * ```\n *\n * @component\n * @token\n * @beta\n */\nexport function TokenSymbol({\n  symbolResolver,\n  formatFn,\n  loadingComponent,\n  fallbackComponent,\n  queryOptions,\n  ...restProps\n}) {\n  const {\n    address,\n    client,\n    chain\n  } = useTokenContext();\n  const symbolQuery = useQuery({\n    queryKey: getQueryKeys({\n      chainId: chain.id,\n      address,\n      symbolResolver\n    }),\n    queryFn: async () => fetchTokenSymbol({\n      symbolResolver,\n      address,\n      chain,\n      client\n    }),\n    ...queryOptions\n  });\n  if (symbolQuery.isLoading) {\n    return loadingComponent || null;\n  }\n  if (!symbolQuery.data) {\n    return fallbackComponent || null;\n  }\n  if (formatFn && typeof formatFn === \"function\") {\n    return _jsx(\"span\", {\n      ...restProps,\n      children: formatFn(symbolQuery.data)\n    });\n  }\n  return _jsx(\"span\", {\n    ...restProps,\n    children: symbolQuery.data\n  });\n}\n/**\n * @internal Exported for tests only\n */\nexport async function fetchTokenSymbol(props) {\n  const {\n    symbolResolver,\n    address,\n    client,\n    chain\n  } = props;\n  if (typeof symbolResolver === \"string\") {\n    return symbolResolver;\n  }\n  if (typeof symbolResolver === \"function\") {\n    return symbolResolver();\n  }\n  if (address.toLowerCase() === NATIVE_TOKEN_ADDRESS.toLowerCase()) {\n    // Don't wanna use `getChainSymbol` because it has some side effect (it catches error and defaults to \"ETH\")\n    return getChainMetadata(chain).then(data => data.nativeCurrency.symbol);\n  }\n  // Try to fetch the symbol from both the `symbol` function and the contract metadata\n  // then prioritize its result\n  const contract = getContract({\n    address,\n    client,\n    chain\n  });\n  const [_symbol, contractMetadata] = await Promise.all([symbol({\n    contract\n  }).catch(() => undefined), getContractMetadata({\n    contract\n  }).catch(() => undefined)]);\n  if (typeof _symbol === \"string\") {\n    return _symbol;\n  }\n  if (typeof contractMetadata?.symbol === \"string\") {\n    return contractMetadata.symbol;\n  }\n  throw new Error(\"Failed to resolve symbol from both symbol() and contract metadata\");\n}\n/**\n * @internal\n */\nexport function getQueryKeys(props) {\n  const {\n    chainId,\n    address,\n    symbolResolver\n  } = props;\n  return [\"_internal_token_symbol_\", chainId, address, {\n    resolver: typeof symbolResolver === \"string\" ? symbolResolver : typeof symbolResolver === \"function\" ? getFunctionId(symbolResolver) : undefined\n  }];\n}\n//# sourceMappingURL=symbol.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}