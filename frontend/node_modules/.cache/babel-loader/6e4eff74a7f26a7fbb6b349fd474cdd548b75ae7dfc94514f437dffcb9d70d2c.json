{"ast":null,"code":"import { encodeAbiParameters } from \"viem\";\nimport { ZERO_ADDRESS } from \"../../../../constants/addresses.js\";\nimport { getContract } from \"../../../../contract/contract.js\";\nimport { isHex } from \"../../../../utils/encoding/helpers/is-hex.js\";\nimport { keccak256 } from \"../../../../utils/hashing/keccak256.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nimport { readContract } from \"../../../read-contract.js\";\n// we do not send multiple batches so this stays consistent\nconst BATCH_ID = 0n;\n/**\n * @internal - only exported for testing\n */\nexport async function prepareBiconomyTransaction({\n  account,\n  serializableTransaction,\n  transaction,\n  gasless\n}) {\n  const forwarderContract = getContract({\n    address: gasless.relayerForwarderAddress,\n    chain: transaction.chain,\n    client: transaction.client\n  });\n  // get the nonce\n  const nonce = await readContract({\n    contract: forwarderContract,\n    method: \"function getNonce(address,uint256) view returns (uint256)\",\n    params: [account.address, BATCH_ID]\n  });\n  const deadline = Math.floor(Date.now() / 1000) + (gasless.deadlineSeconds ?? 3600);\n  const request = {\n    from: account.address,\n    to: serializableTransaction.to,\n    token: ZERO_ADDRESS,\n    txGas: serializableTransaction.gas,\n    tokenGasPrice: 0n,\n    batchId: BATCH_ID,\n    batchNonce: nonce,\n    deadline: deadline,\n    data: serializableTransaction.data\n  };\n  if (!request.to) {\n    throw new Error(\"Cannot send a transaction without a `to` address\");\n  }\n  if (!request.txGas) {\n    throw new Error(\"Cannot send a transaction without a `gas` value\");\n  }\n  if (!request.data) {\n    throw new Error(\"Cannot send a transaction without a `data` value\");\n  }\n  // create the hash\n  const message = encodeAbiParameters([{\n    type: \"address\"\n  }, {\n    type: \"address\"\n  }, {\n    type: \"address\"\n  }, {\n    type: \"uint256\"\n  }, {\n    type: \"uint256\"\n  }, {\n    type: \"uint256\"\n  }, {\n    type: \"uint256\"\n  }, {\n    type: \"bytes32\"\n  }], [request.from, request.to, request.token, request.txGas, request.tokenGasPrice, request.batchId, request.batchNonce, keccak256(request.data)]);\n  const signature = await account.signMessage({\n    message\n  });\n  return [request, signature];\n}\n/**\n * @internal\n */\nexport async function relayBiconomyTransaction(options) {\n  const [request, signature] = await prepareBiconomyTransaction(options);\n  // send the transaction to the biconomy api\n  const response = await fetch(\"https://api.biconomy.io/api/v2/meta-tx/native\", {\n    method: \"POST\",\n    body: stringify({\n      apiId: options.gasless.apiId,\n      params: [request, signature],\n      from: request.from,\n      to: request.to,\n      gasLimit: request.txGas\n    }),\n    headers: {\n      \"x-api-key\": options.gasless.apiKey,\n      \"Content-Type\": \"application/json;charset=utf-8\"\n    }\n  });\n  if (!response.ok) {\n    response.body?.cancel();\n    throw new Error(`Failed to send transaction: ${await response.text()}`);\n  }\n  const json = await response.json();\n  const transactionHash = json.txHash;\n  if (isHex(transactionHash)) {\n    return {\n      transactionHash: transactionHash,\n      chain: options.transaction.chain,\n      client: options.transaction.client\n    };\n  }\n  throw new Error(`Failed to send transaction: ${stringify(json)}`);\n}\n//# sourceMappingURL=biconomy.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}