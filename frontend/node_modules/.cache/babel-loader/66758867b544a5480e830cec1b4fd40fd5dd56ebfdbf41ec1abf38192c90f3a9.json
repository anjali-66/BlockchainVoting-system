{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useWeb3React = exports.Web3ReactProvider = void 0;\nconst react_1 = __importStar(require(\"react\"));\nconst hooks_1 = require(\"./hooks\");\nconst Web3Context = (0, react_1.createContext)(undefined);\nfunction Web3ReactProvider({\n  children,\n  connectors,\n  connectorOverride,\n  network,\n  lookupENS = true\n}) {\n  const cachedConnectors = (0, react_1.useRef)(connectors);\n  // because we're calling `getPriorityConnector` with these connectors, we need to ensure that they're not changing in place\n  if (connectors.length != cachedConnectors.current.length || connectors.some((connector, i) => {\n    const cachedConnector = cachedConnectors.current[i];\n    // because a \"connector\" is actually an array, we want to be sure to only perform an equality check on the actual Connector\n    // class instance, to see if they're the same object\n    return connector[0] !== cachedConnector[0];\n  })) throw new Error('The connectors prop passed to Web3ReactProvider must be referentially static. If connectors is changing, try providing a key prop to Web3ReactProvider that changes every time connectors changes.');\n  const hooks = (0, hooks_1.getPriorityConnector)(...connectors);\n  const {\n    usePriorityConnector,\n    useSelectedChainId,\n    useSelectedAccounts,\n    useSelectedIsActivating,\n    useSelectedAccount,\n    useSelectedIsActive,\n    useSelectedProvider,\n    useSelectedENSNames,\n    useSelectedENSName\n  } = hooks;\n  const priorityConnector = usePriorityConnector();\n  const connector = connectorOverride !== null && connectorOverride !== void 0 ? connectorOverride : priorityConnector;\n  const chainId = useSelectedChainId(connector);\n  const accounts = useSelectedAccounts(connector);\n  const isActivating = useSelectedIsActivating(connector);\n  const account = useSelectedAccount(connector);\n  const isActive = useSelectedIsActive(connector);\n  // note that we've omitted a <T extends BaseProvider = Web3Provider> generic type\n  // in Web3ReactProvider, and thus can't pass T through to useSelectedProvider below.\n  // this is because if we did so, the type of provider would include T, but that would\n  // conflict because Web3Context can't take a generic. however, this isn't particularly\n  // important, because useWeb3React (below) is manually typed\n  const provider = useSelectedProvider(connector, network);\n  const ENSNames = useSelectedENSNames(connector, lookupENS ? provider : undefined);\n  const ENSName = useSelectedENSName(connector, lookupENS ? provider : undefined);\n  return react_1.default.createElement(Web3Context.Provider, {\n    value: {\n      connector,\n      chainId,\n      accounts,\n      isActivating,\n      account,\n      isActive,\n      provider,\n      ENSNames,\n      ENSName,\n      hooks\n    }\n  }, children);\n}\nexports.Web3ReactProvider = Web3ReactProvider;\nfunction useWeb3React() {\n  const context = (0, react_1.useContext)(Web3Context);\n  if (!context) throw Error('useWeb3React can only be used within the Web3ReactProvider component');\n  return context;\n}\nexports.useWeb3React = useWeb3React;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}