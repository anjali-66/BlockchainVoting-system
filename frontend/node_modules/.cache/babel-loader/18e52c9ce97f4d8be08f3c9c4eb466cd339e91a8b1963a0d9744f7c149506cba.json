{"ast":null,"code":"\"use client\";\n\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\nimport { useState } from \"react\";\nimport { waitForReceipt } from \"../../../transaction/actions/wait-for-tx-receipt.js\";\nimport { isBaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { isObjectWithKeys } from \"../../../utils/type-guards.js\";\nimport { structuralSharing } from \"../utils/structuralSharing.js\";\nimport { SetRootElementContext } from \"./RootElementContext.js\";\nimport { ConnectionManagerCtx } from \"./connection-manager.js\";\nimport { invalidateWalletBalance } from \"./invalidateWalletBalance.js\";\n/**\n * @internal\n */\nexport function ThirdwebProviderCore(props) {\n  const [el, setEl] = useState(null);\n  const [queryClient] = useState(() => new QueryClient({\n    defaultOptions: {\n      mutations: {\n        onSettled: (data, _error, variables) => {\n          if (isBaseTransactionOptions(variables)) {\n            if (isObjectWithKeys(data, [\"transactionHash\"]) && isObjectWithKeys(variables, [\"client\", \"chain\"])) {\n              waitForReceipt({\n                transactionHash: data.transactionHash,\n                // We know it exists from the if\n                client: variables.client,\n                chain: variables.chain\n              }).catch(e => {\n                // swallow errors for receipts, but log\n                console.error(\"[Transaction Error]\", e);\n              }).then(() => {\n                return Promise.all([queryClient.invalidateQueries({\n                  queryKey:\n                  // invalidate any readContract queries for this chainId:contractAddress\n                  [\"readContract\", variables.__contract?.chain.id, variables.__contract?.address]\n                }), invalidateWalletBalance(queryClient, variables.__contract?.chain.id)]);\n              });\n            }\n          }\n        }\n      },\n      queries: {\n        // With SSR, we usually want to set some default staleTime\n        // above 0 to avoid refetching immediately on the client\n        staleTime: 60 * 1000,\n        structuralSharing\n      }\n    }\n  }));\n  return _jsx(ConnectionManagerCtx.Provider, {\n    value: props.manager,\n    children: _jsxs(QueryClientProvider, {\n      client: queryClient,\n      children: [_jsx(SetRootElementContext.Provider, {\n        value: setEl,\n        children: props.children\n      }), el]\n    })\n  });\n}\n//# sourceMappingURL=thirdweb-provider.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}