{"ast":null,"code":"import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { useState } from \"react\";\nimport { useBuyWithFiatStatus } from \"../../../../../../core/hooks/pay/useBuyWithFiatStatus.js\";\nimport { Container, Line, ModalHeader } from \"../../../../components/basic.js\";\nimport { OnRampTxDetailsTable } from \"../fiat/FiatTxDetailsTable.js\";\nimport { PostOnRampSwapFlow } from \"../fiat/PostOnRampSwapFlow.js\";\nimport { getBuyWithFiatStatusMeta } from \"./statusMeta.js\";\nexport function FiatDetailsScreen(props) {\n  const initialStatus = props.status;\n  const [stopPolling, setStopPolling] = useState(false);\n  const statusQuery = useBuyWithFiatStatus(stopPolling ? undefined : {\n    client: props.client,\n    intentId: initialStatus.intentId\n  });\n  const status = (statusQuery.data?.status === \"NOT_FOUND\" ? undefined : statusQuery.data) || initialStatus;\n  const hasTwoSteps = isSwapRequiredAfterOnRamp(status);\n  const statusMeta = getBuyWithFiatStatusMeta(status);\n  if (hasTwoSteps) {\n    const fiatQuote = status.quote;\n    return _jsx(PostOnRampSwapFlow, {\n      title: props.title,\n      client: props.client,\n      status: status,\n      onBack: props.onBack,\n      transactionMode: props.transactionMode,\n      isEmbed: props.isEmbed,\n      quote: {\n        fromCurrencyAmount: fiatQuote.fromCurrencyWithFees.amount,\n        fromCurrencySymbol: fiatQuote.fromCurrencyWithFees.currencySymbol,\n        onRampTokenAmount: fiatQuote.estimatedOnRampAmount,\n        toTokenAmount: fiatQuote.estimatedToTokenAmount,\n        onRampToken: {\n          chainId: fiatQuote.onRampToken.chainId,\n          tokenAddress: fiatQuote.onRampToken.tokenAddress,\n          name: fiatQuote.onRampToken.name,\n          symbol: fiatQuote.onRampToken.symbol\n        },\n        toToken: {\n          chainId: fiatQuote.toToken.chainId,\n          tokenAddress: fiatQuote.toToken.tokenAddress,\n          name: fiatQuote.toToken.name,\n          symbol: fiatQuote.toToken.symbol\n        }\n      },\n      onDone: props.onDone,\n      onSwapFlowStarted: () => {\n        setStopPolling(true);\n      },\n      payer: props.payer,\n      // viewing history - ignore onSuccess\n      onSuccess: undefined\n    });\n  }\n  return _jsxs(Container, {\n    children: [_jsx(Container, {\n      p: \"lg\",\n      children: _jsx(ModalHeader, {\n        title: \"Transaction Details\",\n        onBack: props.onBack\n      })\n    }), _jsx(Line, {}), _jsx(Container, {\n      p: \"lg\",\n      children: _jsx(OnRampTxDetailsTable, {\n        client: props.client,\n        token: status.source ? {\n          chainId: status.source.token.chainId,\n          address: status.source.token.tokenAddress,\n          symbol: status.source.token.symbol || \"\",\n          amount: status.source.amount\n        } : {\n          address: status.quote.onRampToken.tokenAddress,\n          amount: status.quote.estimatedOnRampAmount,\n          chainId: status.quote.onRampToken.chainId,\n          symbol: status.quote.onRampToken.symbol || \"\"\n        },\n        fiat: {\n          amount: status.quote.fromCurrencyWithFees.amount,\n          currencySymbol: status.quote.fromCurrencyWithFees.currencySymbol\n        },\n        statusMeta: {\n          color: statusMeta.color,\n          text: statusMeta.status,\n          txHash: status.source?.transactionHash\n        }\n      })\n    })]\n  });\n}\n// if the toToken is the same as the onRampToken, no swap is required\nfunction isSwapRequiredAfterOnRamp(buyWithFiatStatus) {\n  if (buyWithFiatStatus.status === \"NOT_FOUND\") {\n    return false;\n  }\n  const sameChain = buyWithFiatStatus.quote.toToken.chainId === buyWithFiatStatus.quote.onRampToken.chainId;\n  const sameToken = buyWithFiatStatus.quote.toToken.tokenAddress === buyWithFiatStatus.quote.onRampToken.tokenAddress;\n  return !(sameChain && sameToken);\n}\n//# sourceMappingURL=FiatDetailsScreen.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}