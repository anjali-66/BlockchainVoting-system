{"ast":null,"code":"import { cachedTextDecoder } from \"./text-decoder.js\";\nconst uint8ArrayStringified = \"[object Uint8Array]\";\n/**\n * Throw a `TypeError` if the given value is not an instance of `Uint8Array`.\n * @example\n * ```ts\n * import {assertUint8Array} from 'uint8array-extras';\n *\n * try {\n * assertUint8Array(new ArrayBuffer(10)); // Throws a TypeError\n * } catch (error) {\n * console.error(error.message);\n * }\n * ```\n */\nfunction assertUint8Array(value) {\n  if (!isUint8Array(value)) {\n    throw new TypeError(`Expected \\`Uint8Array\\`, got \\`${typeof value}\\``);\n  }\n}\n/**\n * Check if the given value is an instance of `Uint8Array`.\n *\n * Replacement for [`Buffer.isBuffer()`](https://nodejs.org/api/buffer.html#static-method-bufferisbufferobj).\n * @example\n * ```ts\n * import {isUint8Array} from 'uint8array-extras';\n *\n * console.log(isUint8Array(new Uint8Array()));\n * //=> true\n *\n * console.log(isUint8Array(Buffer.from('x')));\n * //=> true\n *\n * console.log(isUint8Array(new ArrayBuffer(10)));\n * //=> false\n * ```\n */\nexport function isUint8Array(value) {\n  if (!value) {\n    return false;\n  }\n  if (value.constructor === Uint8Array) {\n    return true;\n  }\n  return Object.prototype.toString.call(value) === uint8ArrayStringified;\n}\n/**\n * Check if two arrays are identical by verifying that they contain the same bytes in the same sequence.\n *\n * Replacement for [`Buffer#equals()`](https://nodejs.org/api/buffer.html#bufequalsotherbuffer).\n * @example\n * ```ts\n * import {areUint8ArraysEqual} from 'uint8array-extras';\n *\n * const a = new Uint8Array([1, 2, 3]);\n * const b = new Uint8Array([1, 2, 3]);\n * const c = new Uint8Array([4, 5, 6]);\n *\n * console.log(areUint8ArraysEqual(a, b));\n * //=> true\n *\n * console.log(areUint8ArraysEqual(a, c));\n * //=> false\n * ```\n */\nexport function areUint8ArraysEqual(a, b) {\n  assertUint8Array(a);\n  assertUint8Array(b);\n  if (a === b) {\n    return true;\n  }\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let index = 0; index < a.length; index++) {\n    if (a[index] !== b[index]) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * Convert a `Uint8Array` (containing a UTF-8 string) to a string.\n *\n * Replacement for [`Buffer#toString()`](https://nodejs.org/api/buffer.html#buftostringencoding-start-end).\n * @example\n * ```ts\n * import {uint8ArrayToString} from 'uint8array-extras';\n *\n * const byteArray = new Uint8Array([72, 101, 108, 108, 111]);\n *\n * console.log(uint8ArrayToString(byteArray));\n * //=> 'Hello'\n * ```\n */\nfunction uint8ArrayToString(array) {\n  assertUint8Array(array);\n  return cachedTextDecoder().decode(array);\n}\nfunction assertString(value) {\n  if (typeof value !== \"string\") {\n    throw new TypeError(`Expected \\`string\\`, got \\`${typeof value}\\``);\n  }\n}\nexport function base64UrlToBase64(base64url) {\n  // Replace Base64URL characters with Base64 characters\n  let base64 = base64url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  // Add padding if necessary\n  const padding = base64.length % 4;\n  if (padding !== 0) {\n    base64 += \"=\".repeat(4 - padding);\n  }\n  return base64;\n}\n/**\n * Convert a Base64-encoded or [Base64URL](https://base64.guru/standards/base64url)-encoded string to a `Uint8Array`.\n *\n * Replacement for [`Buffer.from('SGVsbG8=', 'base64')`](https://nodejs.org/api/buffer.html#static-method-bufferfromstring-encoding).\n * @example\n * ```ts\n * import {base64ToUint8Array} from 'uint8array-extras';\n *\n * console.log(base64ToUint8Array('SGVsbG8='));\n * //=> Uint8Array [72, 101, 108, 108, 111]\n * ```\n */\nexport function base64ToUint8Array(base64String) {\n  assertString(base64String);\n  return Uint8Array.from(globalThis.atob(base64UrlToBase64(base64String)),\n  // biome-ignore lint/style/noNonNullAssertion: we know that the code points exist\n  x => x.codePointAt(0));\n}\n/**\n * Decode a Base64-encoded or [Base64URL](https://base64.guru/standards/base64url)-encoded string to a string.\n *\n * Replacement for `Buffer.from('SGVsbG8=', 'base64').toString()` and [`atob()`](https://developer.mozilla.org/en-US/docs/Web/API/atob).\n * @example\n * ```ts\n * import {base64ToString} from 'uint8array-extras';\n *\n * console.log(base64ToString('SGVsbG8='));\n * //=> 'Hello'\n * ```\n */\nexport function base64ToString(base64String) {\n  assertString(base64String);\n  return uint8ArrayToString(base64ToUint8Array(base64String));\n}\nfunction base64ToBase64Url(base64) {\n  return base64.replaceAll(\"+\", \"-\").replaceAll(\"/\", \"_\").replace(/=+$/, \"\");\n}\n// Reference: https://phuoc.ng/collection/this-vs-that/concat-vs-push/\nconst MAX_BLOCK_SIZE = 65_535;\nexport function uint8ArrayToBase64(array, {\n  urlSafe = false\n} = {}) {\n  assertUint8Array(array);\n  let base64;\n  if (array.length < MAX_BLOCK_SIZE) {\n    // Required as `btoa` and `atob` don't properly support Unicode: https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem\n    // @ts-expect-error - TS doesn't know about `String#fromCodePoint`\n    base64 = globalThis.btoa(String.fromCodePoint.apply(this, array));\n  } else {\n    base64 = \"\";\n    for (const value of array) {\n      base64 += String.fromCodePoint(value);\n    }\n    base64 = globalThis.btoa(base64);\n  }\n  return urlSafe ? base64ToBase64Url(base64) : base64;\n}\nexport function concatUint8Arrays(arrays, totalLength) {\n  if (arrays.length === 0) {\n    return new Uint8Array(0);\n  }\n  const calculatedTotalLength = totalLength ?? arrays.reduce((accumulator, currentValue) => accumulator + currentValue.length, 0);\n  const returnValue = new Uint8Array(calculatedTotalLength);\n  let offset = 0;\n  for (const array of arrays) {\n    assertUint8Array(array);\n    returnValue.set(array, offset);\n    offset += array.length;\n  }\n  return returnValue;\n}\nexport function compareUint8Arrays(a, b) {\n  assertUint8Array(a);\n  assertUint8Array(b);\n  const length = Math.min(a.length, b.length);\n  for (let index = 0; index < length; index++) {\n    // biome-ignore lint/style/noNonNullAssertion: we check the length above so the index is always in bounds\n    const diff = a[index] - b[index];\n    if (diff !== 0) {\n      return Math.sign(diff);\n    }\n  }\n  // At this point, all the compared elements are equal.\n  // The shorter array should come first if the arrays are of different lengths.\n  return Math.sign(a.length - b.length);\n}\n//# sourceMappingURL=uint8-array.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}