{"ast":null,"code":"import { maxUint96 } from \"ox/Solidity\";\nimport { concat, keccak256, toHex } from \"viem\";\nimport { getContract } from \"../../../contract/contract.js\";\nimport { getNonce } from \"../../../extensions/erc4337/__generated__/IEntryPoint/read/getNonce.js\";\nimport { getUserOpHash as getUserOpHashV06 } from \"../../../extensions/erc4337/__generated__/IEntryPoint/read/getUserOpHash.js\";\nimport { getUserOpHash as getUserOpHashV07 } from \"../../../extensions/erc4337/__generated__/IEntryPoint_v07/read/getUserOpHash.js\";\nimport { getDefaultGasOverrides } from \"../../../gas/fee-data.js\";\nimport { encode } from \"../../../transaction/actions/encode.js\";\nimport { toSerializableTransaction } from \"../../../transaction/actions/to-serializable-transaction.js\";\nimport { encodeAbiParameters } from \"../../../utils/abi/encodeAbiParameters.js\";\nimport { isContractDeployed } from \"../../../utils/bytecode/is-contract-deployed.js\";\nimport { hexToBytes } from \"../../../utils/encoding/to-bytes.js\";\nimport { isThirdwebUrl } from \"../../../utils/fetch.js\";\nimport { resolvePromisedValue } from \"../../../utils/promise/resolve-promised-value.js\";\nimport { estimateUserOpGas, getUserOpGasFees, getUserOpReceipt } from \"./bundler.js\";\nimport { predictAddress, prepareBatchExecute, prepareCreateAccount, prepareExecute } from \"./calls.js\";\nimport { DUMMY_SIGNATURE, ENTRYPOINT_ADDRESS_v0_6, ENTRYPOINT_ADDRESS_v0_7, getDefaultAccountFactory, getDefaultBundlerUrl, getEntryPointVersion } from \"./constants.js\";\nimport { getPackedUserOperation } from \"./packUserOp.js\";\nimport { getPaymasterAndData } from \"./paymaster.js\";\nimport { generateRandomUint192 } from \"./utils.js\";\nconst isDeployingSet = new Set();\nconst getKey = accountContract => {\n  return `${accountContract.chain.id}:${accountContract.address}`;\n};\nconst markAccountDeploying = accountContract => {\n  isDeployingSet.add(getKey(accountContract));\n};\nexport const clearAccountDeploying = accountContract => {\n  isDeployingSet.delete(getKey(accountContract));\n};\nconst isAccountDeploying = accountContract => {\n  return isDeployingSet.has(getKey(accountContract));\n};\n/**\n * Wait for the user operation to be mined.\n * @param args - The options and user operation hash\n * @returns - The transaction receipt\n *\n * @example\n * ```ts\n * import { waitForUserOpReceipt } from \"thirdweb/wallets/smart\";\n *\n * const receipt = await waitForUserOpReceipt({\n *  chain,\n *  client,\n *  userOpHash,\n * });\n * ```\n * @walletUtils\n */\nexport async function waitForUserOpReceipt(args) {\n  const timeout = args.timeoutMs || 120000; // 2mins\n  const interval = args.intervalMs || 1000; // 1s\n  const endtime = Date.now() + timeout;\n  while (Date.now() < endtime) {\n    const userOpReceipt = await getUserOpReceipt(args);\n    if (userOpReceipt) {\n      return userOpReceipt;\n    }\n    await new Promise(resolve => setTimeout(resolve, interval));\n  }\n  throw new Error(`Timeout waiting for userOp to be mined on chain ${args.chain.id} with UserOp hash: ${args.userOpHash}`);\n}\n/**\n * Creates an unsigned user operation from a prepared transaction.\n * @param args - The prepared transaction and options\n * @returns - The unsigned user operation\n * @example\n * ```ts\n * import { createUnsignedUserOp } from \"thirdweb/wallets/smart\";\n *\n * const transaction = prepareContractCall(...);\n *\n * const userOp = await createUnsignedUserOp({\n *  transaction,\n *  factoryContract,\n *  accountContract,\n *  adminAddress,\n *  sponsorGas,\n *  overrides,\n * });\n * ```\n * @walletUtils\n */\nexport async function createUnsignedUserOp(args) {\n  const {\n    transaction: executeTx,\n    accountContract,\n    factoryContract,\n    adminAddress,\n    overrides,\n    sponsorGas,\n    waitForDeployment = true\n  } = args;\n  const chain = executeTx.chain;\n  const client = executeTx.client;\n  const bundlerOptions = {\n    client,\n    chain,\n    bundlerUrl: overrides?.bundlerUrl,\n    entrypointAddress: overrides?.entrypointAddress\n  };\n  const entrypointVersion = getEntryPointVersion(args.overrides?.entrypointAddress || ENTRYPOINT_ADDRESS_v0_6);\n  const [isDeployed, callData, callGasLimit, gasFees, nonce] = await Promise.all([isContractDeployed(accountContract), encode(executeTx), resolvePromisedValue(executeTx.gas), getGasFees({\n    executeTx,\n    bundlerOptions,\n    chain,\n    client\n  }), getAccountNonce({\n    accountContract,\n    chain,\n    client,\n    entrypointAddress: overrides?.entrypointAddress,\n    getNonceOverride: overrides?.getAccountNonce\n  })]);\n  const {\n    maxFeePerGas,\n    maxPriorityFeePerGas\n  } = gasFees;\n  if (entrypointVersion === \"v0.7\") {\n    return populateUserOp_v0_7({\n      bundlerOptions,\n      factoryContract,\n      accountContract,\n      adminAddress,\n      sponsorGas,\n      overrides,\n      isDeployed,\n      nonce,\n      callData,\n      callGasLimit,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      waitForDeployment\n    });\n  }\n  // default to v0.6\n  return populateUserOp_v0_6({\n    bundlerOptions,\n    factoryContract,\n    accountContract,\n    adminAddress,\n    sponsorGas,\n    overrides,\n    isDeployed,\n    nonce,\n    callData,\n    callGasLimit,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    waitForDeployment\n  });\n}\nasync function getGasFees(args) {\n  const {\n    executeTx,\n    bundlerOptions,\n    chain,\n    client\n  } = args;\n  let {\n    maxFeePerGas,\n    maxPriorityFeePerGas\n  } = executeTx;\n  const bundlerUrl = bundlerOptions?.bundlerUrl ?? getDefaultBundlerUrl(chain);\n  if (isThirdwebUrl(bundlerUrl)) {\n    // get gas prices from bundler\n    const bundlerGasPrice = await getUserOpGasFees({\n      options: bundlerOptions\n    });\n    maxFeePerGas = bundlerGasPrice.maxFeePerGas;\n    maxPriorityFeePerGas = bundlerGasPrice.maxPriorityFeePerGas;\n  } else {\n    // Check for explicity values\n    const [resolvedMaxFeePerGas, resolvedMaxPriorityFeePerGas] = await Promise.all([resolvePromisedValue(maxFeePerGas), resolvePromisedValue(maxPriorityFeePerGas)]);\n    if (resolvedMaxFeePerGas && resolvedMaxPriorityFeePerGas) {\n      // Save a network call if the values are provided\n      maxFeePerGas = resolvedMaxFeePerGas;\n      maxPriorityFeePerGas = resolvedMaxPriorityFeePerGas;\n    } else {\n      // Fallback to RPC gas prices if no explicit values provided\n      const feeData = await getDefaultGasOverrides(client, chain);\n      // Still check for explicit values in case one is provided and not the other\n      maxPriorityFeePerGas = resolvedMaxPriorityFeePerGas ?? feeData.maxPriorityFeePerGas ?? 0n;\n      maxFeePerGas = resolvedMaxFeePerGas ?? feeData.maxFeePerGas ?? 0n;\n    }\n  }\n  return {\n    maxFeePerGas,\n    maxPriorityFeePerGas\n  };\n}\nasync function populateUserOp_v0_7(args) {\n  const {\n    bundlerOptions,\n    isDeployed,\n    factoryContract,\n    accountContract,\n    adminAddress,\n    sponsorGas,\n    overrides,\n    nonce,\n    callData,\n    callGasLimit,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    waitForDeployment\n  } = args;\n  const {\n    chain,\n    client\n  } = bundlerOptions;\n  let factory;\n  let factoryData;\n  if (isDeployed || isAccountDeploying(accountContract)) {\n    factoryData = \"0x\";\n    if (waitForDeployment) {\n      // lock until account is deployed if needed to avoid 'sender already created' errors when sending multiple transactions in parallel\n      await waitForAccountDeployed(accountContract);\n    }\n  } else {\n    factory = factoryContract.address;\n    factoryData = await encode(prepareCreateAccount({\n      factoryContract: factoryContract,\n      adminAddress,\n      accountSalt: overrides?.accountSalt,\n      createAccountOverride: overrides?.createAccount\n    }));\n    markAccountDeploying(accountContract);\n  }\n  const partialOp = {\n    sender: accountContract.address,\n    nonce,\n    callData,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    callGasLimit: callGasLimit ?? 0n,\n    verificationGasLimit: 0n,\n    preVerificationGas: 0n,\n    factory,\n    factoryData,\n    paymaster: undefined,\n    paymasterData: \"0x\",\n    paymasterVerificationGasLimit: 0n,\n    paymasterPostOpGasLimit: 0n,\n    signature: DUMMY_SIGNATURE\n  };\n  if (sponsorGas) {\n    const paymasterResult = await getPaymasterAndData({\n      userOp: partialOp,\n      chain,\n      client,\n      entrypointAddress: overrides?.entrypointAddress,\n      paymasterOverride: overrides?.paymaster\n    });\n    if (paymasterResult.paymaster && paymasterResult.paymasterData) {\n      partialOp.paymaster = paymasterResult.paymaster;\n      partialOp.paymasterData = paymasterResult.paymasterData;\n    }\n    // paymaster can have the gas limits in the response\n    if (paymasterResult.callGasLimit && paymasterResult.verificationGasLimit && paymasterResult.preVerificationGas && paymasterResult.paymasterPostOpGasLimit && paymasterResult.paymasterVerificationGasLimit) {\n      partialOp.callGasLimit = paymasterResult.callGasLimit;\n      partialOp.verificationGasLimit = paymasterResult.verificationGasLimit;\n      partialOp.preVerificationGas = paymasterResult.preVerificationGas;\n      partialOp.paymasterPostOpGasLimit = paymasterResult.paymasterPostOpGasLimit;\n      partialOp.paymasterVerificationGasLimit = paymasterResult.paymasterVerificationGasLimit;\n    } else {\n      // otherwise fallback to bundler for gas limits\n      const stateOverrides = overrides?.tokenPaymaster ? {\n        [overrides.tokenPaymaster.tokenAddress]: {\n          stateDiff: {\n            [keccak256(encodeAbiParameters([{\n              type: \"address\"\n            }, {\n              type: \"uint256\"\n            }], [accountContract.address, overrides.tokenPaymaster.balanceStorageSlot]))]: toHex(maxUint96, {\n              size: 32\n            })\n          }\n        }\n      } : undefined;\n      const estimates = await estimateUserOpGas({\n        userOp: partialOp,\n        options: bundlerOptions\n      }, stateOverrides);\n      partialOp.callGasLimit = estimates.callGasLimit;\n      partialOp.verificationGasLimit = estimates.verificationGasLimit;\n      partialOp.preVerificationGas = estimates.preVerificationGas;\n      partialOp.paymasterPostOpGasLimit = overrides?.tokenPaymaster ? 500000n // TODO: estimate this better, needed if there's an extra swap needed in the paymaster\n      : estimates.paymasterPostOpGasLimit || 0n;\n      partialOp.paymasterVerificationGasLimit = estimates.paymasterVerificationGasLimit || 0n;\n      // need paymaster to re-sign after estimates\n      const paymasterResult2 = await getPaymasterAndData({\n        userOp: partialOp,\n        chain,\n        client,\n        entrypointAddress: overrides?.entrypointAddress,\n        paymasterOverride: overrides?.paymaster\n      });\n      if (paymasterResult2.paymaster && paymasterResult2.paymasterData) {\n        partialOp.paymaster = paymasterResult2.paymaster;\n        partialOp.paymasterData = paymasterResult2.paymasterData;\n      }\n    }\n  } else {\n    // not gasless, so we just need to estimate gas limits\n    const estimates = await estimateUserOpGas({\n      userOp: partialOp,\n      options: bundlerOptions\n    });\n    partialOp.callGasLimit = estimates.callGasLimit;\n    partialOp.verificationGasLimit = estimates.verificationGasLimit;\n    partialOp.preVerificationGas = estimates.preVerificationGas;\n    partialOp.paymasterPostOpGasLimit = estimates.paymasterPostOpGasLimit || 0n;\n    partialOp.paymasterVerificationGasLimit = estimates.paymasterVerificationGasLimit || 0n;\n  }\n  return {\n    ...partialOp,\n    signature: \"0x\"\n  };\n}\nasync function populateUserOp_v0_6(args) {\n  const {\n    bundlerOptions,\n    isDeployed,\n    factoryContract,\n    accountContract,\n    adminAddress,\n    sponsorGas,\n    overrides,\n    nonce,\n    callData,\n    callGasLimit,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    waitForDeployment\n  } = args;\n  const {\n    chain,\n    client\n  } = bundlerOptions;\n  let initCode;\n  if (isDeployed || isAccountDeploying(accountContract)) {\n    initCode = \"0x\";\n    if (waitForDeployment) {\n      // lock until account is deployed if needed to avoid 'sender already created' errors when sending multiple transactions in parallel\n      await waitForAccountDeployed(accountContract);\n    }\n  } else {\n    initCode = await getAccountInitCode({\n      factoryContract: factoryContract,\n      adminAddress,\n      accountSalt: overrides?.accountSalt,\n      createAccountOverride: overrides?.createAccount\n    });\n    markAccountDeploying(accountContract);\n  }\n  const partialOp = {\n    sender: accountContract.address,\n    nonce,\n    initCode,\n    callData,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    callGasLimit: callGasLimit ?? 0n,\n    verificationGasLimit: 0n,\n    preVerificationGas: 0n,\n    paymasterAndData: \"0x\",\n    signature: DUMMY_SIGNATURE\n  };\n  if (sponsorGas) {\n    const paymasterResult = await getPaymasterAndData({\n      userOp: partialOp,\n      chain,\n      client,\n      entrypointAddress: overrides?.entrypointAddress,\n      paymasterOverride: overrides?.paymaster\n    });\n    const paymasterAndData = \"paymasterAndData\" in paymasterResult ? paymasterResult.paymasterAndData : \"0x\";\n    if (paymasterAndData && paymasterAndData !== \"0x\") {\n      partialOp.paymasterAndData = paymasterAndData;\n    }\n    // paymaster can have the gas limits in the response\n    if (paymasterResult.callGasLimit && paymasterResult.verificationGasLimit && paymasterResult.preVerificationGas) {\n      partialOp.callGasLimit = paymasterResult.callGasLimit;\n      partialOp.verificationGasLimit = paymasterResult.verificationGasLimit;\n      partialOp.preVerificationGas = paymasterResult.preVerificationGas;\n    } else {\n      // otherwise fallback to bundler for gas limits\n      const estimates = await estimateUserOpGas({\n        userOp: partialOp,\n        options: bundlerOptions\n      });\n      partialOp.callGasLimit = estimates.callGasLimit;\n      partialOp.verificationGasLimit = estimates.verificationGasLimit;\n      partialOp.preVerificationGas = estimates.preVerificationGas;\n      // need paymaster to re-sign after estimates\n      if (paymasterAndData && paymasterAndData !== \"0x\") {\n        const paymasterResult2 = await getPaymasterAndData({\n          userOp: partialOp,\n          chain,\n          client,\n          entrypointAddress: overrides?.entrypointAddress,\n          paymasterOverride: overrides?.paymaster\n        });\n        const paymasterAndData2 = \"paymasterAndData\" in paymasterResult2 ? paymasterResult2.paymasterAndData : \"0x\";\n        if (paymasterAndData2 && paymasterAndData2 !== \"0x\") {\n          partialOp.paymasterAndData = paymasterAndData2;\n        }\n      }\n    }\n  } else {\n    // not gasless, so we just need to estimate gas limits\n    const estimates = await estimateUserOpGas({\n      userOp: partialOp,\n      options: bundlerOptions\n    });\n    partialOp.callGasLimit = estimates.callGasLimit;\n    partialOp.verificationGasLimit = estimates.verificationGasLimit;\n    partialOp.preVerificationGas = estimates.preVerificationGas;\n  }\n  return {\n    ...partialOp,\n    signature: \"0x\"\n  };\n}\n/**\n * Sign a user operation.\n * @param userOp - The UserOperation to sign (with signature field ignored)\n * @returns - The user operation with the signature field populated\n * @example\n * ```ts\n * import { signUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOp = await createUnsignedUserOp(...);\n *\n * const signedUserOp = await signUserOp({\n *  client,\n *  userOp,\n *  chain,\n *  adminAccount,\n * });\n * ```\n * @walletUtils\n */\nexport async function signUserOp(args) {\n  const {\n    userOp,\n    chain,\n    entrypointAddress,\n    adminAccount\n  } = args;\n  const entrypointVersion = getEntryPointVersion(entrypointAddress || ENTRYPOINT_ADDRESS_v0_6);\n  let userOpHash;\n  if (entrypointVersion === \"v0.7\") {\n    const packedUserOp = getPackedUserOperation(userOp);\n    userOpHash = await getUserOpHashV07({\n      contract: getContract({\n        address: entrypointAddress || ENTRYPOINT_ADDRESS_v0_7,\n        chain,\n        client: args.client\n      }),\n      userOp: packedUserOp\n    });\n  } else {\n    userOpHash = await getUserOpHashV06({\n      contract: getContract({\n        address: entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n        chain,\n        client: args.client\n      }),\n      userOp: userOp\n    });\n  }\n  if (adminAccount.signMessage) {\n    const signature = await adminAccount.signMessage({\n      message: {\n        raw: hexToBytes(userOpHash)\n      }\n    });\n    return {\n      ...userOp,\n      signature\n    };\n  }\n  throw new Error(\"signMessage not implemented in signingAccount\");\n}\nasync function getAccountInitCode(options) {\n  const {\n    factoryContract,\n    adminAddress,\n    accountSalt,\n    createAccountOverride\n  } = options;\n  const deployTx = prepareCreateAccount({\n    factoryContract,\n    adminAddress,\n    accountSalt,\n    createAccountOverride\n  });\n  return concat([factoryContract.address, await encode(deployTx)]);\n}\nasync function getAccountNonce(options) {\n  const {\n    accountContract,\n    chain,\n    client,\n    entrypointAddress,\n    getNonceOverride\n  } = options;\n  if (getNonceOverride) {\n    return getNonceOverride(accountContract);\n  }\n  return await getNonce({\n    contract: getContract({\n      address: entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n      chain,\n      client\n    }),\n    key: generateRandomUint192(),\n    sender: accountContract.address\n  });\n}\n/**\n * Create and sign a user operation.\n * @param options - The options for creating and signing the user operation\n * @returns - The signed user operation\n * @example\n * ```ts\n * import { createAndSignUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOp = await createAndSignUserOp({\n *  client,\n *  adminAccount,\n *  smartWalletOptions,\n *  transactions,\n * });\n * ```\n * @walletUtils\n */\nexport async function createAndSignUserOp(options) {\n  const config = options.smartWalletOptions;\n  const factoryContract = getContract({\n    address: config.factoryAddress || getDefaultAccountFactory(config.overrides?.entrypointAddress),\n    chain: config.chain,\n    client: options.client\n  });\n  const accountAddress = await predictAddress({\n    factoryContract,\n    adminAddress: options.adminAccount.address,\n    predictAddressOverride: config.overrides?.predictAddress,\n    accountSalt: config.overrides?.accountSalt,\n    accountAddress: config.overrides?.accountAddress\n  });\n  const accountContract = getContract({\n    address: accountAddress,\n    chain: config.chain,\n    client: options.client\n  });\n  let executeTx;\n  if (options.transactions.length === 1) {\n    const tx = options.transactions[0];\n    const serializedTx = await toSerializableTransaction({\n      transaction: tx,\n      from: accountAddress\n    });\n    executeTx = prepareExecute({\n      accountContract,\n      transaction: serializedTx,\n      executeOverride: config.overrides?.execute\n    });\n  } else {\n    const serializedTxs = await Promise.all(options.transactions.map(tx => toSerializableTransaction({\n      transaction: tx,\n      from: accountAddress\n    })));\n    executeTx = prepareBatchExecute({\n      accountContract,\n      transactions: serializedTxs,\n      executeBatchOverride: config.overrides?.executeBatch\n    });\n  }\n  const unsignedUserOp = await createUnsignedUserOp({\n    transaction: executeTx,\n    factoryContract,\n    accountContract,\n    adminAddress: options.adminAccount.address,\n    sponsorGas: \"sponsorGas\" in config ? config.sponsorGas : config.gasless,\n    overrides: config.overrides,\n    waitForDeployment: options.waitForDeployment\n  });\n  const signedUserOp = await signUserOp({\n    client: options.client,\n    chain: config.chain,\n    adminAccount: options.adminAccount,\n    entrypointAddress: config.overrides?.entrypointAddress,\n    userOp: unsignedUserOp\n  });\n  return signedUserOp;\n}\nasync function waitForAccountDeployed(accountContract) {\n  const startTime = Date.now();\n  while (isAccountDeploying(accountContract)) {\n    if (Date.now() - startTime > 60000) {\n      clearAccountDeploying(accountContract); // clear the flag so it doesnt stay stuck in this state\n      throw new Error(\"Account deployment is taking too long (over 1 minute). Please try again.\");\n    }\n    await new Promise(resolve => setTimeout(resolve, 500));\n  }\n}\n//# sourceMappingURL=userop.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}