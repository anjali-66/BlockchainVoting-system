{"ast":null,"code":"\"use client\";\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { getFunctionId } from \"../../../../../utils/function-id.js\";\nimport { useNFTContext } from \"./provider.js\";\nimport { getNFTInfo } from \"./utils.js\";\n/**\n * This component fetches and displays an NFT's name. It takes in a `className` and `style` props\n * so you can style it just like how you would style a <span> element.\n * @returns A <span> element containing the name of the NFT\n *\n * @example\n * ### Basic usage\n * ```tsx\n * import { NFTProvider, NFTName } from \"thirdweb/react\";\n *\n * <NFTProvider>\n *   <NFTName />\n * </NFTProvider>\n * ```\n *\n * ### Show a loading sign while the name is being fetched\n * ```tsx\n * import { NFTProvider, NFTName } from \"thirdweb/react\";\n *\n * <NFTProvider>\n *   <NFTName loadingComponent={<YourLoadingSign />} />\n * </NFTProvider>\n * ```\n *\n * ### Show something in case the name failed to resolve\n * ```tsx\n * import { NFTProvider, NFTName } from \"thirdweb/react\";\n *\n * <NFTProvider>\n *   <NFTName fallbackComponent={<span>Failed to load name</span>} />\n * </NFTProvider>\n * ```\n *\n * ### Custom query options for useQuery (tanstack-query)\n * ```tsx\n * import { NFTProvider, NFTName } from \"thirdweb/react\";\n *\n * <NFTProvider>\n *   <NFTName queryOptions={{ retry: 3, enabled: false, }} />\n * </NFTProvider>\n * ```\n *\n * ### Override the name with the `nameResolver` prop\n * If you already have the name, you can skip the network requests and pass it directly to the NFTName\n * ```tsx\n * <NFTName nameResolver=\"Doodles #1\" />\n * ```\n *\n * You can also pass in your own custom (async) function that retrieves the name\n * ```tsx\n * const getName = async () => {\n *   // ...\n *   return name;\n * };\n *\n * <NFTName nameResolver={getName} />\n * ```\n *\n * @nft\n * @component\n * @beta\n */\nexport function NFTName({\n  loadingComponent,\n  fallbackComponent,\n  queryOptions,\n  nameResolver,\n  ...restProps\n}) {\n  const {\n    contract,\n    tokenId\n  } = useNFTContext();\n  const nameQuery = useQuery({\n    queryKey: [\"_internal_nft_name_\", contract.chain.id, tokenId.toString(), {\n      resolver: typeof nameResolver === \"string\" ? nameResolver : typeof nameResolver === \"function\" ? getFunctionId(nameResolver) : undefined\n    }],\n    queryFn: async () => fetchNftName({\n      nameResolver,\n      contract,\n      tokenId\n    }),\n    ...queryOptions\n  });\n  if (nameQuery.isLoading) {\n    return loadingComponent || null;\n  }\n  if (!nameQuery.data) {\n    return fallbackComponent || null;\n  }\n  return _jsx(\"span\", {\n    ...restProps,\n    children: nameQuery.data\n  });\n}\n/**\n * @internal Exported for tests\n */\nexport async function fetchNftName(props) {\n  const {\n    nameResolver,\n    contract,\n    tokenId\n  } = props;\n  if (typeof nameResolver === \"string\") {\n    return nameResolver;\n  }\n  if (typeof nameResolver === \"function\") {\n    return nameResolver();\n  }\n  const nft = await getNFTInfo({\n    contract,\n    tokenId\n  }).catch(() => undefined);\n  if (!nft) {\n    throw new Error(\"Failed to resolve NFT info\");\n  }\n  if (typeof nft.metadata.name !== \"string\") {\n    throw new Error(\"Failed to resolve NFT name\");\n  }\n  return nft.metadata.name;\n}\n//# sourceMappingURL=name.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}