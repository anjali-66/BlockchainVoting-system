{"ast":null,"code":"import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { useQueryClient } from \"@tanstack/react-query\";\nimport { useCallback, useMemo, useState } from \"react\";\nimport { NATIVE_TOKEN_ADDRESS } from \"../../../../../../constants/addresses.js\";\nimport { isSwapRequiredPostOnramp } from \"../../../../../../pay/buyWithFiat/isSwapRequiredPostOnramp.js\";\nimport { formatNumber } from \"../../../../../../utils/formatNumber.js\";\nimport { spacing } from \"../../../../../core/design-system/index.js\";\nimport { useWalletBalance } from \"../../../../../core/hooks/others/useWalletBalance.js\";\nimport { useBuyWithCryptoQuote } from \"../../../../../core/hooks/pay/useBuyWithCryptoQuote.js\";\nimport { useBuyWithFiatQuote } from \"../../../../../core/hooks/pay/useBuyWithFiatQuote.js\";\nimport { useActiveAccount } from \"../../../../../core/hooks/wallets/useActiveAccount.js\";\nimport { invalidateWalletBalance } from \"../../../../../core/providers/invalidateWalletBalance.js\";\nimport { ErrorState } from \"../../../../wallets/shared/ErrorState.js\";\nimport { LoadingScreen } from \"../../../../wallets/shared/LoadingScreen.js\";\nimport { ChainName } from \"../../../components/ChainName.js\";\nimport { Drawer, DrawerOverlay, useDrawer } from \"../../../components/Drawer.js\";\nimport { Spacer } from \"../../../components/Spacer.js\";\nimport { Spinner } from \"../../../components/Spinner.js\";\nimport { SwitchNetworkButton } from \"../../../components/SwitchNetwork.js\";\nimport { Container, Line, ModalHeader } from \"../../../components/basic.js\";\nimport { Button } from \"../../../components/buttons.js\";\nimport { Text } from \"../../../components/text.js\";\nimport { TokenSymbol } from \"../../../components/token/TokenSymbol.js\";\nimport { ConnectButton } from \"../../ConnectButton.js\";\nimport { ChainButton, NetworkSelectorContent } from \"../../NetworkSelector.js\";\nimport { TokenSelector } from \"../TokenSelector.js\";\nimport { WalletSwitcherConnectionScreen } from \"../WalletSwitcherConnectionScreen.js\";\nimport { isNativeToken } from \"../nativeToken.js\";\nimport { DirectPaymentModeScreen } from \"./DirectPaymentModeScreen.js\";\nimport { EstimatedTimeAndFees } from \"./EstimatedTimeAndFees.js\";\nimport { PayTokenIcon } from \"./PayTokenIcon.js\";\nimport { PayWithCreditCard } from \"./PayWIthCreditCard.js\";\nimport { TransactionModeScreen } from \"./TransactionModeScreen.js\";\nimport { CurrencySelection } from \"./fiat/CurrencySelection.js\";\nimport { FiatFlow } from \"./fiat/FiatFlow.js\";\nimport { useEnabledPaymentMethods } from \"./main/useEnabledPaymentMethods.js\";\nimport { useFiatCurrencySelectionStates, useFromTokenSelectionStates, useToTokenSelectionStates } from \"./main/useUISelectionStates.js\";\nimport { openOnrampPopup } from \"./openOnRamppopup.js\";\nimport { BuyTokenInput } from \"./swap/BuyTokenInput.js\";\nimport { FiatFees, SwapFees } from \"./swap/Fees.js\";\nimport { PayWithCryptoQuoteInfo } from \"./swap/PayWithCrypto.js\";\nimport { PaymentSelectionScreen } from \"./swap/PaymentSelectionScreen.js\";\nimport { SwapFlow } from \"./swap/SwapFlow.js\";\nimport { TransferFlow } from \"./swap/TransferFlow.js\";\nimport { addPendingTx } from \"./swap/pendingSwapTx.js\";\nimport { useBuySupportedDestinations, useBuySupportedSources } from \"./swap/useSwapSupportedChains.js\";\nimport { usePayerSetup } from \"./usePayerSetup.js\";\n/**\n * @internal\n */\nexport default function BuyScreen(props) {\n  const isTestMode = props.payOptions.buyWithCrypto ? props.payOptions.buyWithCrypto.testMode : undefined;\n  const supportedDestinationsQuery = useBuySupportedDestinations(props.client, isTestMode);\n  if (supportedDestinationsQuery.isError) {\n    return _jsx(Container, {\n      style: {\n        minHeight: \"350px\"\n      },\n      fullHeight: true,\n      flex: \"row\",\n      center: \"both\",\n      children: _jsx(ErrorState, {\n        title: \"Something went wrong\",\n        onTryAgain: supportedDestinationsQuery.refetch\n      })\n    });\n  }\n  if (!supportedDestinationsQuery.data) {\n    return _jsx(LoadingScreen, {});\n  }\n  return _jsx(BuyScreenContent, {\n    ...props,\n    supportedDestinations: supportedDestinationsQuery.data\n  });\n}\n/**\n * @internal\n */\nfunction BuyScreenContent(props) {\n  const {\n    client,\n    supportedDestinations,\n    connectLocale,\n    payOptions\n  } = props;\n  const activeAccount = useActiveAccount();\n  const {\n    payer,\n    setPayer\n  } = usePayerSetup();\n  const [screen, setScreen] = useState({\n    id: \"main\"\n  });\n  const {\n    tokenAmount,\n    setTokenAmount,\n    toChain,\n    setToChain,\n    deferredTokenAmount,\n    toToken,\n    setToToken\n  } = useToTokenSelectionStates({\n    payOptions,\n    supportedDestinations\n  });\n  const [hasEditedAmount, setHasEditedAmount] = useState(false);\n  const onDone = useCallback(() => {\n    setScreen({\n      id: \"main\"\n    });\n    props.onDone();\n  }, [props.onDone]);\n  // check if the screen is expanded or not\n  // update supportedSources whenever toToken or toChain is updated\n  const supportedSourcesQuery = useBuySupportedSources({\n    client: props.client,\n    destinationChainId: toChain.id,\n    destinationTokenAddress: isNativeToken(toToken) ? NATIVE_TOKEN_ADDRESS : toToken.address\n  });\n  const destinationSupportedTokens = useMemo(() => {\n    return createSupportedTokens(supportedDestinations, payOptions, props.supportedTokens);\n  }, [props.supportedTokens, supportedDestinations, payOptions]);\n  const sourceSupportedTokens = useMemo(() => {\n    if (!supportedSourcesQuery.data) {\n      return undefined;\n    }\n    const supportedSources = supportedSourcesQuery.data;\n    return createSupportedTokens(supportedSources, payOptions, props.supportedTokens);\n  }, [props.supportedTokens, supportedSourcesQuery.data, payOptions]);\n  const {\n    fromChain,\n    setFromChain,\n    fromToken,\n    setFromToken\n  } = useFromTokenSelectionStates({\n    payOptions,\n    supportedSources: supportedSourcesQuery.data || []\n  });\n  const {\n    selectedCurrency,\n    setSelectedCurrency\n  } = useFiatCurrencySelectionStates({\n    payOptions\n  });\n  const enabledPaymentMethods = useEnabledPaymentMethods({\n    payOptions: props.payOptions,\n    supportedDestinations: props.supportedDestinations,\n    toChain: toChain,\n    toToken: toToken\n  });\n  const payDisabled = enabledPaymentMethods.buyWithCryptoEnabled === false && enabledPaymentMethods.buyWithFiatEnabled === false;\n  // screens ----------------------------\n  const queryClient = useQueryClient();\n  const onSwapSuccess = useCallback(_status => {\n    props.payOptions.onPurchaseSuccess?.({\n      type: \"crypto\",\n      status: _status\n    });\n    invalidateWalletBalance(queryClient);\n  }, [props.payOptions.onPurchaseSuccess, queryClient]);\n  const onFiatSuccess = useCallback(_status => {\n    props.payOptions.onPurchaseSuccess?.({\n      type: \"fiat\",\n      status: _status\n    });\n    invalidateWalletBalance(queryClient);\n  }, [props.payOptions.onPurchaseSuccess, queryClient]);\n  if (screen.id === \"connect-payer-wallet\") {\n    return _jsx(WalletSwitcherConnectionScreen, {\n      accountAbstraction: props.connectOptions?.accountAbstraction,\n      appMetadata: props.connectOptions?.appMetadata,\n      chain: props.connectOptions?.chain,\n      chains: props.connectOptions?.chains,\n      client: props.client,\n      connectLocale: props.connectLocale,\n      isEmbed: props.isEmbed,\n      onBack: () => setScreen(screen.backScreen),\n      onSelect: w => {\n        const account = w.getAccount();\n        const chain = w.getChain();\n        if (w && account && chain) {\n          setPayer({\n            account,\n            chain,\n            wallet: w\n          });\n        }\n      },\n      hiddenWallets: props.hiddenWallets,\n      recommendedWallets: props.connectOptions?.recommendedWallets,\n      showAllWallets: props.connectOptions?.showAllWallets === undefined ? true : props.connectOptions?.showAllWallets,\n      walletConnect: props.connectOptions?.walletConnect,\n      wallets: props.connectOptions?.wallets?.filter(w => w.id !== \"inApp\")\n    });\n  }\n  if (screen.id === \"swap-flow\" && payer) {\n    return _jsx(SwapFlow, {\n      title: props.title,\n      transactionMode: payOptions.mode === \"transaction\",\n      isEmbed: props.isEmbed,\n      client: client,\n      onBack: () => {\n        setScreen({\n          id: \"buy-with-crypto\"\n        });\n      },\n      buyWithCryptoQuote: screen.quote,\n      payer: payer,\n      isFiatFlow: false,\n      onDone: onDone,\n      onTryAgain: () => {\n        setScreen({\n          id: \"buy-with-crypto\"\n        });\n      },\n      onSuccess: onSwapSuccess\n    });\n  }\n  if (screen.id === \"fiat-flow\" && payer) {\n    return _jsx(FiatFlow, {\n      title: props.title,\n      transactionMode: payOptions.mode === \"transaction\",\n      quote: screen.quote,\n      onBack: () => {\n        setScreen({\n          id: \"buy-with-fiat\"\n        });\n      },\n      client: client,\n      testMode: props.payOptions.buyWithFiat !== false && props.payOptions.buyWithFiat?.testMode === true,\n      theme: typeof props.theme === \"string\" ? props.theme : props.theme.type,\n      openedWindow: screen.openedWindow,\n      onDone: onDone,\n      isEmbed: props.isEmbed,\n      payer: payer,\n      onSuccess: onFiatSuccess\n    });\n  }\n  if (screen.id === \"transfer-flow\" && payer && activeAccount) {\n    const goBack = () => setScreen({\n      id: \"buy-with-crypto\"\n    });\n    // TODO (pay) pass it via screen props\n    const defaultRecipientAddress = props.payOptions?.paymentInfo?.sellerAddress;\n    const receiverAddress = defaultRecipientAddress || activeAccount.address;\n    return _jsx(TransferFlow, {\n      title: props.title,\n      onBack: goBack,\n      payer: payer,\n      client: props.client,\n      chain: toChain,\n      token: toToken,\n      tokenAmount: tokenAmount,\n      receiverAddress: receiverAddress,\n      transactionMode: props.payOptions.mode === \"transaction\",\n      payOptions: payOptions,\n      isEmbed: props.isEmbed,\n      onDone: onDone,\n      onTryAgain: () => {\n        setScreen({\n          id: \"buy-with-crypto\"\n        });\n      },\n      onSuccess: onSwapSuccess\n    });\n  }\n  if (screen.id === \"select-currency\") {\n    const goBack = () => setScreen(screen.backScreen);\n    return _jsx(CurrencySelection, {\n      onSelect: currency => {\n        goBack();\n        setSelectedCurrency(currency);\n      },\n      onBack: goBack\n    });\n  }\n  if (screen.id === \"select-to-token\") {\n    const chains = supportedDestinations.map(x => x.chain);\n    const goBack = () => setScreen(screen.backScreen);\n    const allowEdits = payOptions?.prefillBuy?.allowEdits;\n    // if token selection is disabled - only show network selector screen\n    if (allowEdits?.token === false) {\n      return _jsx(ChainSelectionScreen, {\n        chains: chains,\n        client: props.client,\n        connectLocale: props.connectLocale,\n        setChain: setToChain,\n        goBack: goBack\n      });\n    }\n    return _jsx(TokenSelector, {\n      onBack: goBack,\n      tokenList: ((toChain?.id ? destinationSupportedTokens[toChain.id] : undefined) || []).filter(x => x.address !== NATIVE_TOKEN_ADDRESS),\n      onTokenSelect: tokenInfo => {\n        setToToken(tokenInfo);\n        goBack();\n      },\n      chain: toChain,\n      chainSelection:\n      // hide chain selection if it's disabled\n      allowEdits?.chain !== false ? {\n        chains: chains,\n        select: c => {\n          setToChain(c);\n        }\n      } : undefined,\n      connectLocale: connectLocale,\n      client: client,\n      modalTitle: props.title\n    });\n  }\n  if (screen.id === \"select-from-token\" && supportedSourcesQuery.data && sourceSupportedTokens) {\n    const chains = supportedSourcesQuery.data.map(x => x.chain);\n    const goBack = () => setScreen(screen.backScreen);\n    // if token selection is disabled - only show network selector screen\n    if (payOptions.buyWithCrypto !== false && payOptions.buyWithCrypto?.prefillSource?.allowEdits?.token === false) {\n      return _jsx(ChainSelectionScreen, {\n        chains: chains,\n        client: props.client,\n        connectLocale: props.connectLocale,\n        setChain: setFromChain,\n        goBack: goBack\n      });\n    }\n    return _jsx(TokenSelector, {\n      onBack: goBack,\n      tokenList: ((fromChain?.id ? sourceSupportedTokens[fromChain.id] : undefined) || []).filter(x => x.address !== NATIVE_TOKEN_ADDRESS),\n      onTokenSelect: tokenInfo => {\n        setFromToken(tokenInfo);\n        goBack();\n      },\n      chain: fromChain,\n      chainSelection:\n      // hide chain selection if it's disabled\n      payOptions.buyWithCrypto !== false && payOptions.buyWithCrypto?.prefillSource?.allowEdits?.chain !== false ? {\n        chains: supportedSourcesQuery.data.map(x => x.chain),\n        select: c => setFromChain(c)\n      } : undefined,\n      connectLocale: connectLocale,\n      client: client,\n      modalTitle: \"Pay with\"\n    });\n  }\n  return _jsx(Container, {\n    animate: \"fadein\",\n    children: _jsxs(\"div\", {\n      children: [screen.id === \"main\" && _jsx(MainScreen, {\n        title: props.title,\n        payerAccount: payer?.account,\n        client: client,\n        onSelectBuyToken: () => setScreen({\n          id: \"select-to-token\",\n          backScreen: screen\n        }),\n        payOptions: payOptions,\n        setTokenAmount: setTokenAmount,\n        setToChain: setToChain,\n        setToToken: setToToken,\n        setFromChain: setFromChain,\n        setFromToken: setFromToken,\n        toChain: toChain,\n        toToken: toToken,\n        tokenAmount: tokenAmount,\n        connectOptions: props.connectOptions,\n        setScreen: setScreen,\n        supportedDestinations: supportedDestinations,\n        onBack: props.onBack,\n        theme: props.theme,\n        hasEditedAmount: hasEditedAmount,\n        setHasEditedAmount: setHasEditedAmount,\n        enabledPaymentMethods: enabledPaymentMethods\n      }), (screen.id === \"select-payment-method\" || screen.id === \"buy-with-crypto\" || screen.id === \"buy-with-fiat\") && payer && _jsxs(TokenSelectedLayout, {\n        title: props.title,\n        selectedChain: toChain,\n        selectedToken: toToken,\n        tokenAmount: tokenAmount,\n        client: client,\n        onBack: () => {\n          if (enabledPaymentMethods.buyWithCryptoEnabled && screen.id === \"buy-with-fiat\") {\n            setScreen({\n              id: \"select-payment-method\"\n            });\n          } else if (screen.id === \"buy-with-crypto\") {\n            setScreen({\n              id: \"select-payment-method\"\n            });\n          } else {\n            setScreen({\n              id: \"main\"\n            });\n          }\n        },\n        children: [screen.id === \"select-payment-method\" && _jsx(PaymentSelectionScreen, {\n          client: client,\n          mode: payOptions.mode,\n          sourceSupportedTokens: sourceSupportedTokens,\n          hiddenWallets: props.hiddenWallets,\n          payWithFiatEnabled: props.payOptions.buyWithFiat !== false,\n          toChain: toChain,\n          toToken: toToken,\n          tokenAmount: tokenAmount,\n          onSelect: (w, token, chain) => {\n            const account = w.getAccount();\n            if (account) {\n              setPayer({\n                account,\n                chain,\n                wallet: w\n              });\n              setFromToken(token);\n              setFromChain(chain);\n              setScreen({\n                id: \"buy-with-crypto\"\n              });\n            }\n          },\n          onSelectFiat: () => {\n            setScreen({\n              id: \"buy-with-fiat\"\n            });\n          },\n          showAllWallets: !!props.connectOptions?.showAllWallets,\n          wallets: props.connectOptions?.wallets,\n          onBack: () => {\n            // no-op\n          },\n          onConnect: () => {\n            setScreen({\n              id: \"connect-payer-wallet\",\n              backScreen: {\n                id: \"select-payment-method\"\n              }\n            });\n          }\n        }), screen.id === \"buy-with-crypto\" && activeAccount && _jsx(SwapScreenContent, {\n          setScreen: setScreen,\n          tokenAmount: deferredTokenAmount,\n          toChain: toChain,\n          toToken: toToken,\n          fromChain: fromChain,\n          fromToken: fromToken,\n          showFromTokenSelector: () => {\n            setScreen({\n              id: \"select-from-token\",\n              backScreen: screen\n            });\n          },\n          payer: payer,\n          client: client,\n          isEmbed: props.isEmbed,\n          onDone: onDone,\n          payOptions: payOptions,\n          connectLocale: connectLocale,\n          connectOptions: props.connectOptions,\n          setPayer: setPayer,\n          // pass it even though we are passing payer, because payer might be different\n          activeAccount: activeAccount,\n          setTokenAmount: setTokenAmount,\n          setHasEditedAmount: setHasEditedAmount,\n          disableTokenSelection: payDisabled === true || payOptions.buyWithCrypto !== false && payOptions.buyWithCrypto?.prefillSource?.allowEdits?.chain === false && payOptions.buyWithCrypto?.prefillSource?.allowEdits?.token === false\n        }), screen.id === \"buy-with-fiat\" && _jsx(FiatScreenContent, {\n          setScreen: setScreen,\n          tokenAmount: deferredTokenAmount,\n          toChain: toChain,\n          toToken: toToken,\n          selectedCurrency: selectedCurrency,\n          client: client,\n          isEmbed: props.isEmbed,\n          onDone: onDone,\n          payOptions: payOptions,\n          theme: props.theme,\n          showCurrencySelector: () => {\n            setScreen({\n              id: \"select-currency\",\n              backScreen: screen\n            });\n          },\n          payer: payer,\n          setTokenAmount: setTokenAmount,\n          setHasEditedAmount: setHasEditedAmount\n        })]\n      })]\n    })\n  });\n}\nfunction SelectedTokenInfo(props) {\n  return _jsx(\"div\", {\n    children: _jsxs(Container, {\n      flex: \"row\",\n      gap: \"sm\",\n      center: \"y\",\n      style: {\n        justifyContent: \"space-between\"\n      },\n      children: [_jsxs(Container, {\n        flex: \"row\",\n        gap: \"xs\",\n        center: \"y\",\n        children: [_jsx(Text, {\n          color: \"primaryText\",\n          \"data-testid\": \"tokenAmount\",\n          size: \"xl\",\n          children: formatNumber(Number(props.tokenAmount), 6)\n        }), _jsxs(Container, {\n          flex: \"row\",\n          gap: \"xxs\",\n          center: \"y\",\n          children: [_jsx(TokenSymbol, {\n            token: props.selectedToken,\n            chain: props.selectedChain,\n            size: \"md\",\n            color: \"secondaryText\"\n          }), _jsx(PayTokenIcon, {\n            chain: props.selectedChain,\n            client: props.client,\n            size: \"sm\",\n            token: props.selectedToken\n          })]\n        })]\n      }), _jsx(ChainName, {\n        chain: props.selectedChain,\n        client: props.client,\n        size: \"sm\",\n        short: true\n      })]\n    })\n  });\n}\nfunction MainScreen(props) {\n  const {\n    setTokenAmount,\n    setToChain,\n    setToToken,\n    setFromChain,\n    setFromToken,\n    payerAccount,\n    client,\n    tokenAmount,\n    payOptions,\n    toToken,\n    toChain,\n    supportedDestinations,\n    enabledPaymentMethods\n  } = props;\n  const {\n    buyWithCryptoEnabled,\n    buyWithFiatEnabled\n  } = enabledPaymentMethods;\n  const disableContinue = !tokenAmount;\n  switch (payOptions.mode) {\n    case \"transaction\":\n      {\n        return _jsx(TransactionModeScreen, {\n          supportedDestinations: supportedDestinations,\n          payUiOptions: payOptions,\n          payerAccount: payerAccount,\n          connectOptions: props.connectOptions,\n          client: client,\n          onContinue: (tokenAmount, toChain, toToken) => {\n            setTokenAmount(tokenAmount);\n            setToChain(toChain);\n            setFromChain(toChain);\n            setFromToken(toToken);\n            setToToken(toToken);\n            if (buyWithFiatEnabled && !buyWithCryptoEnabled) {\n              props.setScreen({\n                id: \"buy-with-fiat\"\n              });\n            } else {\n              props.setScreen({\n                id: \"select-payment-method\"\n              });\n            }\n          }\n        });\n      }\n    case \"direct_payment\":\n      {\n        return _jsx(DirectPaymentModeScreen, {\n          client: client,\n          payUiOptions: payOptions,\n          payerAccount: payerAccount,\n          connectOptions: props.connectOptions,\n          supportedDestinations: supportedDestinations,\n          onContinue: (tokenAmount, toChain, toToken) => {\n            setTokenAmount(tokenAmount);\n            setToChain(toChain);\n            setFromChain(toChain);\n            setFromToken(toToken);\n            setToToken(toToken);\n            if (buyWithFiatEnabled && !buyWithCryptoEnabled) {\n              props.setScreen({\n                id: \"buy-with-fiat\"\n              });\n            } else {\n              props.setScreen({\n                id: \"select-payment-method\"\n              });\n            }\n          }\n        });\n      }\n    default:\n      {\n        return _jsxs(Container, {\n          p: \"lg\",\n          children: [_jsx(ModalHeader, {\n            title: props.title,\n            onBack: props.onBack\n          }), _jsx(Spacer, {\n            y: \"xl\"\n          }), _jsx(BuyTokenInput, {\n            value: tokenAmount,\n            onChange: async value => {\n              props.setHasEditedAmount(true);\n              setTokenAmount(value);\n            },\n            freezeAmount: payOptions.prefillBuy?.allowEdits?.amount === false,\n            freezeChainAndToken: payOptions.prefillBuy?.allowEdits?.chain === false && payOptions.prefillBuy?.allowEdits?.token === false,\n            token: toToken,\n            chain: toChain,\n            onSelectToken: props.onSelectBuyToken,\n            client: props.client\n          }), _jsx(Spacer, {\n            y: \"xl\"\n          }), _jsx(Container, {\n            flex: \"column\",\n            gap: \"sm\",\n            children: !payerAccount ? _jsx(\"div\", {\n              children: _jsx(ConnectButton, {\n                ...props.connectOptions,\n                client: props.client,\n                theme: props.theme,\n                connectButton: {\n                  style: {\n                    width: \"100%\"\n                  }\n                }\n              })\n            }) : _jsx(Button, {\n              variant: \"accent\",\n              fullWidth: true,\n              disabled: disableContinue,\n              \"data-disabled\": disableContinue,\n              onClick: () => {\n                if (buyWithFiatEnabled && !buyWithCryptoEnabled) {\n                  props.setScreen({\n                    id: \"buy-with-fiat\"\n                  });\n                } else {\n                  props.setScreen({\n                    id: \"select-payment-method\"\n                  });\n                }\n              },\n              children: \"Continue\"\n            })\n          })]\n        });\n      }\n  }\n}\nfunction TokenSelectedLayout(props) {\n  return _jsxs(Container, {\n    children: [_jsx(Container, {\n      p: \"lg\",\n      children: _jsx(ModalHeader, {\n        title: props.title,\n        onBack: props.onBack\n      })\n    }), _jsxs(Container, {\n      px: \"lg\",\n      style: {\n        paddingBottom: spacing.lg\n      },\n      children: [_jsx(Spacer, {\n        y: \"xs\"\n      }), _jsx(SelectedTokenInfo, {\n        selectedToken: props.selectedToken,\n        selectedChain: props.selectedChain,\n        tokenAmount: props.tokenAmount,\n        client: props.client\n      }), _jsx(Spacer, {\n        y: \"md\"\n      }), _jsx(Line, {}), _jsx(Spacer, {\n        y: \"lg\"\n      }), _jsx(Text, {\n        size: \"sm\",\n        children: \" Pay with \"\n      }), _jsx(Spacer, {\n        y: \"sm\"\n      }), props.children]\n    })]\n  });\n}\nfunction SwapScreenContent(props) {\n  const {\n    setScreen,\n    payer,\n    client,\n    toChain,\n    tokenAmount,\n    toToken,\n    fromChain,\n    fromToken,\n    payOptions,\n    disableTokenSelection\n  } = props;\n  const defaultRecipientAddress = props.payOptions?.paymentInfo?.sellerAddress;\n  const receiverAddress = defaultRecipientAddress || props.activeAccount.address;\n  const {\n    drawerRef,\n    drawerOverlayRef,\n    isOpen,\n    setIsOpen\n  } = useDrawer();\n  const [drawerScreen, setDrawerScreen] = useState(\"fees\");\n  const fromTokenBalanceQuery = useWalletBalance({\n    address: payer.account.address,\n    chain: fromChain,\n    tokenAddress: isNativeToken(fromToken) ? undefined : fromToken.address,\n    client\n  });\n  const fromTokenId = isNativeToken(fromToken) ? NATIVE_TOKEN_ADDRESS : fromToken.address.toLowerCase();\n  const toTokenId = isNativeToken(toToken) ? NATIVE_TOKEN_ADDRESS : toToken.address.toLowerCase();\n  const swapRequired = !!tokenAmount && !(fromChain.id === toChain.id && fromTokenId === toTokenId);\n  const quoteParams = swapRequired ? {\n    // wallets\n    fromAddress: payer.account.address,\n    toAddress: receiverAddress,\n    // from\n    fromChainId: fromChain.id,\n    fromTokenAddress: isNativeToken(fromToken) ? NATIVE_TOKEN_ADDRESS : fromToken.address,\n    // to\n    toChainId: toChain.id,\n    toTokenAddress: isNativeToken(toToken) ? NATIVE_TOKEN_ADDRESS : toToken.address,\n    toAmount: tokenAmount,\n    client,\n    purchaseData: payOptions.purchaseData\n  } : undefined;\n  const quoteQuery = useBuyWithCryptoQuote(quoteParams, {\n    // refetch every 30 seconds\n    staleTime: 30 * 1000,\n    refetchInterval: 30 * 1000,\n    gcTime: 30 * 1000\n  });\n  const sourceTokenAmount = swapRequired ? quoteQuery.data?.swapDetails.fromAmount : tokenAmount;\n  const isNotEnoughBalance = !!sourceTokenAmount && !!fromTokenBalanceQuery.data && Number(fromTokenBalanceQuery.data.displayValue) < Number(sourceTokenAmount);\n  const disableContinue = swapRequired && !quoteQuery.data || isNotEnoughBalance;\n  const switchChainRequired = props.payer.wallet.getChain()?.id !== fromChain.id;\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  function getErrorMessage(err) {\n    const defaultMessage = \"Unable to get price quote\";\n    try {\n      if (err.error.code === \"MINIMUM_PURCHASE_AMOUNT\") {\n        const obj = err.error;\n        const minAmountToken = obj.data.minimumAmountEth;\n        return {\n          minAmount: formatNumber(Number(minAmountToken), 6)\n        };\n      }\n    } catch {}\n    return {\n      msg: [defaultMessage]\n    };\n  }\n  const errorMsg = !quoteQuery.isLoading && quoteQuery.error ? getErrorMessage(quoteQuery.error) : undefined;\n  function showSwapFlow() {\n    if ((props.payOptions.mode === \"direct_payment\" || props.payOptions.mode === \"fund_wallet\") && !isNotEnoughBalance && !swapRequired) {\n      // same currency, just direct transfer\n      setScreen({\n        id: \"transfer-flow\"\n      });\n    } else if (props.payOptions.mode === \"transaction\" && !isNotEnoughBalance && !swapRequired) {\n      if (payer.account.address !== receiverAddress) {\n        // needs transfer from another wallet before executing the transaction\n        setScreen({\n          id: \"transfer-flow\"\n        });\n      } else {\n        // has enough balance to just do the transaction directly\n        props.onDone();\n      }\n      return;\n    }\n    if (!quoteQuery.data) {\n      return;\n    }\n    setScreen({\n      id: \"swap-flow\",\n      quote: quoteQuery.data\n    });\n  }\n  function showFees() {\n    if (!quoteQuery.data) {\n      return;\n    }\n    setIsOpen(true);\n    setDrawerScreen(\"fees\");\n  }\n  return _jsxs(Container, {\n    flex: \"column\",\n    gap: \"md\",\n    animate: \"fadein\",\n    children: [isOpen && _jsxs(_Fragment, {\n      children: [_jsx(DrawerOverlay, {\n        ref: drawerOverlayRef\n      }), _jsx(Drawer, {\n        ref: drawerRef,\n        close: () => setIsOpen(false),\n        children: drawerScreen === \"fees\" && quoteQuery.data && _jsxs(\"div\", {\n          children: [_jsx(Text, {\n            size: \"lg\",\n            color: \"primaryText\",\n            children: \"Fees\"\n          }), _jsx(Spacer, {\n            y: \"lg\"\n          }), _jsx(SwapFees, {\n            quote: quoteQuery.data\n          })]\n        })\n      })]\n    }), _jsxs(\"div\", {\n      children: [_jsx(PayWithCryptoQuoteInfo, {\n        value: sourceTokenAmount || \"\",\n        chain: fromChain,\n        token: fromToken,\n        isLoading: quoteQuery.isLoading && !sourceTokenAmount,\n        client: client,\n        freezeChainAndTokenSelection: disableTokenSelection,\n        payerAccount: props.payer.account,\n        swapRequired: swapRequired\n      }), swapRequired && _jsx(EstimatedTimeAndFees, {\n        quoteIsLoading: quoteQuery.isLoading,\n        estimatedSeconds: quoteQuery.data?.swapDetails.estimated.durationSeconds,\n        onViewFees: showFees\n      }), _jsx(Spacer, {\n        y: \"md\"\n      })]\n    }), errorMsg && _jsxs(\"div\", {\n      children: [errorMsg.minAmount && _jsxs(Text, {\n        color: \"danger\",\n        size: \"sm\",\n        center: true,\n        multiline: true,\n        children: [\"Minimum amount is \", errorMsg.minAmount, \" \", _jsx(TokenSymbol, {\n          token: toToken,\n          chain: toChain,\n          size: \"sm\",\n          inline: true,\n          color: \"danger\"\n        })]\n      }), errorMsg.msg?.map(msg => _jsx(Text, {\n        color: \"danger\",\n        size: \"sm\",\n        center: true,\n        multiline: true,\n        children: msg\n      }, msg))]\n    }), !errorMsg && isNotEnoughBalance && _jsxs(\"div\", {\n      children: [_jsx(Text, {\n        color: \"danger\",\n        size: \"sm\",\n        center: true,\n        multiline: true,\n        children: \"Not enough funds.\"\n      }), _jsx(Text, {\n        color: \"danger\",\n        size: \"sm\",\n        center: true,\n        multiline: true,\n        children: \"Try a different wallet or token.\"\n      })]\n    }), errorMsg?.minAmount ? _jsx(Button, {\n      variant: \"accent\",\n      fullWidth: true,\n      onClick: () => {\n        props.setTokenAmount(String(errorMsg.minAmount));\n        props.setHasEditedAmount(true);\n      },\n      children: \"Set Minimum\"\n    }) : switchChainRequired && !quoteQuery.isLoading && !isNotEnoughBalance && !quoteQuery.error ? _jsx(SwitchNetworkButton, {\n      variant: \"accent\",\n      fullWidth: true,\n      switchChain: async () => {\n        await props.payer.wallet.switchChain(fromChain);\n      }\n    }) : _jsx(Button, {\n      variant: disableContinue ? \"outline\" : \"accent\",\n      fullWidth: true,\n      \"data-disabled\": disableContinue,\n      disabled: disableContinue,\n      onClick: async () => {\n        if (!disableContinue) {\n          showSwapFlow();\n        }\n      },\n      gap: \"xs\",\n      children: quoteQuery.isLoading ? _jsxs(_Fragment, {\n        children: [\"Getting price quote\", _jsx(Spinner, {\n          size: \"sm\",\n          color: \"accentText\"\n        })]\n      }) : \"Continue\"\n    })]\n  });\n}\nfunction FiatScreenContent(props) {\n  const {\n    toToken,\n    tokenAmount,\n    payer,\n    client,\n    setScreen,\n    toChain,\n    showCurrencySelector,\n    selectedCurrency\n  } = props;\n  const defaultRecipientAddress = props.payOptions?.paymentInfo?.sellerAddress;\n  const receiverAddress = defaultRecipientAddress || props.payer.account.address;\n  const {\n    drawerRef,\n    drawerOverlayRef,\n    isOpen,\n    setIsOpen\n  } = useDrawer();\n  const [drawerScreen, setDrawerScreen] = useState(\"fees\");\n  const buyWithFiatOptions = props.payOptions.buyWithFiat;\n  const fiatQuoteQuery = useBuyWithFiatQuote(buyWithFiatOptions !== false && tokenAmount ? {\n    fromCurrencySymbol: selectedCurrency.shorthand,\n    toChainId: toChain.id,\n    toAddress: receiverAddress,\n    toTokenAddress: isNativeToken(toToken) ? NATIVE_TOKEN_ADDRESS : toToken.address,\n    toAmount: tokenAmount,\n    client,\n    isTestMode: buyWithFiatOptions?.testMode,\n    purchaseData: props.payOptions.purchaseData,\n    fromAddress: payer.account.address,\n    preferredProvider: buyWithFiatOptions?.preferredProvider\n  } : undefined);\n  function handleSubmit() {\n    if (!fiatQuoteQuery.data) {\n      return;\n    }\n    const hasTwoSteps = isSwapRequiredPostOnramp(fiatQuoteQuery.data);\n    let openedWindow = null;\n    if (!hasTwoSteps) {\n      openedWindow = openOnrampPopup(fiatQuoteQuery.data.onRampLink, typeof props.theme === \"string\" ? props.theme : props.theme.type);\n      addPendingTx({\n        type: \"fiat\",\n        intentId: fiatQuoteQuery.data.intentId\n      });\n    }\n    setScreen({\n      id: \"fiat-flow\",\n      quote: fiatQuoteQuery.data,\n      openedWindow\n    });\n  }\n  function showFees() {\n    if (!fiatQuoteQuery.data) {\n      return;\n    }\n    setDrawerScreen(\"fees\");\n    setIsOpen(true);\n  }\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  function getErrorMessage(err) {\n    const defaultMessage = \"Unable to get price quote\";\n    try {\n      if (err.error.code === \"MINIMUM_PURCHASE_AMOUNT\") {\n        const obj = err.error;\n        const minAmountToken = obj.data.minimumAmountEth;\n        return {\n          minAmount: formatNumber(Number(minAmountToken), 6)\n        };\n      }\n    } catch {}\n    return {\n      msg: [defaultMessage]\n    };\n  }\n  const disableSubmit = !fiatQuoteQuery.data;\n  const errorMsg = !fiatQuoteQuery.isLoading && fiatQuoteQuery.error ? getErrorMessage(fiatQuoteQuery.error) : undefined;\n  return _jsxs(Container, {\n    flex: \"column\",\n    gap: \"md\",\n    animate: \"fadein\",\n    children: [isOpen && _jsxs(_Fragment, {\n      children: [_jsx(DrawerOverlay, {\n        ref: drawerOverlayRef\n      }), _jsx(Drawer, {\n        ref: drawerRef,\n        close: () => setIsOpen(false),\n        children: drawerScreen === \"fees\" && fiatQuoteQuery.data && _jsxs(\"div\", {\n          children: [_jsx(Text, {\n            size: \"lg\",\n            color: \"primaryText\",\n            children: \"Fees\"\n          }), _jsx(Spacer, {\n            y: \"lg\"\n          }), _jsx(FiatFees, {\n            quote: fiatQuoteQuery.data\n          })]\n        })\n      })]\n    }), _jsxs(\"div\", {\n      children: [_jsx(PayWithCreditCard, {\n        isLoading: fiatQuoteQuery.isLoading,\n        value: fiatQuoteQuery.data?.fromCurrencyWithFees.amount,\n        client: client,\n        currency: selectedCurrency,\n        onSelectCurrency: showCurrencySelector\n      }), _jsx(EstimatedTimeAndFees, {\n        quoteIsLoading: fiatQuoteQuery.isLoading,\n        estimatedSeconds: fiatQuoteQuery.data?.estimatedDurationSeconds,\n        onViewFees: showFees\n      }), _jsx(Spacer, {\n        y: \"md\"\n      })]\n    }), errorMsg && _jsxs(\"div\", {\n      children: [errorMsg.minAmount && _jsxs(Text, {\n        color: \"danger\",\n        size: \"sm\",\n        center: true,\n        multiline: true,\n        children: [\"Minimum amount is \", errorMsg.minAmount, \" \", _jsx(TokenSymbol, {\n          token: toToken,\n          chain: toChain,\n          size: \"sm\",\n          inline: true,\n          color: \"danger\"\n        })]\n      }), errorMsg.msg?.map(msg => _jsx(Text, {\n        color: \"danger\",\n        size: \"sm\",\n        center: true,\n        multiline: true,\n        children: msg\n      }, msg))]\n    }), errorMsg?.minAmount ? _jsx(Button, {\n      variant: \"accent\",\n      fullWidth: true,\n      onClick: () => {\n        props.setTokenAmount(String(errorMsg.minAmount));\n        props.setHasEditedAmount(true);\n      },\n      children: \"Set Minimum\"\n    }) : _jsx(Button, {\n      variant: disableSubmit ? \"outline\" : \"accent\",\n      \"data-disabled\": disableSubmit,\n      disabled: disableSubmit,\n      fullWidth: true,\n      onClick: handleSubmit,\n      gap: \"xs\",\n      children: fiatQuoteQuery.isLoading ? _jsxs(_Fragment, {\n        children: [\"Getting price quote\", _jsx(Spinner, {\n          size: \"sm\",\n          color: \"accentText\"\n        })]\n      }) : \"Continue\"\n    })]\n  });\n}\nfunction createSupportedTokens(data, payOptions, supportedTokensOverrides) {\n  const tokens = {};\n  const isBuyWithFiatDisabled = payOptions.buyWithFiat === false;\n  const isBuyWithCryptoDisabled = payOptions.buyWithCrypto === false;\n  // FIXME (pay) when buywithFiat is disabled, missing a bunch of tokens on base??\n  for (const x of data) {\n    tokens[x.chain.id] = x.tokens.filter(t => {\n      // for source tokens, data is not provided, so we include all of them\n      if (t.buyWithCryptoEnabled === undefined && t.buyWithFiatEnabled === undefined) {\n        return true;\n      }\n      // it token supports both - include it\n      if (t.buyWithCryptoEnabled && t.buyWithFiatEnabled) {\n        return true;\n      }\n      // if buyWithFiat is disabled, and buyWithCrypto is not supported by token - exclude the token\n      if (!t.buyWithCryptoEnabled && isBuyWithFiatDisabled) {\n        return false;\n      }\n      // if buyWithCrypto is disabled, and buyWithFiat is not supported by token - exclude the token\n      if (!t.buyWithFiatEnabled && isBuyWithCryptoDisabled) {\n        return false;\n      }\n      return true; // include the token\n    });\n  }\n  // override with props.supportedTokens\n  if (supportedTokensOverrides) {\n    for (const k in supportedTokensOverrides) {\n      const key = Number(k);\n      const tokenList = supportedTokensOverrides[key];\n      if (tokenList) {\n        tokens[key] = tokenList;\n      }\n    }\n  }\n  return tokens;\n}\nfunction ChainSelectionScreen(props) {\n  return _jsx(NetworkSelectorContent, {\n    client: props.client,\n    connectLocale: props.connectLocale,\n    showTabs: false,\n    onBack: props.goBack,\n    chains: props.chains,\n    closeModal: props.goBack,\n    networkSelector: {\n      renderChain(renderChainProps) {\n        return _jsx(ChainButton, {\n          chain: renderChainProps.chain,\n          confirming: false,\n          switchingFailed: false,\n          onClick: () => {\n            props.setChain(renderChainProps.chain);\n            props.goBack();\n          },\n          client: props.client,\n          connectLocale: props.connectLocale\n        });\n      }\n    }\n  });\n}\n//# sourceMappingURL=BuyScreen.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}