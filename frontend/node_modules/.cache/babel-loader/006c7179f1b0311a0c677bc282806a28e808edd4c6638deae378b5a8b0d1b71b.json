{"ast":null,"code":"import * as Base64 from './Base64.js';\nimport * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\nimport * as P256 from './P256.js';\nimport * as internal from './internal/webauthn.js';\nexport const createChallenge = Uint8Array.from([105, 171, 180, 181, 160, 222, 75, 198, 42, 42, 32, 31, 141, 37, 186, 233]);\n/**\n * Creates a new WebAuthn P256 Credential, which can be stored and later used for signing.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' }) // [!code focus]\n * // @log: {\n * // @log:   id: 'oZ48...',\n * // @log:   publicKey: { x: 51421...5123n, y: 12345...6789n },\n * // @log:   raw: PublicKeyCredential {},\n * // @log: }\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   credentialId: credential.id,\n *   challenge: '0xdeadbeef',\n * })\n * ```\n *\n * @param options - Credential creation options.\n * @returns A WebAuthn P256 credential.\n */\nexport async function createCredential(options) {\n  const {\n    createFn = window.navigator.credentials.create.bind(window.navigator.credentials),\n    ...rest\n  } = options;\n  const creationOptions = getCredentialCreationOptions(rest);\n  try {\n    const credential = await createFn(creationOptions);\n    if (!credential) throw new CredentialCreationFailedError();\n    const response = credential.response;\n    const publicKey = await internal.parseCredentialPublicKey(response);\n    return {\n      id: credential.id,\n      publicKey,\n      raw: credential\n    };\n  } catch (error) {\n    throw new CredentialCreationFailedError({\n      cause: error\n    });\n  }\n}\n/**\n * Gets the authenticator data which contains information about the\n * processing of an authenticator request (ie. from `WebAuthnP256.sign`).\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * autenticator data. In most cases you will not need this function.\n * `authenticatorData` is typically returned as part of the\n * {@link ox#WebAuthnP256.(sign:function)} response (ie. an authenticator response).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const authenticatorData = WebAuthnP256.getAuthenticatorData({\n *   rpId: 'example.com',\n *   signCount: 420,\n * })\n * // @log: \"0xa379a6f6eeafb9a55e378c118034e2751e682fab9f2d30ab13d2125586ce194705000001a4\"\n * ```\n *\n * @param options - Options to construct the authenticator data.\n * @returns The authenticator data.\n */\nexport function getAuthenticatorData(options = {}) {\n  const {\n    flag = 5,\n    rpId = window.location.hostname,\n    signCount = 0\n  } = options;\n  const rpIdHash = Hash.sha256(Hex.fromString(rpId));\n  const flag_bytes = Hex.fromNumber(flag, {\n    size: 1\n  });\n  const signCount_bytes = Hex.fromNumber(signCount, {\n    size: 4\n  });\n  return Hex.concat(rpIdHash, flag_bytes, signCount_bytes);\n}\n/**\n * Constructs the Client Data in stringified JSON format which represents client data that\n * was passed to `credentials.get()` in {@link ox#WebAuthnP256.(sign:function)}.\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * client data. In most cases you will not need this function.\n * `clientDataJSON` is typically returned as part of the\n * {@link ox#WebAuthnP256.(sign:function)} response (ie. an authenticator response).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const clientDataJSON = WebAuthnP256.getClientDataJSON({\n *   challenge: '0xdeadbeef',\n *   origin: 'https://example.com',\n * })\n * // @log: \"{\"type\":\"webauthn.get\",\"challenge\":\"3q2-7w\",\"origin\":\"https://example.com\",\"crossOrigin\":false}\"\n * ```\n *\n * @param options - Options to construct the client data.\n * @returns The client data.\n */\nexport function getClientDataJSON(options) {\n  const {\n    challenge,\n    crossOrigin = false,\n    extraClientData,\n    origin = window.location.origin\n  } = options;\n  return JSON.stringify({\n    type: 'webauthn.get',\n    challenge: Base64.fromHex(challenge, {\n      url: true,\n      pad: false\n    }),\n    origin,\n    crossOrigin,\n    ...extraClientData\n  });\n}\n/**\n * Returns the creation options for a P256 WebAuthn Credential to be used with\n * the Web Authentication API.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const options = WebAuthnP256.getCredentialCreationOptions({ name: 'Example' })\n *\n * const credential = await window.navigator.credentials.create(options)\n * ```\n *\n * @param options - Options.\n * @returns The credential creation options.\n */\nexport function getCredentialCreationOptions(options) {\n  const {\n    attestation = 'none',\n    authenticatorSelection = {\n      residentKey: 'preferred',\n      requireResidentKey: false,\n      userVerification: 'required'\n    },\n    challenge = createChallenge,\n    excludeCredentialIds,\n    name: name_,\n    rp = {\n      id: window.location.hostname,\n      name: window.document.title\n    },\n    user,\n    extensions\n  } = options;\n  const name = user?.name ?? name_;\n  return {\n    publicKey: {\n      attestation,\n      authenticatorSelection,\n      challenge,\n      ...(excludeCredentialIds ? {\n        excludeCredentials: excludeCredentialIds?.map(id => ({\n          id: Base64.toBytes(id),\n          type: 'public-key'\n        }))\n      } : {}),\n      pubKeyCredParams: [{\n        type: 'public-key',\n        alg: -7 // p256\n      }],\n      rp,\n      user: {\n        id: user?.id ?? Hash.keccak256(Bytes.fromString(name), {\n          as: 'Bytes'\n        }),\n        name,\n        displayName: user?.displayName ?? name\n      },\n      extensions\n    }\n  };\n}\n/**\n * Returns the request options to sign a challenge with the Web Authentication API.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const options = WebAuthnP256.getCredentialRequestOptions({\n *   challenge: '0xdeadbeef',\n * })\n *\n * const credential = await window.navigator.credentials.get(options)\n * ```\n *\n * @param options - Options.\n * @returns The credential request options.\n */\nexport function getCredentialRequestOptions(options) {\n  const {\n    credentialId,\n    challenge,\n    rpId = window.location.hostname,\n    userVerification = 'required'\n  } = options;\n  return {\n    publicKey: {\n      ...(credentialId ? {\n        allowCredentials: [{\n          id: Base64.toBytes(credentialId),\n          type: 'public-key'\n        }]\n      } : {}),\n      challenge: Bytes.fromHex(challenge),\n      rpId,\n      userVerification\n    }\n  };\n}\n/**\n * Constructs the final digest that was signed and computed by the authenticator. This payload includes\n * the cryptographic `challenge`, as well as authenticator metadata (`authenticatorData` + `clientDataJSON`).\n * This value can be also used with raw P256 verification (such as {@link ox#P256.(verify:function)} or\n * {@link ox#WebCryptoP256.(verify:function)}).\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * signing payloads. In most cases you will not need this function and\n * instead use {@link ox#WebAuthnP256.(sign:function)}.\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256, WebCryptoP256 } from 'ox'\n *\n * const { metadata, payload } = WebAuthnP256.getSignPayload({ // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   metadata: {\n * // @log:     authenticatorData: \"0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000\",\n * // @log:     challengeIndex: 23,\n * // @log:     clientDataJSON: \"{\"type\":\"webauthn.get\",\"challenge\":\"9jEFijuhEWrM4SOW-tChJbUEHEP44VcjcJ-Bqo1fTM8\",\"origin\":\"http://localhost:5173\",\"crossOrigin\":false}\",\n * // @log:     typeIndex: 1,\n * // @log:     userVerificationRequired: true,\n * // @log:   },\n * // @log:   payload: \"0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d9763050000000045086dcb06a5f234db625bcdc94e657f86b76b6fd3eb9c30543eabc1e577a4b0\",\n * // @log: }\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPair()\n *\n * const signature = await WebCryptoP256.sign({\n *   payload,\n *   privateKey,\n * })\n * ```\n *\n * @param options - Options to construct the signing payload.\n * @returns The signing payload.\n */\nexport function getSignPayload(options) {\n  const {\n    challenge,\n    crossOrigin,\n    extraClientData,\n    flag,\n    origin,\n    rpId,\n    signCount,\n    userVerification = 'required'\n  } = options;\n  const authenticatorData = getAuthenticatorData({\n    flag,\n    rpId,\n    signCount\n  });\n  const clientDataJSON = getClientDataJSON({\n    challenge,\n    crossOrigin,\n    extraClientData,\n    origin\n  });\n  const clientDataJSONHash = Hash.sha256(Hex.fromString(clientDataJSON));\n  const challengeIndex = clientDataJSON.indexOf('\"challenge\"');\n  const typeIndex = clientDataJSON.indexOf('\"type\"');\n  const metadata = {\n    authenticatorData,\n    clientDataJSON,\n    challengeIndex,\n    typeIndex,\n    userVerificationRequired: userVerification === 'required'\n  };\n  const payload = Hex.concat(authenticatorData, clientDataJSONHash);\n  return {\n    metadata,\n    payload\n  };\n}\n/**\n * Signs a challenge using a stored WebAuthn P256 Credential. If no Credential is provided,\n * a prompt will be displayed for the user to select an existing Credential\n * that was previously registered.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({ // [!code focus]\n *   credentialId: credential.id, // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   metadata: {\n * // @log:     authenticatorData: '0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000',\n * // @log:     clientDataJSON: '{\"type\":\"webauthn.get\",\"challenge\":\"9jEFijuhEWrM4SOW-tChJbUEHEP44VcjcJ-Bqo1fTM8\",\"origin\":\"http://localhost:5173\",\"crossOrigin\":false}',\n * // @log:     challengeIndex: 23,\n * // @log:     typeIndex: 1,\n * // @log:     userVerificationRequired: true,\n * // @log:   },\n * // @log:   signature: { r: 51231...4215n, s: 12345...6789n },\n * // @log: }\n * ```\n *\n * @param options - Options.\n * @returns The signature.\n */\nexport async function sign(options) {\n  const {\n    getFn = window.navigator.credentials.get.bind(window.navigator.credentials),\n    ...rest\n  } = options;\n  const requestOptions = getCredentialRequestOptions(rest);\n  try {\n    const credential = await getFn(requestOptions);\n    if (!credential) throw new CredentialRequestFailedError();\n    const response = credential.response;\n    const clientDataJSON = String.fromCharCode(...new Uint8Array(response.clientDataJSON));\n    const challengeIndex = clientDataJSON.indexOf('\"challenge\"');\n    const typeIndex = clientDataJSON.indexOf('\"type\"');\n    const signature = internal.parseAsn1Signature(new Uint8Array(response.signature));\n    return {\n      metadata: {\n        authenticatorData: Hex.fromBytes(new Uint8Array(response.authenticatorData)),\n        clientDataJSON,\n        challengeIndex,\n        typeIndex,\n        userVerificationRequired: requestOptions.publicKey.userVerification === 'required'\n      },\n      signature,\n      raw: credential\n    };\n  } catch (error) {\n    throw new CredentialRequestFailedError({\n      cause: error\n    });\n  }\n}\n/**\n * Verifies a signature using the Credential's public key and the challenge which was signed.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   credentialId: credential.id,\n *   challenge: '0xdeadbeef',\n * })\n *\n * const result = await WebAuthnP256.verify({ // [!code focus]\n *   metadata, // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n *   publicKey: credential.publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @param options - Options.\n * @returns Whether the signature is valid.\n */\nexport function verify(options) {\n  const {\n    challenge,\n    hash = true,\n    metadata,\n    publicKey,\n    signature\n  } = options;\n  const {\n    authenticatorData,\n    challengeIndex,\n    clientDataJSON,\n    typeIndex,\n    userVerificationRequired\n  } = metadata;\n  const authenticatorDataBytes = Bytes.fromHex(authenticatorData);\n  // Check length of `authenticatorData`.\n  if (authenticatorDataBytes.length < 37) return false;\n  const flag = authenticatorDataBytes[32];\n  // Verify that the UP bit of the flags in authData is set.\n  if ((flag & 0x01) !== 0x01) return false;\n  // If user verification was determined to be required, verify that\n  // the UV bit of the flags in authData is set. Otherwise, ignore the\n  // value of the UV flag.\n  if (userVerificationRequired && (flag & 0x04) !== 0x04) return false;\n  // If the BE bit of the flags in authData is not set, verify that\n  // the BS bit is not set.\n  if ((flag & 0x08) !== 0x08 && (flag & 0x10) === 0x10) return false;\n  // Check that response is for an authentication assertion\n  const type = '\"type\":\"webauthn.get\"';\n  if (type !== clientDataJSON.slice(Number(typeIndex), type.length + 1)) return false;\n  // Check that hash is in the clientDataJSON.\n  const match = clientDataJSON.slice(Number(challengeIndex)).match(/^\"challenge\":\"(.*?)\"/);\n  if (!match) return false;\n  // Validate the challenge in the clientDataJSON.\n  const [_, challenge_extracted] = match;\n  if (Hex.fromBytes(Base64.toBytes(challenge_extracted)) !== challenge) return false;\n  const clientDataJSONHash = Hash.sha256(Bytes.fromString(clientDataJSON), {\n    as: 'Bytes'\n  });\n  const payload = Bytes.concat(authenticatorDataBytes, clientDataJSONHash);\n  return P256.verify({\n    hash,\n    payload,\n    publicKey,\n    signature\n  });\n}\n/** Thrown when a WebAuthn P256 credential creation fails. */\nexport class CredentialCreationFailedError extends Errors.BaseError {\n  constructor({\n    cause\n  } = {}) {\n    super('Failed to create credential.', {\n      cause\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'WebAuthnP256.CredentialCreationFailedError'\n    });\n  }\n}\n/** Thrown when a WebAuthn P256 credential request fails. */\nexport class CredentialRequestFailedError extends Errors.BaseError {\n  constructor({\n    cause\n  } = {}) {\n    super('Failed to request credential.', {\n      cause\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'WebAuthnP256.CredentialRequestFailedError'\n    });\n  }\n}\n//# sourceMappingURL=WebAuthnP256.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}