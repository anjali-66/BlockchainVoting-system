{"ast":null,"code":"import * as ox__Bytes from \"ox/Bytes\";\nimport * as ox__TypedData from \"ox/TypedData\";\nimport { encodeAbiParameters } from \"../abi/encodeAbiParameters.js\";\nimport { toHex } from \"../encoding/hex.js\";\nimport { keccak256 } from \"./keccak256.js\";\n/**\n * @internal\n */\nexport function hashTypedData(parameters) {\n  const {\n    domain = {},\n    message,\n    primaryType\n  } = parameters;\n  const types = {\n    EIP712Domain: ox__TypedData.extractEip712DomainTypes(domain),\n    ...parameters.types\n  };\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  ox__TypedData.validate({\n    domain,\n    message,\n    primaryType,\n    types\n  });\n  const parts = [\"0x1901\"];\n  if (domain) parts.push(ox__TypedData.hashDomain({\n    domain,\n    types: types\n  }));\n  if (primaryType !== \"EIP712Domain\") {\n    const hashedStruct = (() => {\n      const encoded = encodeData({\n        data: message,\n        primaryType,\n        types: types\n      });\n      return keccak256(encoded);\n    })();\n    parts.push(hashedStruct);\n  }\n  return keccak256(ox__Bytes.concat(...parts.map(p => ox__Bytes.fromHex(p))));\n}\nfunction encodeData({\n  data,\n  primaryType,\n  types\n}) {\n  const encodedTypes = [{\n    type: \"bytes32\"\n  }];\n  const encodedValues = [hashType({\n    primaryType,\n    types\n  })];\n  if (!types[primaryType]) throw new Error(\"Invalid types\");\n  for (const field of types[primaryType]) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name]\n    });\n    encodedTypes.push(type);\n    encodedValues.push(value);\n  }\n  return encodeAbiParameters(encodedTypes, encodedValues);\n}\nfunction hashType({\n  primaryType,\n  types\n}) {\n  const encodedHashType = toHex(encodeType({\n    primaryType,\n    types\n  }));\n  return keccak256(encodedHashType);\n}\nfunction encodeType({\n  primaryType,\n  types\n}) {\n  let result = \"\";\n  const unsortedDeps = findTypeDependencies({\n    primaryType,\n    types\n  });\n  unsortedDeps.delete(primaryType);\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];\n  for (const type of deps) {\n    if (!types[type]) throw new Error(\"Invalid types\");\n    result += `${type}(${types[type].map(({\n      name,\n      type: t\n    }) => `${t} ${name}`).join(\",\")})`;\n  }\n  return result;\n}\nfunction findTypeDependencies({\n  primaryType: primaryType_,\n  types\n}, results = new Set()) {\n  const match = primaryType_.match(/^\\w*/u);\n  const primaryType = match?.[0];\n  if (results.has(primaryType) || types[primaryType] === undefined) {\n    return results;\n  }\n  results.add(primaryType);\n  for (const field of types[primaryType]) {\n    findTypeDependencies({\n      primaryType: field.type,\n      types\n    }, results);\n  }\n  return results;\n}\nfunction encodeField({\n  types,\n  name,\n  type,\n  value\n}) {\n  if (types[type] !== undefined) {\n    return [{\n      type: \"bytes32\"\n    }, keccak256(encodeData({\n      data: value,\n      primaryType: type,\n      types\n    }))];\n  }\n  if (type === \"bytes\") {\n    const prepend = value.length % 2 ? \"0\" : \"\";\n    value = `0x${prepend + value.slice(2)}`;\n    return [{\n      type: \"bytes32\"\n    }, keccak256(value)];\n  }\n  if (type === \"string\") return [{\n    type: \"bytes32\"\n  }, keccak256(toHex(value))];\n  if (type.lastIndexOf(\"]\") === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf(\"[\"));\n    const typeValuePairs =\n    // biome-ignore lint/suspicious/noExplicitAny: Can't anticipate types of nested values\n    value.map(item => encodeField({\n      name,\n      type: parsedType,\n      types,\n      value: item\n    }));\n    return [{\n      type: \"bytes32\"\n    }, keccak256(encodeAbiParameters(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v)))];\n  }\n  return [{\n    type\n  }, value];\n}\n//# sourceMappingURL=hashTypedData.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}