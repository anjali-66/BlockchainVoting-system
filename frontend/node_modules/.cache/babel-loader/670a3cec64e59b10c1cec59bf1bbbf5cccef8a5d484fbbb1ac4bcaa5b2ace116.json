{"ast":null,"code":"\"use client\";\n\n// packages/react/tooltip/src/Tooltip.tsx\nimport * as React from \"react\";\nimport { composeEventHandlers } from \"@radix-ui/primitive\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport { DismissableLayer } from \"@radix-ui/react-dismissable-layer\";\nimport { useId } from \"@radix-ui/react-id\";\nimport * as PopperPrimitive from \"@radix-ui/react-popper\";\nimport { createPopperScope } from \"@radix-ui/react-popper\";\nimport { Portal as PortalPrimitive } from \"@radix-ui/react-portal\";\nimport { Presence } from \"@radix-ui/react-presence\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { Slottable } from \"@radix-ui/react-slot\";\nimport { useControllableState } from \"@radix-ui/react-use-controllable-state\";\nimport * as VisuallyHiddenPrimitive from \"@radix-ui/react-visually-hidden\";\nimport { jsx, jsxs } from \"react/jsx-runtime\";\nvar [createTooltipContext, createTooltipScope] = createContextScope(\"Tooltip\", [createPopperScope]);\nvar usePopperScope = createPopperScope();\nvar PROVIDER_NAME = \"TooltipProvider\";\nvar DEFAULT_DELAY_DURATION = 700;\nvar TOOLTIP_OPEN = \"tooltip.open\";\nvar [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME);\nvar TooltipProvider = props => {\n  const {\n    __scopeTooltip,\n    delayDuration = DEFAULT_DELAY_DURATION,\n    skipDelayDuration = 300,\n    disableHoverableContent = false,\n    children\n  } = props;\n  const [isOpenDelayed, setIsOpenDelayed] = React.useState(true);\n  const isPointerInTransitRef = React.useRef(false);\n  const skipDelayTimerRef = React.useRef(0);\n  React.useEffect(() => {\n    const skipDelayTimer = skipDelayTimerRef.current;\n    return () => window.clearTimeout(skipDelayTimer);\n  }, []);\n  return /* @__PURE__ */jsx(TooltipProviderContextProvider, {\n    scope: __scopeTooltip,\n    isOpenDelayed,\n    delayDuration,\n    onOpen: React.useCallback(() => {\n      window.clearTimeout(skipDelayTimerRef.current);\n      setIsOpenDelayed(false);\n    }, []),\n    onClose: React.useCallback(() => {\n      window.clearTimeout(skipDelayTimerRef.current);\n      skipDelayTimerRef.current = window.setTimeout(() => setIsOpenDelayed(true), skipDelayDuration);\n    }, [skipDelayDuration]),\n    isPointerInTransitRef,\n    onPointerInTransitChange: React.useCallback(inTransit => {\n      isPointerInTransitRef.current = inTransit;\n    }, []),\n    disableHoverableContent,\n    children\n  });\n};\nTooltipProvider.displayName = PROVIDER_NAME;\nvar TOOLTIP_NAME = \"Tooltip\";\nvar [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME);\nvar Tooltip = props => {\n  const {\n    __scopeTooltip,\n    children,\n    open: openProp,\n    defaultOpen = false,\n    onOpenChange,\n    disableHoverableContent: disableHoverableContentProp,\n    delayDuration: delayDurationProp\n  } = props;\n  const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props.__scopeTooltip);\n  const popperScope = usePopperScope(__scopeTooltip);\n  const [trigger, setTrigger] = React.useState(null);\n  const contentId = useId();\n  const openTimerRef = React.useRef(0);\n  const disableHoverableContent = disableHoverableContentProp ?? providerContext.disableHoverableContent;\n  const delayDuration = delayDurationProp ?? providerContext.delayDuration;\n  const wasOpenDelayedRef = React.useRef(false);\n  const [open = false, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: open2 => {\n      if (open2) {\n        providerContext.onOpen();\n        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));\n      } else {\n        providerContext.onClose();\n      }\n      onOpenChange?.(open2);\n    }\n  });\n  const stateAttribute = React.useMemo(() => {\n    return open ? wasOpenDelayedRef.current ? \"delayed-open\" : \"instant-open\" : \"closed\";\n  }, [open]);\n  const handleOpen = React.useCallback(() => {\n    window.clearTimeout(openTimerRef.current);\n    openTimerRef.current = 0;\n    wasOpenDelayedRef.current = false;\n    setOpen(true);\n  }, [setOpen]);\n  const handleClose = React.useCallback(() => {\n    window.clearTimeout(openTimerRef.current);\n    openTimerRef.current = 0;\n    setOpen(false);\n  }, [setOpen]);\n  const handleDelayedOpen = React.useCallback(() => {\n    window.clearTimeout(openTimerRef.current);\n    openTimerRef.current = window.setTimeout(() => {\n      wasOpenDelayedRef.current = true;\n      setOpen(true);\n      openTimerRef.current = 0;\n    }, delayDuration);\n  }, [delayDuration, setOpen]);\n  React.useEffect(() => {\n    return () => {\n      if (openTimerRef.current) {\n        window.clearTimeout(openTimerRef.current);\n        openTimerRef.current = 0;\n      }\n    };\n  }, []);\n  return /* @__PURE__ */jsx(PopperPrimitive.Root, {\n    ...popperScope,\n    children: /* @__PURE__ */jsx(TooltipContextProvider, {\n      scope: __scopeTooltip,\n      contentId,\n      open,\n      stateAttribute,\n      trigger,\n      onTriggerChange: setTrigger,\n      onTriggerEnter: React.useCallback(() => {\n        if (providerContext.isOpenDelayed) handleDelayedOpen();else handleOpen();\n      }, [providerContext.isOpenDelayed, handleDelayedOpen, handleOpen]),\n      onTriggerLeave: React.useCallback(() => {\n        if (disableHoverableContent) {\n          handleClose();\n        } else {\n          window.clearTimeout(openTimerRef.current);\n          openTimerRef.current = 0;\n        }\n      }, [handleClose, disableHoverableContent]),\n      onOpen: handleOpen,\n      onClose: handleClose,\n      disableHoverableContent,\n      children\n    })\n  });\n};\nTooltip.displayName = TOOLTIP_NAME;\nvar TRIGGER_NAME = \"TooltipTrigger\";\nvar TooltipTrigger = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeTooltip,\n    ...triggerProps\n  } = props;\n  const context = useTooltipContext(TRIGGER_NAME, __scopeTooltip);\n  const providerContext = useTooltipProviderContext(TRIGGER_NAME, __scopeTooltip);\n  const popperScope = usePopperScope(__scopeTooltip);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref, context.onTriggerChange);\n  const isPointerDownRef = React.useRef(false);\n  const hasPointerMoveOpenedRef = React.useRef(false);\n  const handlePointerUp = React.useCallback(() => isPointerDownRef.current = false, []);\n  React.useEffect(() => {\n    return () => document.removeEventListener(\"pointerup\", handlePointerUp);\n  }, [handlePointerUp]);\n  return /* @__PURE__ */jsx(PopperPrimitive.Anchor, {\n    asChild: true,\n    ...popperScope,\n    children: /* @__PURE__ */jsx(Primitive.button, {\n      \"aria-describedby\": context.open ? context.contentId : void 0,\n      \"data-state\": context.stateAttribute,\n      ...triggerProps,\n      ref: composedRefs,\n      onPointerMove: composeEventHandlers(props.onPointerMove, event => {\n        if (event.pointerType === \"touch\") return;\n        if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {\n          context.onTriggerEnter();\n          hasPointerMoveOpenedRef.current = true;\n        }\n      }),\n      onPointerLeave: composeEventHandlers(props.onPointerLeave, () => {\n        context.onTriggerLeave();\n        hasPointerMoveOpenedRef.current = false;\n      }),\n      onPointerDown: composeEventHandlers(props.onPointerDown, () => {\n        isPointerDownRef.current = true;\n        document.addEventListener(\"pointerup\", handlePointerUp, {\n          once: true\n        });\n      }),\n      onFocus: composeEventHandlers(props.onFocus, () => {\n        if (!isPointerDownRef.current) context.onOpen();\n      }),\n      onBlur: composeEventHandlers(props.onBlur, context.onClose),\n      onClick: composeEventHandlers(props.onClick, context.onClose)\n    })\n  });\n});\nTooltipTrigger.displayName = TRIGGER_NAME;\nvar PORTAL_NAME = \"TooltipPortal\";\nvar [PortalProvider, usePortalContext] = createTooltipContext(PORTAL_NAME, {\n  forceMount: void 0\n});\nvar TooltipPortal = props => {\n  const {\n    __scopeTooltip,\n    forceMount,\n    children,\n    container\n  } = props;\n  const context = useTooltipContext(PORTAL_NAME, __scopeTooltip);\n  return /* @__PURE__ */jsx(PortalProvider, {\n    scope: __scopeTooltip,\n    forceMount,\n    children: /* @__PURE__ */jsx(Presence, {\n      present: forceMount || context.open,\n      children: /* @__PURE__ */jsx(PortalPrimitive, {\n        asChild: true,\n        container,\n        children\n      })\n    })\n  });\n};\nTooltipPortal.displayName = PORTAL_NAME;\nvar CONTENT_NAME = \"TooltipContent\";\nvar TooltipContent = React.forwardRef((props, forwardedRef) => {\n  const portalContext = usePortalContext(CONTENT_NAME, props.__scopeTooltip);\n  const {\n    forceMount = portalContext.forceMount,\n    side = \"top\",\n    ...contentProps\n  } = props;\n  const context = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);\n  return /* @__PURE__ */jsx(Presence, {\n    present: forceMount || context.open,\n    children: context.disableHoverableContent ? /* @__PURE__ */jsx(TooltipContentImpl, {\n      side,\n      ...contentProps,\n      ref: forwardedRef\n    }) : /* @__PURE__ */jsx(TooltipContentHoverable, {\n      side,\n      ...contentProps,\n      ref: forwardedRef\n    })\n  });\n});\nvar TooltipContentHoverable = React.forwardRef((props, forwardedRef) => {\n  const context = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);\n  const providerContext = useTooltipProviderContext(CONTENT_NAME, props.__scopeTooltip);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const [pointerGraceArea, setPointerGraceArea] = React.useState(null);\n  const {\n    trigger,\n    onClose\n  } = context;\n  const content = ref.current;\n  const {\n    onPointerInTransitChange\n  } = providerContext;\n  const handleRemoveGraceArea = React.useCallback(() => {\n    setPointerGraceArea(null);\n    onPointerInTransitChange(false);\n  }, [onPointerInTransitChange]);\n  const handleCreateGraceArea = React.useCallback((event, hoverTarget) => {\n    const currentTarget = event.currentTarget;\n    const exitPoint = {\n      x: event.clientX,\n      y: event.clientY\n    };\n    const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());\n    const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);\n    const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());\n    const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);\n    setPointerGraceArea(graceArea);\n    onPointerInTransitChange(true);\n  }, [onPointerInTransitChange]);\n  React.useEffect(() => {\n    return () => handleRemoveGraceArea();\n  }, [handleRemoveGraceArea]);\n  React.useEffect(() => {\n    if (trigger && content) {\n      const handleTriggerLeave = event => handleCreateGraceArea(event, content);\n      const handleContentLeave = event => handleCreateGraceArea(event, trigger);\n      trigger.addEventListener(\"pointerleave\", handleTriggerLeave);\n      content.addEventListener(\"pointerleave\", handleContentLeave);\n      return () => {\n        trigger.removeEventListener(\"pointerleave\", handleTriggerLeave);\n        content.removeEventListener(\"pointerleave\", handleContentLeave);\n      };\n    }\n  }, [trigger, content, handleCreateGraceArea, handleRemoveGraceArea]);\n  React.useEffect(() => {\n    if (pointerGraceArea) {\n      const handleTrackPointerGrace = event => {\n        const target = event.target;\n        const pointerPosition = {\n          x: event.clientX,\n          y: event.clientY\n        };\n        const hasEnteredTarget = trigger?.contains(target) || content?.contains(target);\n        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea);\n        if (hasEnteredTarget) {\n          handleRemoveGraceArea();\n        } else if (isPointerOutsideGraceArea) {\n          handleRemoveGraceArea();\n          onClose();\n        }\n      };\n      document.addEventListener(\"pointermove\", handleTrackPointerGrace);\n      return () => document.removeEventListener(\"pointermove\", handleTrackPointerGrace);\n    }\n  }, [trigger, content, pointerGraceArea, onClose, handleRemoveGraceArea]);\n  return /* @__PURE__ */jsx(TooltipContentImpl, {\n    ...props,\n    ref: composedRefs\n  });\n});\nvar [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, {\n  isInside: false\n});\nvar TooltipContentImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeTooltip,\n    children,\n    \"aria-label\": ariaLabel,\n    onEscapeKeyDown,\n    onPointerDownOutside,\n    ...contentProps\n  } = props;\n  const context = useTooltipContext(CONTENT_NAME, __scopeTooltip);\n  const popperScope = usePopperScope(__scopeTooltip);\n  const {\n    onClose\n  } = context;\n  React.useEffect(() => {\n    document.addEventListener(TOOLTIP_OPEN, onClose);\n    return () => document.removeEventListener(TOOLTIP_OPEN, onClose);\n  }, [onClose]);\n  React.useEffect(() => {\n    if (context.trigger) {\n      const handleScroll = event => {\n        const target = event.target;\n        if (target?.contains(context.trigger)) onClose();\n      };\n      window.addEventListener(\"scroll\", handleScroll, {\n        capture: true\n      });\n      return () => window.removeEventListener(\"scroll\", handleScroll, {\n        capture: true\n      });\n    }\n  }, [context.trigger, onClose]);\n  return /* @__PURE__ */jsx(DismissableLayer, {\n    asChild: true,\n    disableOutsidePointerEvents: false,\n    onEscapeKeyDown,\n    onPointerDownOutside,\n    onFocusOutside: event => event.preventDefault(),\n    onDismiss: onClose,\n    children: /* @__PURE__ */jsxs(PopperPrimitive.Content, {\n      \"data-state\": context.stateAttribute,\n      ...popperScope,\n      ...contentProps,\n      ref: forwardedRef,\n      style: {\n        ...contentProps.style,\n        // re-namespace exposed content custom properties\n        ...{\n          \"--radix-tooltip-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n          \"--radix-tooltip-content-available-width\": \"var(--radix-popper-available-width)\",\n          \"--radix-tooltip-content-available-height\": \"var(--radix-popper-available-height)\",\n          \"--radix-tooltip-trigger-width\": \"var(--radix-popper-anchor-width)\",\n          \"--radix-tooltip-trigger-height\": \"var(--radix-popper-anchor-height)\"\n        }\n      },\n      children: [/* @__PURE__ */jsx(Slottable, {\n        children\n      }), /* @__PURE__ */jsx(VisuallyHiddenContentContextProvider, {\n        scope: __scopeTooltip,\n        isInside: true,\n        children: /* @__PURE__ */jsx(VisuallyHiddenPrimitive.Root, {\n          id: context.contentId,\n          role: \"tooltip\",\n          children: ariaLabel || children\n        })\n      })]\n    })\n  });\n});\nTooltipContent.displayName = CONTENT_NAME;\nvar ARROW_NAME = \"TooltipArrow\";\nvar TooltipArrow = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeTooltip,\n    ...arrowProps\n  } = props;\n  const popperScope = usePopperScope(__scopeTooltip);\n  const visuallyHiddenContentContext = useVisuallyHiddenContentContext(ARROW_NAME, __scopeTooltip);\n  return visuallyHiddenContentContext.isInside ? null : /* @__PURE__ */jsx(PopperPrimitive.Arrow, {\n    ...popperScope,\n    ...arrowProps,\n    ref: forwardedRef\n  });\n});\nTooltipArrow.displayName = ARROW_NAME;\nfunction getExitSideFromRect(point, rect) {\n  const top = Math.abs(rect.top - point.y);\n  const bottom = Math.abs(rect.bottom - point.y);\n  const right = Math.abs(rect.right - point.x);\n  const left = Math.abs(rect.left - point.x);\n  switch (Math.min(top, bottom, right, left)) {\n    case left:\n      return \"left\";\n    case right:\n      return \"right\";\n    case top:\n      return \"top\";\n    case bottom:\n      return \"bottom\";\n    default:\n      throw new Error(\"unreachable\");\n  }\n}\nfunction getPaddedExitPoints(exitPoint, exitSide, padding = 5) {\n  const paddedExitPoints = [];\n  switch (exitSide) {\n    case \"top\":\n      paddedExitPoints.push({\n        x: exitPoint.x - padding,\n        y: exitPoint.y + padding\n      }, {\n        x: exitPoint.x + padding,\n        y: exitPoint.y + padding\n      });\n      break;\n    case \"bottom\":\n      paddedExitPoints.push({\n        x: exitPoint.x - padding,\n        y: exitPoint.y - padding\n      }, {\n        x: exitPoint.x + padding,\n        y: exitPoint.y - padding\n      });\n      break;\n    case \"left\":\n      paddedExitPoints.push({\n        x: exitPoint.x + padding,\n        y: exitPoint.y - padding\n      }, {\n        x: exitPoint.x + padding,\n        y: exitPoint.y + padding\n      });\n      break;\n    case \"right\":\n      paddedExitPoints.push({\n        x: exitPoint.x - padding,\n        y: exitPoint.y - padding\n      }, {\n        x: exitPoint.x - padding,\n        y: exitPoint.y + padding\n      });\n      break;\n  }\n  return paddedExitPoints;\n}\nfunction getPointsFromRect(rect) {\n  const {\n    top,\n    right,\n    bottom,\n    left\n  } = rect;\n  return [{\n    x: left,\n    y: top\n  }, {\n    x: right,\n    y: top\n  }, {\n    x: right,\n    y: bottom\n  }, {\n    x: left,\n    y: bottom\n  }];\n}\nfunction isPointInPolygon(point, polygon) {\n  const {\n    x,\n    y\n  } = point;\n  let inside = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x;\n    const yi = polygon[i].y;\n    const xj = polygon[j].x;\n    const yj = polygon[j].y;\n    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;\n    if (intersect) inside = !inside;\n  }\n  return inside;\n}\nfunction getHull(points) {\n  const newPoints = points.slice();\n  newPoints.sort((a, b) => {\n    if (a.x < b.x) return -1;else if (a.x > b.x) return 1;else if (a.y < b.y) return -1;else if (a.y > b.y) return 1;else return 0;\n  });\n  return getHullPresorted(newPoints);\n}\nfunction getHullPresorted(points) {\n  if (points.length <= 1) return points.slice();\n  const upperHull = [];\n  for (let i = 0; i < points.length; i++) {\n    const p = points[i];\n    while (upperHull.length >= 2) {\n      const q = upperHull[upperHull.length - 1];\n      const r = upperHull[upperHull.length - 2];\n      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) upperHull.pop();else break;\n    }\n    upperHull.push(p);\n  }\n  upperHull.pop();\n  const lowerHull = [];\n  for (let i = points.length - 1; i >= 0; i--) {\n    const p = points[i];\n    while (lowerHull.length >= 2) {\n      const q = lowerHull[lowerHull.length - 1];\n      const r = lowerHull[lowerHull.length - 2];\n      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) lowerHull.pop();else break;\n    }\n    lowerHull.push(p);\n  }\n  lowerHull.pop();\n  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {\n    return upperHull;\n  } else {\n    return upperHull.concat(lowerHull);\n  }\n}\nvar Provider = TooltipProvider;\nvar Root3 = Tooltip;\nvar Trigger = TooltipTrigger;\nvar Portal = TooltipPortal;\nvar Content2 = TooltipContent;\nvar Arrow2 = TooltipArrow;\nexport { Arrow2 as Arrow, Content2 as Content, Portal, Provider, Root3 as Root, Tooltip, TooltipArrow, TooltipContent, TooltipPortal, TooltipProvider, TooltipTrigger, Trigger, createTooltipScope };\n//# sourceMappingURL=index.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}