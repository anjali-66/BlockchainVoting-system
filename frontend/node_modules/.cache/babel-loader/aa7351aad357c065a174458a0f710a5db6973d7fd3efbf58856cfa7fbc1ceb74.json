{"ast":null,"code":"import * as Address from './Address.js';\nimport * as Errors from './Errors.js';\nimport { uid } from './internal/uid.js';\nexport const domainRegex = /^([a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,}(:[0-9]{1,5})?$/;\nexport const ipRegex = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(:[0-9]{1,5})?$/;\nexport const localhostRegex = /^localhost(:[0-9]{1,5})?$/;\nexport const nonceRegex = /^[a-zA-Z0-9]{8,}$/;\nexport const schemeRegex = /^([a-zA-Z][a-zA-Z0-9+-.]*)$/;\n// https://regexr.com/80gdj\nexport const prefixRegex = /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\\/\\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\\n)(?<address>0x[a-fA-F0-9]{40})\\n\\n(?:(?<statement>.*)\\n\\n)?/;\n// https://regexr.com/80gf9\nexport const suffixRegex = /(?:URI: (?<uri>.+))\\n(?:Version: (?<version>.+))\\n(?:Chain ID: (?<chainId>\\d+))\\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\\n(?:Issued At: (?<issuedAt>.+))(?:\\nExpiration Time: (?<expirationTime>.+))?(?:\\nNot Before: (?<notBefore>.+))?(?:\\nRequest ID: (?<requestId>.+))?/;\n/**\n * Creates [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) formatted message.\n *\n * @example\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.createMessage({\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   chainId: 1,\n *   domain: 'example.com',\n *   nonce: 'foobarbaz',\n *   uri: 'https://example.com/path',\n *   version: '1',\n * })\n * // @log: \"example.com wants you to sign in with your Ethereum account:\n * // @log: 0xA0Cf798816D4b9b9866b5330EEa46a18382f251e\n * // @log:\n * // @log:\n * // @log: URI: https://example.com/path\n * // @log: Version: 1\n * // @log: Chain ID: 1\n * // @log: Nonce: foobarbaz\n * // @log: Issued At: 2023-02-01T00:00:00.000Z\"\n * ```\n *\n * @param value - Values to use when creating EIP-4361 formatted message.\n * @returns EIP-4361 formatted message.\n */\nexport function createMessage(value) {\n  const {\n    chainId,\n    domain,\n    expirationTime,\n    issuedAt = new Date(),\n    nonce,\n    notBefore,\n    requestId,\n    resources,\n    scheme,\n    uri,\n    version\n  } = value;\n  // Validate fields\n  {\n    // Required fields\n    if (chainId !== Math.floor(chainId)) throw new InvalidMessageFieldError({\n      field: 'chainId',\n      metaMessages: ['- Chain ID must be a EIP-155 chain ID.', '- See https://eips.ethereum.org/EIPS/eip-155', '', `Provided value: ${chainId}`]\n    });\n    if (!(domainRegex.test(domain) || ipRegex.test(domain) || localhostRegex.test(domain))) throw new InvalidMessageFieldError({\n      field: 'domain',\n      metaMessages: ['- Domain must be an RFC 3986 authority.', '- See https://www.rfc-editor.org/rfc/rfc3986', '', `Provided value: ${domain}`]\n    });\n    if (!nonceRegex.test(nonce)) throw new InvalidMessageFieldError({\n      field: 'nonce',\n      metaMessages: ['- Nonce must be at least 8 characters.', '- Nonce must be alphanumeric.', '', `Provided value: ${nonce}`]\n    });\n    if (!isUri(uri)) throw new InvalidMessageFieldError({\n      field: 'uri',\n      metaMessages: ['- URI must be a RFC 3986 URI referring to the resource that is the subject of the signing.', '- See https://www.rfc-editor.org/rfc/rfc3986', '', `Provided value: ${uri}`]\n    });\n    if (version !== '1') throw new InvalidMessageFieldError({\n      field: 'version',\n      metaMessages: [\"- Version must be '1'.\", '', `Provided value: ${version}`]\n    });\n    // Optional fields\n    if (scheme && !schemeRegex.test(scheme)) throw new InvalidMessageFieldError({\n      field: 'scheme',\n      metaMessages: ['- Scheme must be an RFC 3986 URI scheme.', '- See https://www.rfc-editor.org/rfc/rfc3986#section-3.1', '', `Provided value: ${scheme}`]\n    });\n    const statement = value.statement;\n    if (statement?.includes('\\n')) throw new InvalidMessageFieldError({\n      field: 'statement',\n      metaMessages: [\"- Statement must not include '\\\\n'.\", '', `Provided value: ${statement}`]\n    });\n  }\n  // Construct message\n  const address = Address.from(value.address);\n  const origin = (() => {\n    if (scheme) return `${scheme}://${domain}`;\n    return domain;\n  })();\n  const statement = (() => {\n    if (!value.statement) return '';\n    return `${value.statement}\\n`;\n  })();\n  const prefix = `${origin} wants you to sign in with your Ethereum account:\\n${address}\\n\\n${statement}`;\n  let suffix = `URI: ${uri}\\nVersion: ${version}\\nChain ID: ${chainId}\\nNonce: ${nonce}\\nIssued At: ${issuedAt.toISOString()}`;\n  if (expirationTime) suffix += `\\nExpiration Time: ${expirationTime.toISOString()}`;\n  if (notBefore) suffix += `\\nNot Before: ${notBefore.toISOString()}`;\n  if (requestId) suffix += `\\nRequest ID: ${requestId}`;\n  if (resources) {\n    let content = '\\nResources:';\n    for (const resource of resources) {\n      if (!isUri(resource)) throw new InvalidMessageFieldError({\n        field: 'resources',\n        metaMessages: ['- Every resource must be a RFC 3986 URI.', '- See https://www.rfc-editor.org/rfc/rfc3986', '', `Provided value: ${resource}`]\n      });\n      content += `\\n- ${resource}`;\n    }\n    suffix += content;\n  }\n  return `${prefix}\\n${suffix}`;\n}\n/**\n * Generates random [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) nonce.\n *\n * @example\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.generateNonce()\n * // @log: '65ed4681d4efe0270b923ff5f4b097b1c95974dc33aeebecd5724c42fd86dfd25dc70b27ef836b2aa22e68f19ebcccc1'\n * ```\n *\n * @returns Random nonce.\n */\nexport function generateNonce() {\n  return uid(96);\n}\n/**\n * Check if the given URI is a valid [RFC 3986](https://www.rfc-editor.org/rfc/rfc3986) URI.\n *\n * @example\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.isUri('https://example.com/foo')\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns `false` if invalid, otherwise the valid URI.\n */\n// based on https://github.com/ogt/valid-url\nexport function isUri(value) {\n  // check for illegal characters\n  if (/[^a-z0-9\\:\\/\\?\\#\\[\\]\\@\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=\\.\\-\\_\\~\\%]/i.test(value)) return false;\n  // check for hex escapes that aren't complete\n  if (/%[^0-9a-f]/i.test(value)) return false;\n  if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value)) return false;\n  // from RFC 3986\n  const splitted = splitUri(value);\n  const scheme = splitted[1];\n  const authority = splitted[2];\n  const path = splitted[3];\n  const query = splitted[4];\n  const fragment = splitted[5];\n  // scheme and path are required, though the path can be empty\n  if (!(scheme?.length && path && path.length >= 0)) return false;\n  // if authority is present, the path must be empty or begin with a /\n  if (authority?.length) {\n    if (!(path.length === 0 || /^\\//.test(path))) return false;\n  } else {\n    // if authority is not present, the path must not start with //\n    if (/^\\/\\//.test(path)) return false;\n  }\n  // scheme must begin with a letter, then consist of letters, digits, +, ., or -\n  if (!/^[a-z][a-z0-9\\+\\-\\.]*$/.test(scheme.toLowerCase())) return false;\n  let out = '';\n  // re-assemble the URL per section 5.3 in RFC 3986\n  out += `${scheme}:`;\n  if (authority?.length) out += `//${authority}`;\n  out += path;\n  if (query?.length) out += `?${query}`;\n  if (fragment?.length) out += `#${fragment}`;\n  return out;\n}\nfunction splitUri(value) {\n  return value.match(/(?:([^:\\/?#]+):)?(?:\\/\\/([^\\/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?/);\n}\n/**\n * [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) formatted message into message fields object.\n *\n * @example\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.parseMessage(`example.com wants you to sign in with your Ethereum account:\n * 0xA0Cf798816D4b9b9866b5330EEa46a18382f251e\n *\n * I accept the ExampleOrg Terms of Service: https://example.com/tos\n *\n * URI: https://example.com/path\n * Version: 1\n * Chain ID: 1\n * Nonce: foobarbaz\n * Issued At: 2023-02-01T00:00:00.000Z`)\n * // @log: {\n * // @log:   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * // @log:   chainId: 1,\n * // @log:   domain: 'example.com',\n * // @log:   issuedAt: '2023-02-01T00:00:00.000Z',\n * // @log:   nonce: 'foobarbaz',\n * // @log:   statement: 'I accept the ExampleOrg Terms of Service: https://example.com/tos',\n * // @log:   uri: 'https://example.com/path',\n * // @log:   version: '1',\n * // @log: }\n * ```\n *\n * @param message - [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) formatted message.\n * @returns Message fields object.\n */\nexport function parseMessage(message) {\n  const {\n    scheme,\n    statement,\n    ...prefix\n  } = message.match(prefixRegex)?.groups ?? {};\n  const {\n    chainId,\n    expirationTime,\n    issuedAt,\n    notBefore,\n    requestId,\n    ...suffix\n  } = message.match(suffixRegex)?.groups ?? {};\n  const resources = message.split('Resources:')[1]?.split('\\n- ').slice(1);\n  return {\n    ...prefix,\n    ...suffix,\n    ...(chainId ? {\n      chainId: Number(chainId)\n    } : {}),\n    ...(expirationTime ? {\n      expirationTime: new Date(expirationTime)\n    } : {}),\n    ...(issuedAt ? {\n      issuedAt: new Date(issuedAt)\n    } : {}),\n    ...(notBefore ? {\n      notBefore: new Date(notBefore)\n    } : {}),\n    ...(requestId ? {\n      requestId\n    } : {}),\n    ...(resources ? {\n      resources\n    } : {}),\n    ...(scheme ? {\n      scheme\n    } : {}),\n    ...(statement ? {\n      statement\n    } : {})\n  };\n}\n/**\n * Validates [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) message.\n *\n * @example\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.validateMessage({\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   domain: 'example.com',\n *   message: {\n *     address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *     chainId: 1,\n *     domain: 'example.com',\n *     nonce: 'foobarbaz',\n *     uri: 'https://example.com/path',\n *     version: '1',\n *   },\n *   nonce: 'foobarbaz',\n * })\n * // @log: true\n * ```\n *\n * @param value - Values to use when validating EIP-4361 formatted message.\n * @returns Whether the message is valid.\n */\nexport function validateMessage(value) {\n  const {\n    address,\n    domain,\n    message,\n    nonce,\n    scheme,\n    time = new Date()\n  } = value;\n  if (domain && message.domain !== domain) return false;\n  if (nonce && message.nonce !== nonce) return false;\n  if (scheme && message.scheme !== scheme) return false;\n  if (message.expirationTime && time >= message.expirationTime) return false;\n  if (message.notBefore && time < message.notBefore) return false;\n  try {\n    if (!message.address) return false;\n    if (address && !Address.isEqual(message.address, address)) return false;\n  } catch {\n    return false;\n  }\n  return true;\n}\n/**\n * Thrown when a field in a SIWE Message is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.createMessage({\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   chainId: 1.1,\n *   domain: 'example.com',\n *   nonce: 'foobarbaz',\n *   uri: 'https://example.com/path',\n *   version: '1',\n * })\n * // @error: Siwe.InvalidMessageFieldError: Invalid Sign-In with Ethereum message field \"chainId\".\n * // @error: - Chain ID must be a EIP-155 chain ID.\n * // @error: - See https://eips.ethereum.org/EIPS/eip-155\n * // @error: Provided value: 1.1\n * ```\n */\nexport class InvalidMessageFieldError extends Errors.BaseError {\n  constructor(parameters) {\n    const {\n      field,\n      metaMessages\n    } = parameters;\n    super(`Invalid Sign-In with Ethereum message field \"${field}\".`, {\n      metaMessages\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Siwe.InvalidMessageFieldError'\n    });\n  }\n}\n//# sourceMappingURL=Siwe.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}