{"ast":null,"code":"import { parseAbiItem } from \"abitype\";\nimport { decodeAbiParameters } from \"viem\";\nimport { isAbiFunction } from \"./utils.js\";\nimport { eth_call } from \"../rpc/actions/eth_call.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport { encodeAbiParameters } from \"../utils/abi/encodeAbiParameters.js\";\nimport { prepareMethod } from \"../utils/abi/prepare-method.js\";\n/**\n * ### Reads state from a deployed smart contract.\n *\n * Use this for raw read calls from a contract, but you can also use read [extensions](https://portal.thirdweb.com/typescript/v5/extensions/use) for predefined methods for common standards.\n *\n * @param options - The transaction options.\n * @returns A promise that resolves with the result of the read call.\n * @transaction\n * @example\n *\n * ### Raw contract call (recommended)\n *\n * You can read from any contract by using the solidity signature of the function you want to call.\n *\n * ```ts\n * import { getContract } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { useReadContract } from \"thirdweb/react\";\n *\n * const contract = getContract({\n *   client,\n *   address: \"0x...\",\n *   chain: sepolia,\n * });\n *\n * const { data, isLoading } = useReadContract({\n *   contract,\n *   method: \"function tokenURI(uint256 tokenId) returns (string)\",\n *   params: [1n],\n * });\n * ```\n *\n * Note that this is type safe, the params types will be enforced based on the signature.\n *\n * ### Raw contract call with `resolveMethod`\n *\n * If you don't have the solidity signature of the function you want to call, you can use the `resolveMethod` helper to resolve the method from any deployed contract.\n *\n * Note that this is not type safe, and will also have a 1 time overhead of resolving the contract ABI.\n *\n * ```ts\n * import { getContract, resolveMethod } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { useReadContract } from \"thirdweb/react\";\n *\n * const contract = getContract({\n *   client,\n *   address: \"0x...\",\n *   chain: sepolia,\n * });\n *\n * const { data, isLoading } = useReadContract({\n *   contract,\n *   method: resolveMethod(\"tokenURI\"),\n *   params: [1n],\n * });\n * ```\n */\nexport async function readContract(options) {\n  const {\n    contract,\n    method,\n    params\n  } = options;\n  const resolvePreparedMethod = async () => {\n    if (Array.isArray(method)) {\n      return method;\n    }\n    if (isAbiFunction(method)) {\n      return prepareMethod(method);\n    }\n    if (typeof method === \"function\") {\n      return prepareMethod(\n      // @ts-expect-error - we're sure it's a function\n      await method(contract));\n    }\n    // if the method starts with the string `function ` we always will want to try to parse it\n    if (typeof method === \"string\" && method.startsWith(\"function \")) {\n      // @ts-expect-error - method *is* string in this case\n      const abiItem = parseAbiItem(method);\n      if (abiItem.type === \"function\") {\n        return prepareMethod(abiItem);\n      }\n      throw new Error(`\"method\" passed is not of type \"function\"`);\n    }\n    // check if we have a \"abi\" on the contract\n    if (contract.abi && contract.abi?.length > 0) {\n      // extract the abiFunction from it\n      const abiFunction = contract.abi?.find(item => item.type === \"function\" && item.name === method);\n      // if we were able to find it -> return it\n      if (abiFunction) {\n        return prepareMethod(abiFunction);\n      }\n    }\n    throw new Error(`Could not resolve method \"${method}\".`);\n  };\n  // resolve in parallel\n  const [resolvedPreparedMethod, resolvedParams] = await Promise.all([resolvePreparedMethod(), typeof params === \"function\" ? params() : params]);\n  let encodedData;\n  // if we have no inputs, we know it's just the signature\n  if (resolvedPreparedMethod[1].length === 0) {\n    encodedData = resolvedPreparedMethod[0];\n  } else {\n    // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n    // we can do this because we know the specific formats of the values\n    encodedData = resolvedPreparedMethod[0] + encodeAbiParameters(resolvedPreparedMethod[1],\n    // @ts-expect-error - TODO: fix this type issue\n    resolvedParams).slice(2);\n  }\n  const rpcRequest = getRpcClient({\n    chain: contract.chain,\n    client: contract.client\n  });\n  const result = await eth_call(rpcRequest, {\n    data: encodedData,\n    to: contract.address,\n    from: options.from\n  });\n  // use the prepared method to decode the result\n  const decoded = decodeAbiParameters(resolvedPreparedMethod[2], result);\n  if (Array.isArray(decoded) && decoded.length === 1) {\n    return decoded[0];\n  }\n  return decoded;\n}\n//# sourceMappingURL=read-contract.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}