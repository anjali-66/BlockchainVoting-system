{"ast":null,"code":"import { useQuery } from \"@tanstack/react-query\";\nimport { useEffect, useState } from \"react\";\nimport { getChainMetadata } from \"../../../../../../../chains/utils.js\";\nimport { NATIVE_TOKEN_ADDRESS } from \"../../../../../../../constants/addresses.js\";\nimport { getContract } from \"../../../../../../../contract/contract.js\";\nimport { getCurrencyMetadata } from \"../../../../../../../extensions/erc20/read/getCurrencyMetadata.js\";\nimport { encode } from \"../../../../../../../transaction/actions/encode.js\";\nimport { getTransactionGasCost } from \"../../../../../../../transaction/utils.js\";\nimport { resolvePromisedValue } from \"../../../../../../../utils/promise/resolve-promised-value.js\";\nimport { getWalletBalance } from \"../../../../../../../wallets/utils/getWalletBalance.js\";\nexport function useTransactionCostAndData(args) {\n  const {\n    transaction,\n    account,\n    supportedDestinations\n  } = args;\n  // Compute query key of the transaction first\n  const [txQueryKey, setTxQueryKey] = useState();\n  useEffect(() => {\n    Promise.all([resolvePromisedValue(transaction.value), resolvePromisedValue(transaction.erc20Value), resolvePromisedValue(transaction.to), encode(transaction)]).then(([value, erc20Value, to, data]) => {\n      setTxQueryKey({\n        value: value?.toString(),\n        erc20Value: erc20Value?.amountWei?.toString(),\n        erc20Currency: erc20Value?.tokenAddress,\n        to,\n        data\n      });\n    });\n  }, [transaction]);\n  return useQuery({\n    queryKey: [\"transaction-cost\", transaction.chain.id, account?.address, txQueryKey],\n    queryFn: async () => {\n      if (!account) {\n        throw new Error(\"No payer account found\");\n      }\n      const erc20Value = await resolvePromisedValue(transaction.erc20Value);\n      if (erc20Value) {\n        const [tokenBalance, tokenMeta, gasCostWei] = await Promise.all([getWalletBalance({\n          address: account.address,\n          chain: transaction.chain,\n          client: transaction.client,\n          tokenAddress: erc20Value.tokenAddress\n        }), getCurrencyMetadata({\n          contract: getContract({\n            address: erc20Value.tokenAddress,\n            chain: transaction.chain,\n            client: transaction.client\n          })\n        }), getTransactionGasCost(transaction, account?.address)]);\n        const transactionValueWei = erc20Value.amountWei;\n        const walletBalance = tokenBalance;\n        const currency = {\n          address: erc20Value.tokenAddress,\n          name: tokenMeta.name,\n          symbol: tokenMeta.symbol,\n          icon: supportedDestinations.find(c => c.chain.id === transaction.chain.id)?.tokens.find(t => t.address.toLowerCase() === erc20Value.tokenAddress.toLowerCase())?.icon\n        };\n        return {\n          token: currency,\n          decimals: tokenMeta.decimals,\n          walletBalance,\n          gasCostWei,\n          transactionValueWei\n        };\n      }\n      const [nativeWalletBalance, chainMetadata, gasCostWei] = await Promise.all([getWalletBalance({\n        address: account.address,\n        chain: transaction.chain,\n        client: transaction.client\n      }), getChainMetadata(transaction.chain), getTransactionGasCost(transaction, account?.address)]);\n      const walletBalance = nativeWalletBalance;\n      const transactionValueWei = (await resolvePromisedValue(transaction.value)) || 0n;\n      return {\n        token: {\n          address: NATIVE_TOKEN_ADDRESS,\n          name: chainMetadata.nativeCurrency.name,\n          symbol: chainMetadata.nativeCurrency.symbol,\n          icon: chainMetadata.icon?.url\n        },\n        decimals: 18,\n        walletBalance,\n        gasCostWei,\n        transactionValueWei\n      };\n    },\n    enabled: !!transaction && !!txQueryKey,\n    refetchInterval: () => {\n      if (transaction.erc20Value) {\n        // if erc20 value is set, we don't need to poll\n        return undefined;\n      }\n      return 30_000;\n    }\n  });\n}\n//# sourceMappingURL=useBuyTxStates.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}