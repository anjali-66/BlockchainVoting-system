{"ast":null,"code":"import { getBytecode } from \"../../contract/actions/get-bytecode.js\";\nimport { eth_getStorageAt } from \"../../rpc/actions/eth_getStorageAt.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport { readContract } from \"../../transaction/read-contract.js\";\nimport { isAddress } from \"../address.js\";\nimport { extractMinimalProxyImplementationAddress } from \"./extractMnimalProxyImplementationAddress.js\";\n// TODO: move to const exports\nconst AddressZero = \"0x0000000000000000000000000000000000000000\";\nconst ZERO_BYTES32 = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n/**\n * Resolves the implementation address and bytecode for a given proxy contract.\n * @param contract The contract to resolve the implementation for.\n * @returns A promise that resolves to an object containing the implementation address and bytecode.\n * @example\n * ```ts\n * import { resolveImplementation } from \"thirdweb\";\n * const implementation = await resolveImplementation(contract);\n * ```\n * @contract\n */\nexport async function resolveImplementation(\n// biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\ncontract) {\n  const [originalBytecode, beacon] = await Promise.all([getBytecode(contract), getBeaconFromStorageSlot(contract)]);\n  // check minimal proxy first synchronously\n  const minimalProxyImplementationAddress = extractMinimalProxyImplementationAddress(originalBytecode);\n  if (minimalProxyImplementationAddress) {\n    return {\n      address: minimalProxyImplementationAddress,\n      bytecode: await getBytecode({\n        ...contract,\n        address: minimalProxyImplementationAddress\n      })\n    };\n  }\n  // check other proxy types\n  let implementationAddress;\n  if (beacon && beacon !== AddressZero) {\n    // In case of a BeaconProxy, it is setup as BeaconProxy --> Beacon --> Implementation\n    // Hence we replace the proxy address with Beacon address, and continue further resolving below\n    // biome-ignore lint/style/noParameterAssign: we purposefully mutate the contract object here\n    contract = {\n      ...contract,\n      address: beacon\n    };\n    implementationAddress = await getImplementationFromContractCall(contract);\n  } else {\n    implementationAddress = await getImplementationFromStorageSlot(contract);\n  }\n  if (implementationAddress && isAddress(implementationAddress) && implementationAddress !== AddressZero) {\n    const implementationBytecode = await getBytecode({\n      ...contract,\n      address: implementationAddress\n    });\n    // return the original contract bytecode if the implementation bytecode is empty\n    if (implementationBytecode === \"0x\") {\n      return {\n        address: contract.address,\n        bytecode: originalBytecode\n      };\n    }\n    return {\n      address: implementationAddress,\n      bytecode: implementationBytecode\n    };\n  }\n  return {\n    address: contract.address,\n    bytecode: originalBytecode\n  };\n}\nasync function getBeaconFromStorageSlot(\n// biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\ncontract) {\n  /**\n   * The storage slot of the Beacon as defined in EIP-1967\n   * See https://eips.ethereum.org/EIPS/eip-1967#beacon-contract-address\n   *\n   * bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1))\n   */\n  const rpcRequest = getRpcClient({\n    client: contract.client,\n    chain: contract.chain\n  });\n  try {\n    const proxyStorage = await eth_getStorageAt(rpcRequest, {\n      address: contract.address,\n      position: \"0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50\"\n    });\n    return `0x${proxyStorage.slice(-40)}`;\n  } catch {\n    return undefined;\n  }\n}\nasync function getImplementationFromStorageSlot(\n// biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\ncontract) {\n  const rpcRequest = getRpcClient({\n    client: contract.client,\n    chain: contract.chain\n  });\n  try {\n    const proxyStoragePromises = [eth_getStorageAt(rpcRequest, {\n      address: contract.address,\n      position: \"0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\"\n    }), eth_getStorageAt(rpcRequest, {\n      address: contract.address,\n      position:\n      // keccak256(\"matic.network.proxy.implementation\") - used in polygon USDT proxy: https://polygonscan.com/address/0xc2132d05d31c914a87c6611c10748aeb04b58e8f#code\n      \"0xbaab7dbf64751104133af04abc7d9979f0fda3b059a322a8333f533d3f32bf7f\"\n    }), eth_getStorageAt(rpcRequest, {\n      address: contract.address,\n      position:\n      // keccak256(\"org.zeppelinos.proxy.implementation\") - e.g. base USDC proxy: https://basescan.org/address/0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913#code\n      \"0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3\"\n    })];\n    const proxyStorages = await Promise.all(proxyStoragePromises);\n    const proxyStorage = proxyStorages.find(storage => storage !== ZERO_BYTES32);\n    return proxyStorage ? `0x${proxyStorage.slice(-40)}` : AddressZero;\n  } catch {\n    return undefined;\n  }\n}\nconst UPGRADEABLE_PROXY_ABI = {\n  type: \"function\",\n  name: \"implementation\",\n  inputs: [],\n  outputs: [{\n    type: \"address\",\n    name: \"\",\n    internalType: \"address\"\n  }],\n  stateMutability: \"view\"\n};\nasync function getImplementationFromContractCall(\n// biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\ncontract) {\n  try {\n    return await readContract({\n      contract,\n      method: UPGRADEABLE_PROXY_ABI\n    });\n  } catch {\n    return undefined;\n  }\n}\n//# sourceMappingURL=resolveImplementation.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}