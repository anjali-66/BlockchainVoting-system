{"ast":null,"code":"/**\n * 1. blockTime + contract (with abi) + no events -> logs with types and parsing *if* contract has abi defined\n * 2. blockTime + contract (no abi) + no events -> logs with NO types but *with* parsing\n * 3. blockTime + no contract + events -> logs with types and parsing (across all \"addresses\") (no contract filter)\n * 4. blockTime + contract + events -> logs with types and parsing (filtered by contract address +  event topics)\n */\nimport { resolveContractAbi } from \"../../contract/actions/resolve-abi.js\";\nimport { eth_blockNumber } from \"../../rpc/actions/eth_blockNumber.js\";\nimport { eth_getLogs } from \"../../rpc/actions/eth_getLogs.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport { prepareEvent } from \"../prepare-event.js\";\nimport { isAbiEvent } from \"../utils.js\";\nimport { parseEventLogs } from \"./parse-logs.js\";\n/**\n * Retrieves events from a contract based on the provided options.\n * @param options - The options for retrieving events.\n * @returns A promise that resolves to an array of parsed event logs.\n * Note: toBlock and fromBlock are both inclusive.\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * const events = await getContractEvents({\n *  contract: myContract,\n *  fromBlock: 123456n,\n *  toBlock: 123456n,\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @example\n * Optionally specify a blockRange as the number of blocks to retrieve. toBlock will default to the current block number.\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * const events = await getContractEvents({\n *  contract: myContract,\n *  blockRange: 123456n,\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @example\n * Use fromBlock with blockRange for pagination.\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * const events = await getContractEvents({\n *  contract: myContract,\n *  fromBlock: lastBlockFetched,\n *  blockRange: 123456n,\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @example\n * Retrieve events for a specific block hash.\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * const events = await getContractEvents({\n *  contract: myContract,\n *  blockHash: \"0x...\",\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @contract\n */\nexport async function getContractEvents(options) {\n  const {\n    contract,\n    events,\n    blockRange,\n    ...restParams\n  } = options;\n  const rpcRequest = getRpcClient(contract);\n  if (restParams.blockHash && (blockRange || restParams.fromBlock || restParams.toBlock)) {\n    throw new Error(\"Cannot specify blockHash and range simultaneously,\");\n  }\n  const latestBlockNumber = await eth_blockNumber(rpcRequest);\n  // Compute toBlock and fromBlock if blockRange was passed\n  if (blockRange) {\n    const {\n      fromBlock,\n      toBlock\n    } = restParams;\n    // Make sure the inputs were properly defined\n    if (fromBlock !== undefined && toBlock !== undefined && BigInt(toBlock) - BigInt(fromBlock) !== BigInt(blockRange)) {\n      throw new Error(\"Incompatible blockRange with specified fromBlock and toBlock. Please only define fromBlock or toBlock when specifying blockRange.\");\n    }\n    if (fromBlock !== undefined) {\n      restParams.toBlock = BigInt(fromBlock) + BigInt(blockRange) - 1n; // Subtract one because toBlock is inclusive\n    } else if (toBlock !== undefined) {\n      restParams.fromBlock = BigInt(toBlock) - BigInt(blockRange) + 1n; // Add one because fromBlock is inclusive\n    } else {\n      // If no from or to block specified, use the latest block as the to block\n      restParams.toBlock = latestBlockNumber;\n      restParams.fromBlock = latestBlockNumber - BigInt(blockRange) + 1n; // Add one because fromBlock is inclusive\n    }\n  }\n  let resolvedEvents = events ?? [];\n  // if we have an abi on the contract, we can encode the topics with it\n  if (!events?.length && !!contract) {\n    // if we have a contract *WITH* an abi we can use that\n    if (contract.abi?.length) {\n      // @ts-expect-error - we can't make typescript happy here, but we know this is an abi event\n      resolvedEvents = contract.abi.filter(isAbiEvent).map(abiEvent => prepareEvent({\n        signature: abiEvent\n      }));\n    } else {\n      const runtimeAbi = await resolveContractAbi(contract);\n      // @ts-expect-error - we can't make typescript happy here, but we know this is an abi event\n      resolvedEvents = runtimeAbi.filter(isAbiEvent).map(abiEvent => prepareEvent({\n        signature: abiEvent\n      }));\n    }\n  }\n  const logsParams = events && events.length > 0 ?\n  // if we have events passed in then we use those\n  events.map(e => ({\n    ...restParams,\n    address: contract?.address,\n    topics: e.topics\n  })) :\n  // otherwise we want \"all\" events (aka not pass any topics at all)\n  [{\n    ...restParams,\n    address: contract?.address\n  }];\n  const logs = await Promise.all(logsParams.map(ethLogParams => eth_getLogs(rpcRequest, ethLogParams)));\n  const flattenLogs = logs.flat().sort((a, b) => Number((a.blockNumber ?? 0n) - (b.blockNumber ?? 0n)));\n  return parseEventLogs({\n    logs: flattenLogs,\n    events: resolvedEvents\n  });\n}\n//# sourceMappingURL=get-events.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}