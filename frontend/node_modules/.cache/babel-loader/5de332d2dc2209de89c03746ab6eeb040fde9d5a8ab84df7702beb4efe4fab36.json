{"ast":null,"code":"\"use client\";\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { getContract } from \"../../../../../../contract/contract.js\";\nimport { getContractMetadata } from \"../../../../../../extensions/common/read/getContractMetadata.js\";\nimport { getNFT } from \"../../../../../../extensions/erc1155/read/getNFT.js\";\nimport { useReadContract } from \"../../../../../core/hooks/contract/useReadContract.js\";\nimport { useSendAndConfirmTransaction } from \"../../../../../core/hooks/transaction/useSendAndConfirmTransaction.js\";\nimport { useActiveAccount } from \"../../../../../core/hooks/wallets/useActiveAccount.js\";\nimport { TransactionButton } from \"../../../TransactionButton/index.js\";\n/**\n * This button is used to claim tokens (NFT or ERC20) from a given thirdweb Drop contract.\n *\n * there are 3 type of Drop contract: NFT Drop (DropERC721), Edition Drop (DropERC1155) and Token Drop (DropERC20)\n *\n * Learn more: https://thirdweb.com/explore/drops\n *\n *\n * Note: This button only works with thirdweb Drop contracts.\n * For custom contract, please use [`TransactionButton`](https://portal.thirdweb.com/references/typescript/v5/TransactionButton)\n * @param props\n * @returns A wrapper for TransactionButton\n *\n * @component\n * @example\n *\n * Example for claiming NFT from an NFT Drop contract\n * ```tsx\n * import { ClaimButton } from \"thirdweb/react\";\n * import { ethereum } from \"thirdweb/chains\";\n *\n * <ClaimButton\n *   contractAddress=\"0x...\" // contract address of the NFT Drop\n *   chain={ethereum}\n *   client={client}\n *   claimParams={{\n *     type: \"ERC721\",\n *     quantity: 1n, // claim 1 token\n *   }}\n * >\n *   Claim now\n * </ClaimButton>\n * ```\n *\n * For Edition Drop (ERC1155)\n * ```tsx\n * <ClaimButton\n *   contractAddress=\"0x...\" // contract address of the Edition Drop\n *   chain={ethereum}\n *   client={client}\n *   claimParams={{\n *     type: \"ERC1155\",\n *     quantity: 1n,\n *     tokenId: 0n,\n *   }}\n * >\n *   Claim now\n * </ClaimButton>\n * ```\n *\n * For Token Drop (ERC20)\n * ```tsx\n * <ClaimButton\n *   contractAddress=\"0x...\" // contract address of the Token Drop\n *   chain={ethereum}\n *   client={client}\n *   claimParams={{\n *     type: \"ERC20\",\n *     quantity: \"100\", // claim 100 ERC20 tokens\n *     // instead of `quantity`, you can also use `quantityInWei` (bigint)\n *   }}\n * >\n *   Claim now\n * </ClaimButton>\n * ```\n *\n * Attach custom Pay metadata\n * ```tsx\n * <ClaimButton\n *   payModal={{\n *     metadata: {\n *       name: \"Van Gogh Starry Night\",\n *       image: \"https://unsplash.com/starry-night.png\"\n *     }\n *   }}\n * >...</ClaimButton>\n *\n * ```\n *\n * Since this button uses the `TransactionButton`, it can take in any props that can be passed\n * to the [`TransactionButton`](https://portal.thirdweb.com/references/typescript/v5/TransactionButton)\n *\n *\n * For error handling & callbacks on transaction-sent and transaction-confirmed,\n * please refer to the TransactionButton docs.\n * @transaction\n */\nexport function ClaimButton(props) {\n  const {\n    children,\n    contractAddress,\n    client,\n    chain,\n    claimParams,\n    payModal\n  } = props;\n  const defaultPayModalMetadata = payModal ? payModal.metadata : undefined;\n  const contract = getContract({\n    address: contractAddress,\n    client,\n    chain\n  });\n  const {\n    data: payMetadata\n  } = useReadContract(getPayMetadata, {\n    contract,\n    tokenId: claimParams.type === \"ERC1155\" ? claimParams.tokenId : undefined,\n    queryOptions: {\n      enabled: !defaultPayModalMetadata\n    }\n  });\n  const account = useActiveAccount();\n  const {\n    mutateAsync\n  } = useSendAndConfirmTransaction();\n  return _jsx(TransactionButton, {\n    payModal: {\n      metadata: defaultPayModalMetadata || payMetadata,\n      ...payModal\n    },\n    transaction: async () => {\n      if (!account) {\n        throw new Error(\"No account detected\");\n      }\n      const [claimTx, {\n        getApprovalForTransaction\n      }] = await Promise.all([getClaimTransaction({\n        contract,\n        account,\n        claimParams\n      }), import(\"../../../../../../extensions/erc20/write/getApprovalForTransaction.js\")]);\n      const approveTx = await getApprovalForTransaction({\n        transaction: claimTx,\n        account\n      });\n      if (approveTx) {\n        await mutateAsync(approveTx);\n      }\n      return claimTx;\n    },\n    ...props,\n    children: children\n  });\n}\n/**\n * We can only get the image and name for Edition Drop\n * For NFT Drop and Token Drop we fall back to the name & image of the contract\n * @internal\n */\nasync function getPayMetadata(options) {\n  const {\n    contract,\n    tokenId\n  } = options;\n  const [contractMetadata, nft] = await Promise.all([getContractMetadata(options), tokenId ? getNFT({\n    contract,\n    tokenId\n  }) : undefined]);\n  if (tokenId) {\n    return {\n      image: nft?.metadata?.image,\n      name: nft?.metadata?.name\n    };\n  }\n  return {\n    image: contractMetadata?.image,\n    name: contractMetadata?.name\n  };\n}\n/**\n * @internal Export for test\n */\nasync function getClaimTransaction({\n  contract,\n  account,\n  claimParams\n}) {\n  switch (claimParams.type) {\n    case \"ERC721\":\n      return await getERC721ClaimTo({\n        contract,\n        account,\n        claimParams\n      });\n    case \"ERC1155\":\n      return await getERC1155ClaimTo({\n        contract,\n        account,\n        claimParams\n      });\n    case \"ERC20\":\n      {\n        return await getERC20ClaimTo({\n          contract,\n          account,\n          claimParams\n        });\n      }\n    default:\n      throw new Error(\"Invalid contract type. Must be either NFT Drop (ERC721), Edition Drop (ERC1155) or Token Drop (ERC20)\");\n  }\n}\n/**\n * @internal\n */\nexport async function getERC721ClaimTo({\n  contract,\n  account,\n  claimParams\n}) {\n  const {\n    claimTo\n  } = await import(\"../../../../../../extensions/erc721/drops/write/claimTo.js\");\n  return claimTo({\n    contract,\n    to: claimParams.to || account?.address || \"\",\n    quantity: claimParams.quantity,\n    from: claimParams.from\n  });\n}\n/**\n * @internal\n */\nexport async function getERC1155ClaimTo({\n  contract,\n  account,\n  claimParams\n}) {\n  const {\n    claimTo\n  } = await import(\"../../../../../../extensions/erc1155/drops/write/claimTo.js\");\n  return claimTo({\n    contract,\n    to: claimParams.to || account?.address || \"\",\n    quantity: claimParams.quantity,\n    tokenId: claimParams.tokenId,\n    from: claimParams.from\n  });\n}\n/**\n * @internal\n */\nexport async function getERC20ClaimTo({\n  contract,\n  account,\n  claimParams\n}) {\n  // Ideally we should check if the contract is ERC20 using `isERC20`\n  // however TokenDrop doesn't have `supportsInterface` so it doesn't work\n  const {\n    claimTo\n  } = await import(\"../../../../../../extensions/erc20/drops/write/claimTo.js\");\n  if (\"quantity\" in claimParams) {\n    return claimTo({\n      contract,\n      to: claimParams.to || account?.address || \"\",\n      quantity: claimParams.quantity,\n      from: claimParams.from\n    });\n  }\n  if (\"quantityInWei\" in claimParams) {\n    return claimTo({\n      contract,\n      to: claimParams.to || account?.address || \"\",\n      quantityInWei: claimParams.quantityInWei,\n      from: claimParams.from\n    });\n  }\n  throw new Error(\"Missing quantity or quantityInWei\");\n}\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}