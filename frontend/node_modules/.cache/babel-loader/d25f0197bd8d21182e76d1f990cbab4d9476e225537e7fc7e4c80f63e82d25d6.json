{"ast":null,"code":"// Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>\nimport { WalletLinkConnection } from './connection/WalletLinkConnection.js';\nimport { LOCAL_STORAGE_ADDRESSES_KEY } from './constants.js';\nimport { RelayEventManager } from './RelayEventManager.js';\nimport { WalletLinkSession } from './type/WalletLinkSession.js';\nimport { isErrorResponse } from './type/Web3Response.js';\nimport { isMobileWeb } from './ui/components/util.js';\nimport { WalletLinkRelayUI } from './ui/WalletLinkRelayUI.js';\nimport { WLMobileRelayUI } from './ui/WLMobileRelayUI.js';\nimport { standardErrors } from '../../../core/error/errors.js';\nimport { ScopedLocalStorage } from '../../../core/storage/ScopedLocalStorage.js';\nimport { bigIntStringFromBigInt, hexStringFromBuffer, randomBytesHex } from '../../../core/type/util.js';\nexport class WalletLinkRelay {\n  constructor(options) {\n    this.chainCallbackParams = {\n      chainId: '',\n      jsonRpcUrl: ''\n    }; // to implement distinctUntilChanged\n    this.isMobileWeb = isMobileWeb();\n    this.linkedUpdated = linked => {\n      this.isLinked = linked;\n      const cachedAddresses = this.storage.getItem(LOCAL_STORAGE_ADDRESSES_KEY);\n      if (linked) {\n        // Only set linked session variable one way\n        this._session.linked = linked;\n      }\n      this.isUnlinkedErrorState = false;\n      if (cachedAddresses) {\n        const addresses = cachedAddresses.split(' ');\n        const wasConnectedViaStandalone = this.storage.getItem('IsStandaloneSigning') === 'true';\n        if (addresses[0] !== '' && !linked && this._session.linked && !wasConnectedViaStandalone) {\n          this.isUnlinkedErrorState = true;\n        }\n      }\n    };\n    this.metadataUpdated = (key, value) => {\n      this.storage.setItem(key, value);\n    };\n    this.chainUpdated = (chainId, jsonRpcUrl) => {\n      if (this.chainCallbackParams.chainId === chainId && this.chainCallbackParams.jsonRpcUrl === jsonRpcUrl) {\n        return;\n      }\n      this.chainCallbackParams = {\n        chainId,\n        jsonRpcUrl\n      };\n      if (this.chainCallback) {\n        this.chainCallback(jsonRpcUrl, Number.parseInt(chainId, 10));\n      }\n    };\n    this.accountUpdated = selectedAddress => {\n      if (this.accountsCallback) {\n        this.accountsCallback([selectedAddress]);\n      }\n      if (WalletLinkRelay.accountRequestCallbackIds.size > 0) {\n        // We get the ethereum address from the metadata.  If for whatever\n        // reason we don't get a response via an explicit web3 message\n        // we can still fulfill the eip1102 request.\n        Array.from(WalletLinkRelay.accountRequestCallbackIds.values()).forEach(id => {\n          this.invokeCallback(id, {\n            method: 'requestEthereumAccounts',\n            result: [selectedAddress]\n          });\n        });\n        WalletLinkRelay.accountRequestCallbackIds.clear();\n      }\n    };\n    this.resetAndReload = this.resetAndReload.bind(this);\n    this.linkAPIUrl = options.linkAPIUrl;\n    this.storage = options.storage;\n    this.metadata = options.metadata;\n    this.accountsCallback = options.accountsCallback;\n    this.chainCallback = options.chainCallback;\n    const {\n      session,\n      ui,\n      connection\n    } = this.subscribe();\n    this._session = session;\n    this.connection = connection;\n    this.relayEventManager = new RelayEventManager();\n    this.ui = ui;\n    this.ui.attach();\n  }\n  subscribe() {\n    const session = WalletLinkSession.load(this.storage) || WalletLinkSession.create(this.storage);\n    const {\n      linkAPIUrl\n    } = this;\n    const connection = new WalletLinkConnection({\n      session,\n      linkAPIUrl,\n      listener: this\n    });\n    const ui = this.isMobileWeb ? new WLMobileRelayUI() : new WalletLinkRelayUI();\n    connection.connect();\n    return {\n      session,\n      ui,\n      connection\n    };\n  }\n  resetAndReload() {\n    this.connection.destroy().then(() => {\n      /**\n       * Only clear storage if the session id we have in memory matches the one on disk\n       * Otherwise, in the case where we have 2 tabs, another tab might have cleared\n       * storage already.  In that case if we clear storage again, the user will be in\n       * a state where the first tab allows the user to connect but the session that\n       * was used isn't persisted.  This leaves the user in a state where they aren't\n       * connected to the mobile app.\n       */\n      const storedSession = WalletLinkSession.load(this.storage);\n      if ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) === this._session.id) {\n        ScopedLocalStorage.clearAll();\n      }\n      document.location.reload();\n    }).catch(_ => {});\n  }\n  signEthereumTransaction(params) {\n    return this.sendRequest({\n      method: 'signEthereumTransaction',\n      params: {\n        fromAddress: params.fromAddress,\n        toAddress: params.toAddress,\n        weiValue: bigIntStringFromBigInt(params.weiValue),\n        data: hexStringFromBuffer(params.data, true),\n        nonce: params.nonce,\n        gasPriceInWei: params.gasPriceInWei ? bigIntStringFromBigInt(params.gasPriceInWei) : null,\n        maxFeePerGas: params.gasPriceInWei ? bigIntStringFromBigInt(params.gasPriceInWei) : null,\n        maxPriorityFeePerGas: params.gasPriceInWei ? bigIntStringFromBigInt(params.gasPriceInWei) : null,\n        gasLimit: params.gasLimit ? bigIntStringFromBigInt(params.gasLimit) : null,\n        chainId: params.chainId,\n        shouldSubmit: false\n      }\n    });\n  }\n  signAndSubmitEthereumTransaction(params) {\n    return this.sendRequest({\n      method: 'signEthereumTransaction',\n      params: {\n        fromAddress: params.fromAddress,\n        toAddress: params.toAddress,\n        weiValue: bigIntStringFromBigInt(params.weiValue),\n        data: hexStringFromBuffer(params.data, true),\n        nonce: params.nonce,\n        gasPriceInWei: params.gasPriceInWei ? bigIntStringFromBigInt(params.gasPriceInWei) : null,\n        maxFeePerGas: params.maxFeePerGas ? bigIntStringFromBigInt(params.maxFeePerGas) : null,\n        maxPriorityFeePerGas: params.maxPriorityFeePerGas ? bigIntStringFromBigInt(params.maxPriorityFeePerGas) : null,\n        gasLimit: params.gasLimit ? bigIntStringFromBigInt(params.gasLimit) : null,\n        chainId: params.chainId,\n        shouldSubmit: true\n      }\n    });\n  }\n  submitEthereumTransaction(signedTransaction, chainId) {\n    return this.sendRequest({\n      method: 'submitEthereumTransaction',\n      params: {\n        signedTransaction: hexStringFromBuffer(signedTransaction, true),\n        chainId\n      }\n    });\n  }\n  getWalletLinkSession() {\n    return this._session;\n  }\n  sendRequest(request) {\n    let hideSnackbarItem = null;\n    const id = randomBytesHex(8);\n    const cancel = error => {\n      this.publishWeb3RequestCanceledEvent(id);\n      this.handleErrorResponse(id, request.method, error);\n      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n    };\n    return new Promise((resolve, reject) => {\n      {\n        hideSnackbarItem = this.ui.showConnecting({\n          isUnlinkedErrorState: this.isUnlinkedErrorState,\n          onCancel: cancel,\n          onResetConnection: this.resetAndReload // eslint-disable-line @typescript-eslint/unbound-method\n        });\n      }\n      this.relayEventManager.callbacks.set(id, response => {\n        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n        if (isErrorResponse(response)) {\n          return reject(new Error(response.errorMessage));\n        }\n        resolve(response);\n      });\n      this.publishWeb3RequestEvent(id, request);\n    });\n  }\n  publishWeb3RequestEvent(id, request) {\n    const message = {\n      type: 'WEB3_REQUEST',\n      id,\n      request\n    };\n    this.publishEvent('Web3Request', message, true).then(_ => {}).catch(err => {\n      this.handleWeb3ResponseMessage(message.id, {\n        method: request.method,\n        errorMessage: err.message\n      });\n    });\n    if (this.isMobileWeb) {\n      this.openCoinbaseWalletDeeplink(request.method);\n    }\n  }\n  // copied from MobileRelay\n  openCoinbaseWalletDeeplink(method) {\n    if (!(this.ui instanceof WLMobileRelayUI)) return;\n    // For mobile relay requests, open the Coinbase Wallet app\n    switch (method) {\n      case 'requestEthereumAccounts': // requestEthereumAccounts is handled via popup\n      case 'switchEthereumChain':\n        // switchEthereumChain doesn't need to open the app\n        return;\n      default:\n        window.addEventListener('blur', () => {\n          window.addEventListener('focus', () => {\n            this.connection.checkUnseenEvents();\n          }, {\n            once: true\n          });\n        }, {\n          once: true\n        });\n        this.ui.openCoinbaseWalletDeeplink();\n        break;\n    }\n  }\n  publishWeb3RequestCanceledEvent(id) {\n    const message = {\n      type: 'WEB3_REQUEST_CANCELED',\n      id\n    };\n    this.publishEvent('Web3RequestCanceled', message, false).then();\n  }\n  publishEvent(event, message, callWebhook) {\n    return this.connection.publishEvent(event, message, callWebhook);\n  }\n  handleWeb3ResponseMessage(id, response) {\n    if (response.method === 'requestEthereumAccounts') {\n      WalletLinkRelay.accountRequestCallbackIds.forEach(id => this.invokeCallback(id, response));\n      WalletLinkRelay.accountRequestCallbackIds.clear();\n      return;\n    }\n    this.invokeCallback(id, response);\n  }\n  handleErrorResponse(id, method, error) {\n    var _a;\n    const errorMessage = (_a = error === null || error === void 0 ? void 0 : error.message) !== null && _a !== void 0 ? _a : 'Unspecified error message.';\n    this.handleWeb3ResponseMessage(id, {\n      method,\n      errorMessage\n    });\n  }\n  invokeCallback(id, response) {\n    const callback = this.relayEventManager.callbacks.get(id);\n    if (callback) {\n      callback(response);\n      this.relayEventManager.callbacks.delete(id);\n    }\n  }\n  requestEthereumAccounts() {\n    const {\n      appName,\n      appLogoUrl\n    } = this.metadata;\n    const request = {\n      method: 'requestEthereumAccounts',\n      params: {\n        appName,\n        appLogoUrl\n      }\n    };\n    const hideSnackbarItem = null;\n    const id = randomBytesHex(8);\n    return new Promise((resolve, reject) => {\n      this.relayEventManager.callbacks.set(id, response => {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n        if (isErrorResponse(response)) {\n          return reject(new Error(response.errorMessage));\n        }\n        resolve(response);\n      });\n      WalletLinkRelay.accountRequestCallbackIds.add(id);\n      this.publishWeb3RequestEvent(id, request);\n    });\n  }\n  watchAsset(type, address, symbol, decimals, image, chainId) {\n    const request = {\n      method: 'watchAsset',\n      params: {\n        type,\n        options: {\n          address,\n          symbol,\n          decimals,\n          image\n        },\n        chainId\n      }\n    };\n    let hideSnackbarItem = null;\n    const id = randomBytesHex(8);\n    const cancel = error => {\n      this.publishWeb3RequestCanceledEvent(id);\n      this.handleErrorResponse(id, request.method, error);\n      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n    };\n    {\n      hideSnackbarItem = this.ui.showConnecting({\n        isUnlinkedErrorState: this.isUnlinkedErrorState,\n        onCancel: cancel,\n        onResetConnection: this.resetAndReload // eslint-disable-line @typescript-eslint/unbound-method\n      });\n    }\n    return new Promise((resolve, reject) => {\n      this.relayEventManager.callbacks.set(id, response => {\n        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n        if (isErrorResponse(response)) {\n          return reject(new Error(response.errorMessage));\n        }\n        resolve(response);\n      });\n      this.publishWeb3RequestEvent(id, request);\n    });\n  }\n  addEthereumChain(chainId, rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency) {\n    const request = {\n      method: 'addEthereumChain',\n      params: {\n        chainId,\n        rpcUrls,\n        blockExplorerUrls,\n        chainName,\n        iconUrls,\n        nativeCurrency\n      }\n    };\n    let hideSnackbarItem = null;\n    const id = randomBytesHex(8);\n    const cancel = error => {\n      this.publishWeb3RequestCanceledEvent(id);\n      this.handleErrorResponse(id, request.method, error);\n      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n    };\n    {\n      hideSnackbarItem = this.ui.showConnecting({\n        isUnlinkedErrorState: this.isUnlinkedErrorState,\n        onCancel: cancel,\n        onResetConnection: this.resetAndReload // eslint-disable-line @typescript-eslint/unbound-method\n      });\n    }\n    return new Promise((resolve, reject) => {\n      this.relayEventManager.callbacks.set(id, response => {\n        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n        if (isErrorResponse(response)) {\n          return reject(new Error(response.errorMessage));\n        }\n        resolve(response);\n      });\n      this.publishWeb3RequestEvent(id, request);\n    });\n  }\n  switchEthereumChain(chainId, address) {\n    const request = {\n      method: 'switchEthereumChain',\n      params: Object.assign({\n        chainId\n      }, {\n        address\n      })\n    };\n    let hideSnackbarItem = null;\n    const id = randomBytesHex(8);\n    const cancel = error => {\n      this.publishWeb3RequestCanceledEvent(id);\n      this.handleErrorResponse(id, request.method, error);\n      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n    };\n    {\n      hideSnackbarItem = this.ui.showConnecting({\n        isUnlinkedErrorState: this.isUnlinkedErrorState,\n        onCancel: cancel,\n        onResetConnection: this.resetAndReload // eslint-disable-line @typescript-eslint/unbound-method\n      });\n    }\n    return new Promise((resolve, reject) => {\n      this.relayEventManager.callbacks.set(id, response => {\n        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n        if (isErrorResponse(response) && response.errorCode) {\n          return reject(standardErrors.provider.custom({\n            code: response.errorCode,\n            message: `Unrecognized chain ID. Try adding the chain using addEthereumChain first.`\n          }));\n        } else if (isErrorResponse(response)) {\n          return reject(new Error(response.errorMessage));\n        }\n        resolve(response);\n      });\n      this.publishWeb3RequestEvent(id, request);\n    });\n  }\n}\nWalletLinkRelay.accountRequestCallbackIds = new Set();\n//# sourceMappingURL=WalletLinkRelay.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}