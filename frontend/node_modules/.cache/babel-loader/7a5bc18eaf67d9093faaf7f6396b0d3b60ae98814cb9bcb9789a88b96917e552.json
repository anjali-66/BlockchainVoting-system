{"ast":null,"code":"import * as Bytes from './Bytes.js';\nimport * as Hex from './Hex.js';\nexport const ivLength = 16;\n/**\n * Decrypts encrypted data using AES-GCM.\n *\n * @example\n * ```ts twoslash\n * import { AesGcm, Hex } from 'ox'\n *\n * const key = await AesGcm.getKey({ password: 'qwerty' })\n * const secret = Hex.fromString('i am a secret message')\n *\n * const encrypted = await AesGcm.encrypt(secret, key)\n *\n * const decrypted = await AesGcm.decrypt(encrypted, key) // [!code focus]\n * // @log: Hex.fromString('i am a secret message')\n * ```\n *\n * @param value - The data to encrypt.\n * @param key - The `CryptoKey` to use for encryption.\n * @param options - Decryption options.\n * @returns The decrypted data.\n */\nexport async function decrypt(value, key, options = {}) {\n  const {\n    as = typeof value === 'string' ? 'Hex' : 'Bytes'\n  } = options;\n  const encrypted = Bytes.from(value);\n  const iv = encrypted.slice(0, ivLength);\n  const data = encrypted.slice(ivLength);\n  const decrypted = await globalThis.crypto.subtle.decrypt({\n    name: 'AES-GCM',\n    iv\n  }, key, Bytes.from(data));\n  const result = new Uint8Array(decrypted);\n  if (as === 'Bytes') return result;\n  return Hex.from(result);\n}\n/**\n * Encrypts data using AES-GCM.\n *\n * @example\n * ```ts twoslash\n * import { AesGcm, Hex } from 'ox'\n *\n * const key = await AesGcm.getKey({ password: 'qwerty' })\n * const secret = Hex.fromString('i am a secret message')\n *\n * const encrypted = await AesGcm.encrypt(secret, key) // [!code focus]\n * // @log: '0x5e257b25bcf53d5431e54e5a68ca0138306d31bb6154f35a97bb8ea18111e7d82bcf619d3c76c4650688bc5310eed80b8fc86d1e3e'\n * ```\n *\n * @param value - The data to encrypt.\n * @param key - The `CryptoKey` to use for encryption.\n * @param options - Encryption options.\n * @returns The encrypted data.\n */\nexport async function encrypt(value, key, options = {}) {\n  const {\n    as = typeof value === 'string' ? 'Hex' : 'Bytes'\n  } = options;\n  const iv = Bytes.random(ivLength);\n  const encrypted = await globalThis.crypto.subtle.encrypt({\n    name: 'AES-GCM',\n    iv\n  }, key, Bytes.from(value));\n  const result = Bytes.concat(iv, new Uint8Array(encrypted));\n  if (as === 'Bytes') return result;\n  return Hex.from(result);\n}\n/**\n * Derives an AES-GCM key from a password using PBKDF2.\n *\n * @example\n * ```ts twoslash\n * import { AesGcm } from 'ox'\n *\n * const key = await AesGcm.getKey({ password: 'qwerty' })\n * // @log: CryptoKey {}\n * ```\n *\n * @param options - Options for key derivation.\n * @returns The derived key.\n */\nexport async function getKey(options) {\n  const {\n    iterations = 900_000,\n    password,\n    salt = randomSalt(32)\n  } = options;\n  const baseKey = await globalThis.crypto.subtle.importKey('raw', Bytes.fromString(password), {\n    name: 'PBKDF2'\n  }, false, ['deriveBits', 'deriveKey']);\n  const key = await globalThis.crypto.subtle.deriveKey({\n    name: 'PBKDF2',\n    salt,\n    iterations,\n    hash: 'SHA-256'\n  }, baseKey, {\n    name: 'AES-GCM',\n    length: 256\n  }, false, ['encrypt', 'decrypt']);\n  return key;\n}\n/**\n * Generates a random salt of the specified size.\n *\n * @example\n * ```ts twoslash\n * import { AesGcm } from 'ox'\n *\n * const salt = AesGcm.randomSalt()\n * // @log: Uint8Array [123, 79, 183, 167, 163, 136, 136, 16, 168, 126, 13, 165, 170, 166, 136, 136, 16, 168, 126, 13, 165, 170, 166, 136, 136, 16, 168, 126, 13, 165, 170, 166]\n * ```\n *\n * @param size - The size of the salt to generate. Defaults to `32`.\n * @returns A random salt of the specified size.\n */\nexport function randomSalt(size = 32) {\n  return Bytes.random(size);\n}\n//# sourceMappingURL=AesGcm.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}