{"ast":null,"code":"import { p256 } from '@noble/curves/p256';\nimport * as Hex from '../Hex.js';\nimport * as PublicKey from '../PublicKey.js';\nimport { CredentialCreationFailedError } from '../WebAuthnP256.js';\n/**\n * Parses an ASN.1 signature into a r and s value.\n *\n * @internal\n */\nexport function parseAsn1Signature(bytes) {\n  const r_start = bytes[4] === 0 ? 5 : 4;\n  const r_end = r_start + 32;\n  const s_start = bytes[r_end + 2] === 0 ? r_end + 3 : r_end + 2;\n  const r = BigInt(Hex.fromBytes(bytes.slice(r_start, r_end)));\n  const s = BigInt(Hex.fromBytes(bytes.slice(s_start)));\n  return {\n    r,\n    s: s > p256.CURVE.n / 2n ? p256.CURVE.n - s : s\n  };\n}\n/**\n * Parses a public key into x and y coordinates from the public key\n * defined on the credential.\n *\n * @internal\n */\nexport async function parseCredentialPublicKey(response) {\n  try {\n    const publicKeyBuffer = response.getPublicKey();\n    if (!publicKeyBuffer) throw new CredentialCreationFailedError();\n    // Converting `publicKeyBuffer` throws when credential is created by 1Password Firefox Add-on\n    const publicKeyBytes = new Uint8Array(publicKeyBuffer);\n    const cryptoKey = await crypto.subtle.importKey('spki', new Uint8Array(publicKeyBytes), {\n      name: 'ECDSA',\n      namedCurve: 'P-256',\n      hash: 'SHA-256'\n    }, true, ['verify']);\n    const publicKey = new Uint8Array(await crypto.subtle.exportKey('raw', cryptoKey));\n    return PublicKey.from(publicKey);\n  } catch (error) {\n    // Fallback for 1Password Firefox Add-on restricts access to certain credential properties\n    // so we need to use `attestationObject` to extract the public key.\n    // https://github.com/passwordless-id/webauthn/issues/50#issuecomment-2072902094\n    if (error.message !== 'Permission denied to access object') throw error;\n    const data = new Uint8Array(response.attestationObject);\n    const coordinateLength = 0x20;\n    const cborPrefix = 0x58;\n    const findStart = key => {\n      const coordinate = new Uint8Array([key, cborPrefix, coordinateLength]);\n      for (let i = 0; i < data.length - coordinate.length; i++) if (coordinate.every((byte, j) => data[i + j] === byte)) return i + coordinate.length;\n      throw new CredentialCreationFailedError();\n    };\n    const xStart = findStart(0x21);\n    const yStart = findStart(0x22);\n    return PublicKey.from(new Uint8Array([0x04, ...data.slice(xStart, xStart + coordinateLength), ...data.slice(yStart, yStart + coordinateLength)]));\n  }\n}\n//# sourceMappingURL=webauthn.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}