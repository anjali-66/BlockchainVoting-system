{"ast":null,"code":"import { version } from \"../version.js\";\nimport { LruMap } from \"./caching/lru.js\";\nimport { detectOS, detectPlatform } from \"./detect-platform.js\";\nimport { isJWT } from \"./jwt/is-jwt.js\";\nimport { IS_DEV } from \"./process.js\";\nconst DEFAULT_REQUEST_TIMEOUT = 60000;\n/**\n * @internal\n */\nexport function getClientFetch(client, ecosystem) {\n  /**\n   * @internal\n   */\n  async function fetchWithHeaders(url, init) {\n    const {\n      requestTimeoutMs = DEFAULT_REQUEST_TIMEOUT,\n      ...restInit\n    } = init || {};\n    let headers = restInit.headers ? new Headers(restInit.headers) : undefined;\n    // check if we are making a request to a thirdweb service (we don't want to send any headers to non-thirdweb services)\n    if (isThirdwebUrl(url)) {\n      if (!headers) {\n        headers = new Headers();\n      }\n      // auth token if secret key === jwt\n      const authToken = client.secretKey && isJWT(client.secretKey) ? client.secretKey : undefined;\n      // secret key if secret key !== jwt\n      const secretKey = client.secretKey && !isJWT(client.secretKey) ? client.secretKey : undefined;\n      const clientId = client.clientId;\n      // if we have an auth token set, use that (thirdweb dashboard sets this for the user)\n      // pay urls should never send the auth token, because we always want the \"developer\" to be the one making the request, not the \"end user\"\n      if (authToken && !isPayUrl(url) && !isInAppWalletUrl(url) && !isBundlerUrl(url)) {\n        headers.set(\"authorization\", `Bearer ${authToken}`);\n      } else if (secretKey) {\n        headers.set(\"x-secret-key\", secretKey);\n      } else if (clientId) {\n        headers.set(\"x-client-id\", clientId);\n      }\n      if (ecosystem) {\n        headers.set(\"x-ecosystem-id\", ecosystem.id);\n        if (ecosystem.partnerId) {\n          headers.set(\"x-ecosystem-partner-id\", ecosystem.partnerId);\n        }\n      }\n      // this already internally caches\n      for (const [key, value] of getPlatformHeaders()) {\n        headers.set(key, value);\n      }\n    }\n    let controller;\n    let abortTimeout;\n    if (requestTimeoutMs) {\n      controller = new AbortController();\n      abortTimeout = setTimeout(() => {\n        controller?.abort(\"timeout\");\n      }, requestTimeoutMs);\n    }\n    return fetch(url, {\n      ...restInit,\n      headers,\n      signal: controller?.signal\n    }).finally(() => {\n      if (abortTimeout) {\n        clearTimeout(abortTimeout);\n      }\n    });\n  }\n  return fetchWithHeaders;\n}\n// NOTE: these all start with \".\" because we want to make sure we don't match (for example) \"otherthirdweb.com\"\nconst THIRDWEB_DOMAINS = [\".thirdweb.com\", \".ipfscdn.io\",\n// dev domains\n\".thirdweb.dev\", \".thirdweb-dev.com\"];\nexport const IS_THIRDWEB_URL_CACHE = new LruMap(4096);\n/**\n * @internal\n */\nexport function isThirdwebUrl(url) {\n  if (IS_THIRDWEB_URL_CACHE.has(url)) {\n    // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set\n    return IS_THIRDWEB_URL_CACHE.get(url);\n  }\n  try {\n    const {\n      hostname\n    } = new URL(url);\n    try {\n      // special case for localhost in development only\n      if (IS_DEV) {\n        if (hostname === \"localhost\") {\n          IS_THIRDWEB_URL_CACHE.set(url, true);\n          return true;\n        }\n      }\n    } catch {}\n    const is = THIRDWEB_DOMAINS.some(domain => hostname.endsWith(domain));\n    IS_THIRDWEB_URL_CACHE.set(url, is);\n    return is;\n  } catch {\n    IS_THIRDWEB_URL_CACHE.set(url, false);\n    return false;\n  }\n}\nfunction isPayUrl(url) {\n  try {\n    const {\n      hostname\n    } = new URL(url);\n    // pay service hostname always starts with \"pay.\"\n    return hostname.startsWith(\"pay.\");\n  } catch {\n    return false;\n  }\n}\nfunction isInAppWalletUrl(url) {\n  try {\n    const {\n      hostname\n    } = new URL(url);\n    // in app wallet service hostname always starts with \"in-app-wallet.\" or \"embedded-wallet.\"\n    return hostname.startsWith(\"in-app-wallet.\") || hostname.startsWith(\"embedded-wallet.\");\n  } catch {\n    return false;\n  }\n}\nfunction isBundlerUrl(url) {\n  try {\n    const {\n      hostname\n    } = new URL(url);\n    return hostname.endsWith(\".bundler.thirdweb.com\") || hostname.endsWith(\".bundler.thirdweb-dev.com\");\n  } catch {\n    return false;\n  }\n}\nconst SDK_NAME = \"unified-sdk\";\nlet previousPlatform;\n/**\n * @internal\n */\nexport function getPlatformHeaders() {\n  if (previousPlatform) {\n    return previousPlatform;\n  }\n  let os = null;\n  if (typeof navigator !== \"undefined\") {\n    os = detectOS(navigator.userAgent);\n  }\n  let bundleId = undefined;\n  if (typeof globalThis !== \"undefined\" && \"Application\" in globalThis) {\n    // shims use wallet connect RN module which injects Application info in globalThis\n    // biome-ignore lint/suspicious/noExplicitAny: get around globalThis typing\n    bundleId = globalThis.Application.applicationId;\n  }\n  previousPlatform = Object.entries({\n    \"x-sdk-platform\": detectPlatform(),\n    \"x-sdk-version\": version,\n    \"x-sdk-os\": os ? parseOs(os) : \"unknown\",\n    \"x-sdk-name\": SDK_NAME,\n    ...(bundleId ? {\n      \"x-bundle-id\": bundleId\n    } : {})\n  });\n  return previousPlatform;\n}\n/**\n * @internal\n */\nfunction parseOs(os) {\n  const osLowerCased = os.toLowerCase();\n  if (osLowerCased.startsWith(\"win\")) {\n    return \"win\";\n  }\n  // we do NOT use the lowercase here\n  switch (os) {\n    case \"Mac OS\":\n      return \"mac\";\n    case \"iOS\":\n      return \"ios\";\n    case \"Android OS\":\n      return \"android\";\n    default:\n      // if we somehow fall through here, just replace all spaces with underscores and send it\n      return osLowerCased.replace(/\\s/gi, \"_\");\n  }\n}\n//# sourceMappingURL=fetch.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}