{"ast":null,"code":"import { isBase64JSON, parseBase64String } from \"../base64/base64.js\";\nimport { numberToHex } from \"../encoding/hex.js\";\n/**\n * Fetches the metadata for a token.\n *\n * @param options - The options for fetching the token metadata.\n * @returns The token metadata.\n * @internal\n */\nexport async function fetchTokenMetadata(options) {\n  const {\n    client,\n    tokenId,\n    tokenUri\n  } = options;\n  // handle case where the URI is a base64 encoded JSON (onchain nft)\n  if (isBase64JSON(tokenUri)) {\n    try {\n      return JSON.parse(parseBase64String(tokenUri));\n    } catch (e) {\n      console.error(\"Failed to fetch base64 encoded NFT\", {\n        tokenId,\n        tokenUri\n      }, e);\n      throw e;\n    }\n  }\n  // in all other cases we will need the `download` function from storage\n  const {\n    download\n  } = await import(\"../../storage/download.js\");\n  // handle non-dynamic uris (most common case -> skip the other checks)\n  try {\n    if (!tokenUri.includes(\"{id}\")) {\n      return await (await download({\n        client,\n        uri: tokenUri\n      })).json();\n    }\n  } catch (e) {\n    console.error(\"Failed to fetch non-dynamic NFT\", {\n      tokenId,\n      tokenUri\n    }, e);\n    throw e;\n  }\n  // DYNAMIC NFT FORMATS (2 options, sadly has to be waterfall)\n  try {\n    try {\n      // try first dynamic id format\n      return await (await download({\n        client,\n        uri: tokenUri.replace(\"{id}\", numberToHex(tokenId, {\n          size: 32\n        }).slice(2))\n      })).json();\n    } catch {\n      // otherwise attempt the second format\n      return await (await download({\n        client,\n        uri: tokenUri.replace(\"{id}\", tokenId.toString())\n      })).json();\n    }\n  } catch (e) {\n    console.error(\"Failed to fetch dynamic NFT\", {\n      tokenId,\n      tokenUri\n    }, e);\n    throw e;\n  }\n}\n//# sourceMappingURL=fetchTokenMetadata.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}