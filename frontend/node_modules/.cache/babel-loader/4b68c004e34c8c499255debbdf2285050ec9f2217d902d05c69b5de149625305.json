{"ast":null,"code":"import { bytesToHex } from \"viem\";\nimport { trackTransaction } from \"../../../../analytics/track/transaction.js\";\nimport { getCachedChain } from \"../../../../chains/utils.js\";\nimport { eth_sendRawTransaction } from \"../../../../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../../../../rpc/rpc.js\";\nimport { getAddress } from \"../../../../utils/address.js\";\nimport { toHex } from \"../../../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../../../utils/signatures/helpers/parse-typed-data.js\";\nimport { getUserStatus } from \"../actions/get-enclave-user-status.js\";\nimport { signMessage as signEnclaveMessage } from \"../actions/sign-message.enclave.js\";\nimport { signTransaction as signEnclaveTransaction } from \"../actions/sign-transaction.enclave.js\";\nimport { signTypedData as signEnclaveTypedData } from \"../actions/sign-typed-data.enclave.js\";\nexport class EnclaveWallet {\n  constructor({\n    client,\n    ecosystem,\n    address,\n    storage\n  }) {\n    Object.defineProperty(this, \"client\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"ecosystem\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"address\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"localStorage\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.client = client;\n    this.ecosystem = ecosystem;\n    this.address = address;\n    this.localStorage = storage;\n  }\n  /**\n   * Store the auth token for use\n   * @returns `{walletAddress: string }` The user's wallet details\n   * @internal\n   */\n  async postWalletSetUp(authResult) {\n    await this.localStorage.saveAuthCookie(authResult.storedToken.cookieString);\n  }\n  /**\n   * Gets the current user's details\n   * @internal\n   */\n  async getUserWalletStatus() {\n    const token = await this.localStorage.getAuthCookie();\n    if (!token) {\n      return {\n        status: \"Logged Out\"\n      };\n    }\n    const userStatus = await getUserStatus({\n      authToken: token,\n      client: this.client,\n      ecosystem: this.ecosystem\n    });\n    if (!userStatus) {\n      return {\n        status: \"Logged Out\"\n      };\n    }\n    const wallet = userStatus.wallets[0];\n    const authDetails = {\n      email: userStatus.linkedAccounts.find(account => account.details.email !== undefined)?.details.email,\n      phoneNumber: userStatus.linkedAccounts.find(account => account.details.phone !== undefined)?.details.phone,\n      userWalletId: userStatus.id || \"\",\n      recoveryShareManagement: \"ENCLAVE\"\n    };\n    if (!wallet) {\n      return {\n        status: \"Logged In, Wallet Uninitialized\",\n        authDetails\n      };\n    }\n    return {\n      status: \"Logged In, Wallet Initialized\",\n      walletAddress: wallet.address,\n      authDetails,\n      account: await this.getAccount()\n    };\n  }\n  /**\n   * Returns an account to perform wallet operations\n   * @internal\n   */\n  async getAccount() {\n    const client = this.client;\n    const storage = this.localStorage;\n    const address = this.address;\n    const ecosystem = this.ecosystem;\n    const _signTransaction = async tx => {\n      const rpcRequest = getRpcClient({\n        client,\n        chain: getCachedChain(tx.chainId)\n      });\n      const transaction = {\n        to: tx.to ? getAddress(tx.to) : undefined,\n        data: tx.data,\n        value: typeof tx.value === \"bigint\" ? toHex(tx.value) : undefined,\n        gas: typeof tx.gas === \"bigint\" ? toHex(tx.gas + tx.gas / BigInt(10)) : undefined,\n        // Add a 10% buffer to gas\n        nonce: typeof tx.nonce === \"number\" ? toHex(tx.nonce) : toHex(await import(\"../../../../rpc/actions/eth_getTransactionCount.js\").then(({\n          eth_getTransactionCount\n        }) => eth_getTransactionCount(rpcRequest, {\n          address: this.address,\n          blockTag: \"pending\"\n        }))),\n        chainId: toHex(tx.chainId)\n      };\n      if (typeof tx.maxFeePerGas === \"bigint\") {\n        transaction.maxFeePerGas = toHex(tx.maxFeePerGas);\n        transaction.maxPriorityFeePerGas = typeof tx.maxPriorityFeePerGas === \"bigint\" ? toHex(tx.maxPriorityFeePerGas) : undefined;\n        transaction.type = 2;\n      } else {\n        transaction.gasPrice = typeof tx.gasPrice === \"bigint\" ? toHex(tx.gasPrice) : undefined;\n        transaction.type = 0;\n      }\n      return signEnclaveTransaction({\n        client,\n        storage,\n        payload: transaction\n      });\n    };\n    return {\n      address: getAddress(address),\n      async signTransaction(tx) {\n        if (!tx.chainId) {\n          throw new Error(\"chainId required in tx to sign\");\n        }\n        return _signTransaction({\n          chainId: tx.chainId,\n          ...tx\n        });\n      },\n      async sendTransaction(tx) {\n        const rpcRequest = getRpcClient({\n          client,\n          chain: getCachedChain(tx.chainId)\n        });\n        const signedTx = await _signTransaction(tx);\n        const transactionHash = await eth_sendRawTransaction(rpcRequest, signedTx);\n        trackTransaction({\n          client,\n          ecosystem,\n          chainId: tx.chainId,\n          walletAddress: address,\n          walletType: \"inApp\",\n          transactionHash,\n          contractAddress: tx.to ?? undefined,\n          gasPrice: tx.gasPrice\n        });\n        return {\n          transactionHash\n        };\n      },\n      async signMessage({\n        message\n      }) {\n        const messagePayload = (() => {\n          if (typeof message === \"string\") {\n            return {\n              message,\n              isRaw: false\n            };\n          }\n          return {\n            message: typeof message.raw === \"string\" ? message.raw : bytesToHex(message.raw),\n            isRaw: true\n          };\n        })();\n        const {\n          signature\n        } = await signEnclaveMessage({\n          client,\n          payload: messagePayload,\n          storage\n        });\n        return signature;\n      },\n      async signTypedData(_typedData) {\n        const parsedTypedData = parseTypedData(_typedData);\n        const {\n          signature\n        } = await signEnclaveTypedData({\n          client,\n          payload: parsedTypedData,\n          storage\n        });\n        return signature;\n      }\n    };\n  }\n}\n//# sourceMappingURL=enclave-wallet.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}