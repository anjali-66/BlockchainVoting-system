{"ast":null,"code":"import { VERSION } from '../../sdk-info.js';\nimport { CB_KEYS_URL } from '../constants.js';\nimport { standardErrors } from '../error/errors.js';\nimport { closePopup, openPopup } from '../../util/web.js';\n/**\n * Communicates with a popup window for Coinbase keys.coinbase.com (or another url)\n * to send and receive messages.\n *\n * This class is responsible for opening a popup window, posting messages to it,\n * and listening for responses.\n *\n * It also handles cleanup of event listeners and the popup window itself when necessary.\n */\nexport class Communicator {\n  constructor({\n    url = CB_KEYS_URL,\n    metadata,\n    preference\n  }) {\n    this.popup = null;\n    this.listeners = new Map();\n    /**\n     * Posts a message to the popup window\n     */\n    this.postMessage = async message => {\n      const popup = await this.waitForPopupLoaded();\n      popup.postMessage(message, this.url.origin);\n    };\n    /**\n     * Posts a request to the popup window and waits for a response\n     */\n    this.postRequestAndWaitForResponse = async request => {\n      const responsePromise = this.onMessage(({\n        requestId\n      }) => requestId === request.id);\n      this.postMessage(request);\n      return await responsePromise;\n    };\n    /**\n     * Listens for messages from the popup window that match a given predicate.\n     */\n    this.onMessage = async predicate => {\n      return new Promise((resolve, reject) => {\n        const listener = event => {\n          if (event.origin !== this.url.origin) return; // origin validation\n          const message = event.data;\n          if (predicate(message)) {\n            resolve(message);\n            window.removeEventListener('message', listener);\n            this.listeners.delete(listener);\n          }\n        };\n        window.addEventListener('message', listener);\n        this.listeners.set(listener, {\n          reject\n        });\n      });\n    };\n    /**\n     * Closes the popup, rejects all requests and clears the listeners\n     */\n    this.disconnect = () => {\n      // Note: keys popup handles closing itself. this is a fallback.\n      closePopup(this.popup);\n      this.popup = null;\n      this.listeners.forEach(({\n        reject\n      }, listener) => {\n        reject(standardErrors.provider.userRejectedRequest('Request rejected'));\n        window.removeEventListener('message', listener);\n      });\n      this.listeners.clear();\n    };\n    /**\n     * Waits for the popup window to fully load and then sends a version message.\n     */\n    this.waitForPopupLoaded = async () => {\n      if (this.popup && !this.popup.closed) {\n        // In case the user un-focused the popup between requests, focus it again\n        this.popup.focus();\n        return this.popup;\n      }\n      this.popup = openPopup(this.url);\n      this.onMessage(({\n        event\n      }) => event === 'PopupUnload').then(this.disconnect).catch(() => {});\n      return this.onMessage(({\n        event\n      }) => event === 'PopupLoaded').then(message => {\n        this.postMessage({\n          requestId: message.id,\n          data: {\n            version: VERSION,\n            metadata: this.metadata,\n            preference: this.preference,\n            location: window.location.toString()\n          }\n        });\n      }).then(() => {\n        if (!this.popup) throw standardErrors.rpc.internal();\n        return this.popup;\n      });\n    };\n    this.url = new URL(url);\n    this.metadata = metadata;\n    this.preference = preference;\n  }\n}\n//# sourceMappingURL=Communicator.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}