{"ast":null,"code":"import { cacheChains } from \"../../chains/utils.js\";\nimport { hasSmartAccount } from \"../../react/core/utils/isSmartWallet.js\";\nimport { computedStore } from \"../../reactive/computedStore.js\";\nimport { effect } from \"../../reactive/effect.js\";\nimport { createStore } from \"../../reactive/store.js\";\nimport { stringify } from \"../../utils/json.js\";\nimport { deleteConnectParamsFromStorage } from \"../../utils/storage/walletStorage.js\";\nimport { smartWallet } from \"../smart/smart-wallet.js\";\nconst CONNECTED_WALLET_IDS = \"thirdweb:connected-wallet-ids\";\nconst LAST_ACTIVE_EOA_ID = \"thirdweb:active-wallet-id\";\nconst LAST_ACTIVE_CHAIN = \"thirdweb:active-chain\";\n/**\n * Create a connection manager for Wallet connections\n * @param storage - An instance of type [`AsyncStorage`](https://portal.thirdweb.com/references/typescript/v5/AsyncStorage)\n * @example\n * ```ts\n * const manager = createConnectionManager();\n * ```\n * @returns A connection manager object\n * @walletUtils\n */\nexport function createConnectionManager(storage) {\n  // stores\n  // active wallet/account\n  const activeWalletStore = createStore(undefined);\n  const activeAccountStore = createStore(undefined);\n  const activeWalletChainStore = createStore(undefined);\n  const activeWalletConnectionStatusStore = createStore(\"disconnected\");\n  const definedChainsStore = createStore(new Map());\n  // update global cachedChains when defined Chains store updates\n  effect(() => {\n    cacheChains([...definedChainsStore.getValue().values()]);\n  }, [definedChainsStore]);\n  // change the active chain object to use the defined chain object\n  effect(() => {\n    const chainVal = activeWalletChainStore.getValue();\n    if (!chainVal) {\n      return;\n    }\n    const definedChain = definedChainsStore.getValue().get(chainVal.id);\n    if (!definedChain || definedChain === chainVal) {\n      return;\n    }\n    // update active chain store\n    activeWalletChainStore.setValue(definedChain);\n  }, [definedChainsStore, activeWalletChainStore]);\n  // other connected accounts\n  const walletIdToConnectedWalletMap = createStore(new Map());\n  const isAutoConnecting = createStore(false);\n  const connectedWallets = computedStore(() => {\n    return Array.from(walletIdToConnectedWalletMap.getValue().values());\n  }, [walletIdToConnectedWalletMap]);\n  // actions\n  const addConnectedWallet = wallet => {\n    const oldValue = walletIdToConnectedWalletMap.getValue();\n    if (oldValue.has(wallet.id)) {\n      return;\n    }\n    const newValue = new Map(oldValue);\n    newValue.set(wallet.id, wallet);\n    walletIdToConnectedWalletMap.setValue(newValue);\n  };\n  const removeConnectedWallet = wallet => {\n    const oldValue = walletIdToConnectedWalletMap.getValue();\n    const newValue = new Map(oldValue);\n    newValue.delete(wallet.id);\n    walletIdToConnectedWalletMap.setValue(newValue);\n  };\n  const onWalletDisconnect = wallet => {\n    deleteConnectParamsFromStorage(storage, wallet.id);\n    removeConnectedWallet(wallet);\n    // if disconnecting the active wallet\n    if (activeWalletStore.getValue() === wallet) {\n      storage.removeItem(LAST_ACTIVE_EOA_ID);\n      activeAccountStore.setValue(undefined);\n      activeWalletChainStore.setValue(undefined);\n      activeWalletStore.setValue(undefined);\n      activeWalletConnectionStatusStore.setValue(\"disconnected\");\n    }\n  };\n  const disconnectWallet = wallet => {\n    onWalletDisconnect(wallet);\n    wallet.disconnect();\n  };\n  // handle the connection logic, but don't set the wallet as active\n  const handleConnection = async (wallet, options) => {\n    const account = wallet.getAccount();\n    if (!account) {\n      throw new Error(\"Cannot set a wallet without an account as active\");\n    }\n    const activeWallet = await (async () => {\n      if (options?.accountAbstraction && !hasSmartAccount(wallet)) {\n        return await handleSmartWalletConnection(wallet, options.client, options.accountAbstraction, onWalletDisconnect);\n      } else {\n        return wallet;\n      }\n    })();\n    await storage.setItem(LAST_ACTIVE_EOA_ID, wallet.id);\n    // add personal wallet to connected wallets list even if it's not the active one\n    addConnectedWallet(wallet);\n    handleSetActiveWallet(activeWallet);\n    wallet.subscribe(\"accountChanged\", async () => {\n      // We reimplement connect here to prevent memory leaks\n      const newWallet = await handleConnection(wallet, options);\n      options?.onConnect?.(newWallet);\n    });\n    return activeWallet;\n  };\n  const connect = async (wallet, options) => {\n    // connectedWallet can be either wallet or smartWallet\n    const connectedWallet = await handleConnection(wallet, options);\n    options?.onConnect?.(connectedWallet);\n    return connectedWallet;\n  };\n  const handleSetActiveWallet = activeWallet => {\n    const account = activeWallet.getAccount();\n    if (!account) {\n      throw new Error(\"Cannot set a wallet without an account as active\");\n    }\n    // also add it to connected wallets if it's not already there\n    addConnectedWallet(activeWallet);\n    // update active states\n    activeWalletStore.setValue(activeWallet);\n    activeAccountStore.setValue(account);\n    activeWalletChainStore.setValue(activeWallet.getChain());\n    activeWalletConnectionStatusStore.setValue(\"connected\");\n    // setup listeners\n    const onAccountsChanged = newAccount => {\n      activeAccountStore.setValue(newAccount);\n    };\n    const unsubAccounts = activeWallet.subscribe(\"accountChanged\", onAccountsChanged);\n    const unsubChainChanged = activeWallet.subscribe(\"chainChanged\", chain => activeWalletChainStore.setValue(chain));\n    const unsubDisconnect = activeWallet.subscribe(\"disconnect\", () => {\n      handleDisconnect();\n    });\n    const handleDisconnect = () => {\n      onWalletDisconnect(activeWallet);\n      unsubAccounts();\n      unsubChainChanged();\n      unsubDisconnect();\n    };\n  };\n  const setActiveWallet = async activeWallet => {\n    handleSetActiveWallet(activeWallet);\n    // do not set smart wallet as last active EOA\n    if (activeWallet.id !== \"smart\") {\n      await storage.setItem(LAST_ACTIVE_EOA_ID, activeWallet.id);\n    }\n  };\n  // side effects\n  effect(() => {\n    const _chain = activeWalletChainStore.getValue();\n    if (_chain) {\n      storage.setItem(LAST_ACTIVE_CHAIN, stringify(_chain));\n    } else {\n      storage.removeItem(LAST_ACTIVE_CHAIN);\n    }\n  }, [activeWalletChainStore], false);\n  // save last connected wallet ids to storage\n  effect(async () => {\n    const prevAccounts = (await getStoredConnectedWalletIds(storage)) || [];\n    const accounts = connectedWallets.getValue();\n    const ids = accounts.map(acc => acc?.id).filter(c => !!c);\n    storage.setItem(CONNECTED_WALLET_IDS, stringify(Array.from(new Set([...prevAccounts, ...ids]))));\n  }, [connectedWallets], false);\n  const switchActiveWalletChain = async chain => {\n    const wallet = activeWalletStore.getValue();\n    if (!wallet) {\n      throw new Error(\"no wallet found\");\n    }\n    if (!wallet.switchChain) {\n      throw new Error(\"wallet does not support switching chains\");\n    }\n    if (wallet.id === \"smart\") {\n      // also switch personal wallet\n      const personalWalletId = await getStoredActiveWalletId(storage);\n      if (personalWalletId) {\n        const personalWallet = connectedWallets.getValue().find(w => w.id === personalWalletId);\n        if (personalWallet) {\n          await personalWallet.switchChain(chain);\n        }\n      }\n      await wallet.switchChain(chain);\n      // reset the active wallet as switch chain recreates a new smart account\n      handleSetActiveWallet(wallet);\n    } else {\n      await wallet.switchChain(chain);\n    }\n    // for wallets that dont implement events, just set it manually\n    activeWalletChainStore.setValue(wallet.getChain());\n  };\n  function defineChains(chains) {\n    const currentMapVal = definedChainsStore.getValue();\n    // if all chains to be defined are already defined, no need to update the definedChains map\n    const allChainsSame = chains.every(c => {\n      const definedChain = currentMapVal.get(c.id);\n      // basically a deep equal check\n      return stringify(definedChain) === stringify(c);\n    });\n    if (allChainsSame) {\n      return;\n    }\n    const newMapVal = new Map(currentMapVal);\n    for (const c of chains) {\n      newMapVal.set(c.id, c);\n    }\n    definedChainsStore.setValue(newMapVal);\n  }\n  return {\n    activeWalletStore,\n    activeAccountStore,\n    connectedWallets,\n    addConnectedWallet,\n    disconnectWallet,\n    setActiveWallet,\n    connect,\n    handleConnection,\n    activeWalletChainStore,\n    switchActiveWalletChain,\n    activeWalletConnectionStatusStore,\n    isAutoConnecting,\n    removeConnectedWallet,\n    defineChains\n  };\n}\n/**\n *\n * @internal\n */\nexport async function getStoredConnectedWalletIds(storage) {\n  try {\n    const value = await storage.getItem(CONNECTED_WALLET_IDS);\n    if (value) {\n      return JSON.parse(value);\n    }\n    return [];\n  } catch {\n    return [];\n  }\n}\n/**\n * @internal\n */\nexport async function getStoredActiveWalletId(storage) {\n  try {\n    const value = await storage.getItem(LAST_ACTIVE_EOA_ID);\n    if (value) {\n      return value;\n    }\n  } catch {}\n  return null;\n}\n/**\n * @internal\n */\nexport async function getLastConnectedChain(storage) {\n  try {\n    const value = await storage.getItem(LAST_ACTIVE_CHAIN);\n    if (value) {\n      return JSON.parse(value);\n    }\n  } catch {}\n  return null;\n}\n/**\n * @internal\n */\nexport const handleSmartWalletConnection = async (eoaWallet, client, options, onWalletDisconnect) => {\n  const signer = eoaWallet.getAccount();\n  if (!signer) {\n    throw new Error(\"Cannot set a wallet without an account as active\");\n  }\n  const wallet = smartWallet(options);\n  await wallet.connect({\n    personalAccount: signer,\n    client: client,\n    chain: options.chain\n  });\n  // Disconnect the active wallet when the EOA disconnects if it the active wallet is a smart wallet\n  const disconnectUnsub = eoaWallet.subscribe(\"disconnect\", () => {\n    handleDisconnect();\n  });\n  const handleDisconnect = () => {\n    disconnectUnsub();\n    onWalletDisconnect(wallet);\n  };\n  return wallet;\n};\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}