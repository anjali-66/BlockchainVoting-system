{"ast":null,"code":"import { getContract } from \"../../../contract/contract.js\";\nimport { prepareContractCall } from \"../../../transaction/prepare-contract-call.js\";\nimport { readContract } from \"../../../transaction/read-contract.js\";\nimport { isHex, stringToHex } from \"../../../utils/encoding/hex.js\";\nimport { DEFAULT_ACCOUNT_FACTORY_V0_6 } from \"./constants.js\";\n/**\n * Predict the address of a smart account.\n * @param args - The options for predicting the address of a smart account.\n * @returns The predicted address of the smart account.\n * @example\n * ```ts\n * import { predictSmartAccountAddress } from \"thirdweb/wallets/smart\";\n *\n * const predictedAddress = await predictSmartAccountAddress({\n *  client,\n *  chain,\n *  adminAddress,\n * });\n * ```\n * @walletUtils\n */\nexport async function predictSmartAccountAddress(args) {\n  return predictAddress({\n    adminAddress: args.adminAddress,\n    accountSalt: args.accountSalt,\n    factoryContract: getContract({\n      address: args.factoryAddress ?? DEFAULT_ACCOUNT_FACTORY_V0_6,\n      chain: args.chain,\n      client: args.client\n    })\n  });\n}\n/**\n * Predict the address of a smart account.\n * @param args - The options for predicting the address of a smart account.\n * @returns The predicted address of the smart account.\n * @example\n * ```ts\n * import { predictAddress } from \"thirdweb/wallets/smart\";\n *\n * const predictedAddress = await predictAddress({\n *  factoryContract,\n *  adminAddress,\n *  accountSalt,\n * });\n * ```\n * @walletUtils\n * @deprecated Use `predictSmartAccountAddress` instead.\n */\nexport async function predictAddress(args) {\n  const {\n    factoryContract,\n    predictAddressOverride: predictAddress,\n    adminAddress,\n    accountSalt,\n    accountAddress\n  } = args;\n  if (predictAddress) {\n    return predictAddress(factoryContract, adminAddress);\n  }\n  if (accountAddress) {\n    return accountAddress;\n  }\n  if (!adminAddress) {\n    throw new Error(\"Account address is required to predict the smart wallet address.\");\n  }\n  const saltHex = accountSalt && isHex(accountSalt) ? accountSalt : stringToHex(accountSalt ?? \"\");\n  return readContract({\n    contract: factoryContract,\n    method: \"function getAddress(address, bytes) returns (address)\",\n    params: [adminAddress, saltHex]\n  });\n}\n/**\n * @internal\n */\nexport function prepareCreateAccount(args) {\n  const {\n    adminAddress,\n    factoryContract,\n    createAccountOverride: createAccount,\n    accountSalt\n  } = args;\n  if (createAccount) {\n    return createAccount(factoryContract, adminAddress);\n  }\n  const saltHex = accountSalt && isHex(accountSalt) ? accountSalt : stringToHex(accountSalt ?? \"\");\n  return prepareContractCall({\n    contract: factoryContract,\n    method: \"function createAccount(address, bytes) returns (address)\",\n    params: [adminAddress, saltHex]\n  });\n}\n/**\n * @internal\n */\nexport function prepareExecute(args) {\n  const {\n    accountContract,\n    transaction,\n    executeOverride: execute\n  } = args;\n  if (execute) {\n    return execute(accountContract, transaction);\n  }\n  return prepareContractCall({\n    contract: accountContract,\n    method: \"function execute(address, uint256, bytes)\",\n    params: [transaction.to || \"\", transaction.value || 0n, transaction.data || \"0x\"],\n    // if gas is specified for the inner tx, use that and add 21k for the execute call on the account contract\n    // this avoids another estimateGas call when bundling the userOp\n    // and also allows for passing custom gas limits for the inner tx\n    gas: transaction.gas ? transaction.gas + 21000n : undefined\n  });\n}\n/**\n * @internal\n */\nexport function prepareBatchExecute(args) {\n  const {\n    accountContract,\n    transactions,\n    executeBatchOverride: executeBatch\n  } = args;\n  if (executeBatch) {\n    return executeBatch(accountContract, transactions);\n  }\n  return prepareContractCall({\n    contract: accountContract,\n    method: \"function executeBatch(address[], uint256[], bytes[])\",\n    params: [transactions.map(tx => tx.to || \"\"), transactions.map(tx => tx.value || 0n), transactions.map(tx => tx.data || \"0x\")]\n  });\n}\n//# sourceMappingURL=calls.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}