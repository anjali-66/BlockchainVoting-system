{"ast":null,"code":"import { secp256k1 } from '@noble/curves/secp256k1';\nimport * as Address from './Address.js';\nimport * as Bytes from './Bytes.js';\nimport * as Hex from './Hex.js';\nimport * as PublicKey from './PublicKey.js';\nimport * as Entropy from './internal/entropy.js';\n/** Re-export of noble/curves secp256k1 utilities. */\nexport const noble = secp256k1;\n/**\n * Computes the secp256k1 ECDSA public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const publicKey = Secp256k1.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */\nexport function getPublicKey(options) {\n  const {\n    privateKey\n  } = options;\n  const point = secp256k1.ProjectivePoint.fromPrivateKey(Hex.from(privateKey).slice(2));\n  return PublicKey.from(point);\n}\n/**\n * Generates a random ECDSA private key on the secp256k1 curve.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nexport function randomPrivateKey(options = {}) {\n  const {\n    as = 'Hex'\n  } = options;\n  const bytes = secp256k1.utils.randomPrivateKey();\n  if (as === 'Hex') return Hex.fromBytes(bytes);\n  return bytes;\n}\n/**\n * Recovers the signing address from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const address = Secp256k1.recoverAddress({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered address.\n */\nexport function recoverAddress(options) {\n  return Address.fromPublicKey(recoverPublicKey(options));\n}\n/**\n * Recovers the signing public key from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const publicKey = Secp256k1.recoverPublicKey({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered public key.\n */\nexport function recoverPublicKey(options) {\n  const {\n    payload,\n    signature\n  } = options;\n  const {\n    r,\n    s,\n    yParity\n  } = signature;\n  const signature_ = new secp256k1.Signature(BigInt(r), BigInt(s)).addRecoveryBit(yParity);\n  const point = signature_.recoverPublicKey(Hex.from(payload).substring(2));\n  return PublicKey.from(point);\n}\n/**\n * Signs the payload with the provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The signing options.\n * @returns The ECDSA {@link ox#Signature.Signature}.\n */\nexport function sign(options) {\n  const {\n    extraEntropy = Entropy.extraEntropy,\n    hash,\n    payload,\n    privateKey\n  } = options;\n  const {\n    r,\n    s,\n    recovery\n  } = secp256k1.sign(Bytes.from(payload), Bytes.from(privateKey), {\n    extraEntropy: typeof extraEntropy === 'boolean' ? extraEntropy : Hex.from(extraEntropy).slice(2),\n    lowS: true,\n    ...(hash ? {\n      prehash: true\n    } : {})\n  });\n  return {\n    r,\n    s,\n    yParity: recovery\n  };\n}\n/**\n * Verifies a payload was signed by the provided address.\n *\n * @example\n * ### Verify with Ethereum Address\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const verified = Secp256k1.verify({ // [!code focus]\n *   address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Verify with Public Key\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = '0x...'\n * const publicKey = Secp256k1.getPublicKey({ privateKey })\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = Secp256k1.verify({ // [!code focus]\n *   publicKey, // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided address.\n */\nexport function verify(options) {\n  const {\n    address,\n    hash,\n    payload,\n    publicKey,\n    signature\n  } = options;\n  if (address) return Address.isEqual(address, recoverAddress({\n    payload,\n    signature\n  }));\n  return secp256k1.verify(signature, Bytes.from(payload), PublicKey.toBytes(publicKey), ...(hash ? [{\n    prehash: true,\n    lowS: true\n  }] : []));\n}\n//# sourceMappingURL=Secp256k1.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}