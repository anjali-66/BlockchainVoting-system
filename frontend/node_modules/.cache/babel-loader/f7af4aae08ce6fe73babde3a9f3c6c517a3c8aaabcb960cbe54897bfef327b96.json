{"ast":null,"code":"// copy of: https://github.com/wevm/viem/blob/6cf2c3b5fe608bce9c828af867dfaa65103753a6/src/utils/promise/withCache.ts\n// with slight adjustments made to comply with our linting rules\n// TODO: explore extracting this from viem and instead having a separate general purpose library for this kind of thing\n// alternatively viem could maybe export this helpful util\n// TODO: explore using a LRU cache instead of a Map\nconst promiseCache = /*#__PURE__*/new Map();\nconst responseCache = /*#__PURE__*/new Map();\n/**\n *@internal\n */\nexport function getCache(cacheKey) {\n  const buildCache = (cacheKey_, cache) => ({\n    clear: () => cache.delete(cacheKey_),\n    get: () => cache.get(cacheKey_),\n    set: data => cache.set(cacheKey_, data)\n  });\n  const promise = buildCache(cacheKey, promiseCache);\n  const response = buildCache(cacheKey, responseCache);\n  return {\n    clear: () => {\n      promise.clear();\n      response.clear();\n    },\n    promise,\n    response\n  };\n}\n/**\n * Returns the result of a given promise, and caches the result for\n * subsequent invocations against a provided cache key.\n * @internal\n */\nexport async function withCache(fn, {\n  cacheKey,\n  cacheTime = Number.POSITIVE_INFINITY\n}) {\n  const cache = getCache(cacheKey);\n  // If a response exists in the cache, and it's not expired, return it\n  // and do not invoke the promise.\n  // If the max age is 0, the cache is disabled.\n  const response = cache.response.get();\n  if (response && cacheTime > 0) {\n    const age = new Date().getTime() - response.created.getTime();\n    if (age < cacheTime) {\n      return response.data;\n    }\n  }\n  let promise = cache.promise.get();\n  if (!promise) {\n    promise = fn();\n    // Store the promise in the cache so that subsequent invocations\n    // will wait for the same promise to resolve (deduping).\n    cache.promise.set(promise);\n  }\n  try {\n    const data = await promise;\n    // Store the response in the cache so that subsequent invocations\n    // will return the same response.\n    cache.response.set({\n      created: new Date(),\n      data\n    });\n    return data;\n  } finally {\n    // Clear the promise cache so that subsequent invocations will\n    // invoke the promise again.\n    cache.promise.clear();\n  }\n}\n//# sourceMappingURL=withCache.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}