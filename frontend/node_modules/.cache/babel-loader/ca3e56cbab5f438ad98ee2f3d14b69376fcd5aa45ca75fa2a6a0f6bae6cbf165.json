{"ast":null,"code":"import Ei, { EventEmitter as K } from \"events\";\nimport { HEARTBEAT_EVENTS as q, HeartBeat as wi } from \"@walletconnect/heartbeat\";\nimport Ii from \"@walletconnect/keyvaluestorage\";\nimport { generateChildLogger as I, getLoggerContext as S, pino as Ti, getDefaultLoggerOptions as Te, generatePlatformLogger as Ci } from \"@walletconnect/logger\";\nimport { IMessageTracker as Pi, IPublisher as Si, ISubscriber as Ri, IRelayer as xi, IStore as Oi, IJsonRpcHistory as Ai, IExpirer as Ni, IVerify as zi, IEchoClient as Li, IEventClient as $i, ICore as ki } from \"@walletconnect/types\";\nimport { ONE_DAY as B, SIX_HOURS as Ui, THIRTY_DAYS as te, FIVE_SECONDS as ae, THIRTY_SECONDS as ce, toMiliseconds as E, ONE_MINUTE as Ce, ONE_SECOND as F, Watch as Fi, FIVE_MINUTES as he, fromMiliseconds as Pe } from \"@walletconnect/time\";\nimport { safeJsonStringify as Mi, safeJsonParse as Se } from \"@walletconnect/safe-json\";\nimport * as ie from \"@walletconnect/relay-auth\";\nimport { decodeJWT as Re } from \"@walletconnect/relay-auth\";\nimport { getInternalError as p, mapToObj as xe, objToMap as Oe, generateRandomBytes32 as le, generateKeyPair as Ki, deriveSymKey as Bi, hashKey as Vi, validateEncoding as ji, isTypeTwoEnvelope as Ae, encodeTypeTwoEnvelope as qi, isTypeOneEnvelope as Ne, encrypt as Gi, validateDecoding as Hi, decodeTypeTwoEnvelope as Yi, decrypt as Ji, deserialize as ze, decodeTypeByte as Xi, BASE64 as Le, BASE16 as Wi, hashMessage as ue, getRelayProtocolName as se, createExpiringPromise as U, getRelayProtocolApi as G, isUndefined as de, getSdkError as H, sleep as Zi, isNode as $e, isAndroid as Qi, getAppId as ke, isIos as es, isOnline as Ue, calcExpiry as Y, formatRelayRpcUrl as ts, subscribeToNetworkChange as is, isProposalStruct as ss, isSessionStruct as rs, TYPE_1 as ns, formatUri as Fe, parseUri as Me, createDelayedPromise as os, engineEvent as pe, isExpired as Ke, isValidParams as ge, isValidUrl as as, isValidString as cs, parseExpirerTarget as hs, formatTopicTarget as ls, formatIdTarget as us, isBrowser as ds, verifyP256Jwt as ps, isTestRun as Be, uuidv4 as Ve, formatUA as gs, getAppMetadata as ys } from \"@walletconnect/utils\";\nimport { toString as Ds } from \"uint8arrays\";\nimport { JsonRpcProvider as ms } from \"@walletconnect/jsonrpc-provider\";\nimport { getBigIntRpcId as je, isJsonRpcRequest as qe, isJsonRpcResponse as Ge, formatJsonRpcResult as He, formatJsonRpcRequest as Ye, formatJsonRpcError as bs, isJsonRpcResult as fs, isJsonRpcError as Je } from \"@walletconnect/jsonrpc-utils\";\nimport vs from \"@walletconnect/jsonrpc-ws-connection\";\nimport _s from \"lodash.isequal\";\nimport { getDocument as Es } from \"@walletconnect/window-getters\";\nconst ye = \"wc\",\n  De = 2,\n  J = \"core\",\n  A = `${ye}@2:${J}:`,\n  Xe = {\n    name: J,\n    logger: \"error\"\n  },\n  We = {\n    database: \":memory:\"\n  },\n  Ze = \"crypto\",\n  me = \"client_ed25519_seed\",\n  Qe = B,\n  et = \"keychain\",\n  tt = \"0.3\",\n  it = \"messages\",\n  st = \"0.3\",\n  be = Ui,\n  rt = \"publisher\",\n  nt = \"irn\",\n  ot = \"error\",\n  fe = \"wss://relay.walletconnect.org\",\n  at = \"relayer\",\n  v = {\n    message: \"relayer_message\",\n    message_ack: \"relayer_message_ack\",\n    connect: \"relayer_connect\",\n    disconnect: \"relayer_disconnect\",\n    error: \"relayer_error\",\n    connection_stalled: \"relayer_connection_stalled\",\n    transport_closed: \"relayer_transport_closed\",\n    publish: \"relayer_publish\"\n  },\n  ct = \"_subscription\",\n  C = {\n    payload: \"payload\",\n    connect: \"connect\",\n    disconnect: \"disconnect\",\n    error: \"error\"\n  },\n  ht = .1,\n  ws = {\n    database: \":memory:\"\n  },\n  re = \"2.17.3\",\n  Is = 1e4,\n  M = {\n    link_mode: \"link_mode\",\n    relay: \"relay\"\n  },\n  lt = \"0.3\",\n  ut = \"WALLETCONNECT_CLIENT_ID\",\n  ve = \"WALLETCONNECT_LINK_MODE_APPS\",\n  T = {\n    created: \"subscription_created\",\n    deleted: \"subscription_deleted\",\n    expired: \"subscription_expired\",\n    disabled: \"subscription_disabled\",\n    sync: \"subscription_sync\",\n    resubscribed: \"subscription_resubscribed\"\n  },\n  Ts = te,\n  dt = \"subscription\",\n  pt = \"0.3\",\n  gt = ae * 1e3,\n  yt = \"pairing\",\n  Dt = \"0.3\",\n  Cs = te,\n  V = {\n    wc_pairingDelete: {\n      req: {\n        ttl: B,\n        prompt: !1,\n        tag: 1e3\n      },\n      res: {\n        ttl: B,\n        prompt: !1,\n        tag: 1001\n      }\n    },\n    wc_pairingPing: {\n      req: {\n        ttl: ce,\n        prompt: !1,\n        tag: 1002\n      },\n      res: {\n        ttl: ce,\n        prompt: !1,\n        tag: 1003\n      }\n    },\n    unregistered_method: {\n      req: {\n        ttl: B,\n        prompt: !1,\n        tag: 0\n      },\n      res: {\n        ttl: B,\n        prompt: !1,\n        tag: 0\n      }\n    }\n  },\n  j = {\n    create: \"pairing_create\",\n    expire: \"pairing_expire\",\n    delete: \"pairing_delete\",\n    ping: \"pairing_ping\"\n  },\n  R = {\n    created: \"history_created\",\n    updated: \"history_updated\",\n    deleted: \"history_deleted\",\n    sync: \"history_sync\"\n  },\n  mt = \"history\",\n  bt = \"0.3\",\n  ft = \"expirer\",\n  x = {\n    created: \"expirer_created\",\n    deleted: \"expirer_deleted\",\n    expired: \"expirer_expired\",\n    sync: \"expirer_sync\"\n  },\n  vt = \"0.3\",\n  Ps = B,\n  _t = \"verify-api\",\n  Ss = \"https://verify.walletconnect.com\",\n  Et = \"https://verify.walletconnect.org\",\n  X = Et,\n  wt = `${X}/v3`,\n  It = [Ss, Et],\n  Tt = \"echo\",\n  Ct = \"https://echo.walletconnect.com\",\n  Rs = \"event-client\",\n  z = {\n    pairing_started: \"pairing_started\",\n    pairing_uri_validation_success: \"pairing_uri_validation_success\",\n    pairing_uri_not_expired: \"pairing_uri_not_expired\",\n    store_new_pairing: \"store_new_pairing\",\n    subscribing_pairing_topic: \"subscribing_pairing_topic\",\n    subscribe_pairing_topic_success: \"subscribe_pairing_topic_success\",\n    existing_pairing: \"existing_pairing\",\n    pairing_not_expired: \"pairing_not_expired\",\n    emit_inactive_pairing: \"emit_inactive_pairing\",\n    emit_session_proposal: \"emit_session_proposal\",\n    subscribing_to_pairing_topic: \"subscribing_to_pairing_topic\"\n  },\n  $ = {\n    no_wss_connection: \"no_wss_connection\",\n    no_internet_connection: \"no_internet_connection\",\n    malformed_pairing_uri: \"malformed_pairing_uri\",\n    active_pairing_already_exists: \"active_pairing_already_exists\",\n    subscribe_pairing_topic_failure: \"subscribe_pairing_topic_failure\",\n    pairing_expired: \"pairing_expired\",\n    proposal_expired: \"proposal_expired\",\n    proposal_listener_not_found: \"proposal_listener_not_found\"\n  },\n  xs = {\n    session_approve_started: \"session_approve_started\",\n    proposal_not_expired: \"proposal_not_expired\",\n    session_namespaces_validation_success: \"session_namespaces_validation_success\",\n    create_session_topic: \"create_session_topic\",\n    subscribing_session_topic: \"subscribing_session_topic\",\n    subscribe_session_topic_success: \"subscribe_session_topic_success\",\n    publishing_session_approve: \"publishing_session_approve\",\n    session_approve_publish_success: \"session_approve_publish_success\",\n    store_session: \"store_session\",\n    publishing_session_settle: \"publishing_session_settle\",\n    session_settle_publish_success: \"session_settle_publish_success\"\n  },\n  Os = {\n    no_internet_connection: \"no_internet_connection\",\n    no_wss_connection: \"no_wss_connection\",\n    proposal_expired: \"proposal_expired\",\n    subscribe_session_topic_failure: \"subscribe_session_topic_failure\",\n    session_approve_publish_failure: \"session_approve_publish_failure\",\n    session_settle_publish_failure: \"session_settle_publish_failure\",\n    session_approve_namespace_validation_failure: \"session_approve_namespace_validation_failure\",\n    proposal_not_found: \"proposal_not_found\"\n  },\n  As = {\n    authenticated_session_approve_started: \"authenticated_session_approve_started\",\n    authenticated_session_not_expired: \"authenticated_session_not_expired\",\n    chains_caip2_compliant: \"chains_caip2_compliant\",\n    chains_evm_compliant: \"chains_evm_compliant\",\n    create_authenticated_session_topic: \"create_authenticated_session_topic\",\n    cacaos_verified: \"cacaos_verified\",\n    store_authenticated_session: \"store_authenticated_session\",\n    subscribing_authenticated_session_topic: \"subscribing_authenticated_session_topic\",\n    subscribe_authenticated_session_topic_success: \"subscribe_authenticated_session_topic_success\",\n    publishing_authenticated_session_approve: \"publishing_authenticated_session_approve\",\n    authenticated_session_approve_publish_success: \"authenticated_session_approve_publish_success\"\n  },\n  Ns = {\n    no_internet_connection: \"no_internet_connection\",\n    no_wss_connection: \"no_wss_connection\",\n    missing_session_authenticate_request: \"missing_session_authenticate_request\",\n    session_authenticate_request_expired: \"session_authenticate_request_expired\",\n    chains_caip2_compliant_failure: \"chains_caip2_compliant_failure\",\n    chains_evm_compliant_failure: \"chains_evm_compliant_failure\",\n    invalid_cacao: \"invalid_cacao\",\n    subscribe_authenticated_session_topic_failure: \"subscribe_authenticated_session_topic_failure\",\n    authenticated_session_approve_publish_failure: \"authenticated_session_approve_publish_failure\",\n    authenticated_session_pending_request_not_found: \"authenticated_session_pending_request_not_found\"\n  },\n  Pt = .1,\n  St = \"event-client\",\n  Rt = 86400,\n  xt = \"https://pulse.walletconnect.org/batch\";\nfunction zs(o, e) {\n  if (o.length >= 255) throw new TypeError(\"Alphabet too long\");\n  for (var t = new Uint8Array(256), s = 0; s < t.length; s++) t[s] = 255;\n  for (var i = 0; i < o.length; i++) {\n    var r = o.charAt(i),\n      n = r.charCodeAt(0);\n    if (t[n] !== 255) throw new TypeError(r + \" is ambiguous\");\n    t[n] = i;\n  }\n  var a = o.length,\n    c = o.charAt(0),\n    h = Math.log(a) / Math.log(256),\n    u = Math.log(256) / Math.log(a);\n  function d(l) {\n    if (l instanceof Uint8Array || (ArrayBuffer.isView(l) ? l = new Uint8Array(l.buffer, l.byteOffset, l.byteLength) : Array.isArray(l) && (l = Uint8Array.from(l))), !(l instanceof Uint8Array)) throw new TypeError(\"Expected Uint8Array\");\n    if (l.length === 0) return \"\";\n    for (var g = 0, w = 0, b = 0, D = l.length; b !== D && l[b] === 0;) b++, g++;\n    for (var P = (D - b) * u + 1 >>> 0, f = new Uint8Array(P); b !== D;) {\n      for (var N = l[b], k = 0, O = P - 1; (N !== 0 || k < w) && O !== -1; O--, k++) N += 256 * f[O] >>> 0, f[O] = N % a >>> 0, N = N / a >>> 0;\n      if (N !== 0) throw new Error(\"Non-zero carry\");\n      w = k, b++;\n    }\n    for (var L = P - w; L !== P && f[L] === 0;) L++;\n    for (var ee = c.repeat(g); L < P; ++L) ee += o.charAt(f[L]);\n    return ee;\n  }\n  function y(l) {\n    if (typeof l != \"string\") throw new TypeError(\"Expected String\");\n    if (l.length === 0) return new Uint8Array();\n    var g = 0;\n    if (l[g] !== \" \") {\n      for (var w = 0, b = 0; l[g] === c;) w++, g++;\n      for (var D = (l.length - g) * h + 1 >>> 0, P = new Uint8Array(D); l[g];) {\n        var f = t[l.charCodeAt(g)];\n        if (f === 255) return;\n        for (var N = 0, k = D - 1; (f !== 0 || N < b) && k !== -1; k--, N++) f += a * P[k] >>> 0, P[k] = f % 256 >>> 0, f = f / 256 >>> 0;\n        if (f !== 0) throw new Error(\"Non-zero carry\");\n        b = N, g++;\n      }\n      if (l[g] !== \" \") {\n        for (var O = D - b; O !== D && P[O] === 0;) O++;\n        for (var L = new Uint8Array(w + (D - O)), ee = w; O !== D;) L[ee++] = P[O++];\n        return L;\n      }\n    }\n  }\n  function m(l) {\n    var g = y(l);\n    if (g) return g;\n    throw new Error(`Non-${e} character`);\n  }\n  return {\n    encode: d,\n    decodeUnsafe: y,\n    decode: m\n  };\n}\nvar Ls = zs,\n  $s = Ls;\nconst Ot = o => {\n    if (o instanceof Uint8Array && o.constructor.name === \"Uint8Array\") return o;\n    if (o instanceof ArrayBuffer) return new Uint8Array(o);\n    if (ArrayBuffer.isView(o)) return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);\n    throw new Error(\"Unknown type, must be binary type\");\n  },\n  ks = o => new TextEncoder().encode(o),\n  Us = o => new TextDecoder().decode(o);\nclass Fs {\n  constructor(e, t, s) {\n    this.name = e, this.prefix = t, this.baseEncode = s;\n  }\n  encode(e) {\n    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;\n    throw Error(\"Unknown type, must be binary type\");\n  }\n}\nclass Ms {\n  constructor(e, t, s) {\n    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error(\"Invalid prefix character\");\n    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = s;\n  }\n  decode(e) {\n    if (typeof e == \"string\") {\n      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n      return this.baseDecode(e.slice(this.prefix.length));\n    } else throw Error(\"Can only multibase decode strings\");\n  }\n  or(e) {\n    return At(this, e);\n  }\n}\nclass Ks {\n  constructor(e) {\n    this.decoders = e;\n  }\n  or(e) {\n    return At(this, e);\n  }\n  decode(e) {\n    const t = e[0],\n      s = this.decoders[t];\n    if (s) return s.decode(e);\n    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n  }\n}\nconst At = (o, e) => new Ks({\n  ...(o.decoders || {\n    [o.prefix]: o\n  }),\n  ...(e.decoders || {\n    [e.prefix]: e\n  })\n});\nclass Bs {\n  constructor(e, t, s, i) {\n    this.name = e, this.prefix = t, this.baseEncode = s, this.baseDecode = i, this.encoder = new Fs(e, t, s), this.decoder = new Ms(e, t, i);\n  }\n  encode(e) {\n    return this.encoder.encode(e);\n  }\n  decode(e) {\n    return this.decoder.decode(e);\n  }\n}\nconst ne = ({\n    name: o,\n    prefix: e,\n    encode: t,\n    decode: s\n  }) => new Bs(o, e, t, s),\n  W = ({\n    prefix: o,\n    name: e,\n    alphabet: t\n  }) => {\n    const {\n      encode: s,\n      decode: i\n    } = $s(t, e);\n    return ne({\n      prefix: o,\n      name: e,\n      encode: s,\n      decode: r => Ot(i(r))\n    });\n  },\n  Vs = (o, e, t, s) => {\n    const i = {};\n    for (let u = 0; u < e.length; ++u) i[e[u]] = u;\n    let r = o.length;\n    for (; o[r - 1] === \"=\";) --r;\n    const n = new Uint8Array(r * t / 8 | 0);\n    let a = 0,\n      c = 0,\n      h = 0;\n    for (let u = 0; u < r; ++u) {\n      const d = i[o[u]];\n      if (d === void 0) throw new SyntaxError(`Non-${s} character`);\n      c = c << t | d, a += t, a >= 8 && (a -= 8, n[h++] = 255 & c >> a);\n    }\n    if (a >= t || 255 & c << 8 - a) throw new SyntaxError(\"Unexpected end of data\");\n    return n;\n  },\n  js = (o, e, t) => {\n    const s = e[e.length - 1] === \"=\",\n      i = (1 << t) - 1;\n    let r = \"\",\n      n = 0,\n      a = 0;\n    for (let c = 0; c < o.length; ++c) for (a = a << 8 | o[c], n += 8; n > t;) n -= t, r += e[i & a >> n];\n    if (n && (r += e[i & a << t - n]), s) for (; r.length * t & 7;) r += \"=\";\n    return r;\n  },\n  _ = ({\n    name: o,\n    prefix: e,\n    bitsPerChar: t,\n    alphabet: s\n  }) => ne({\n    prefix: e,\n    name: o,\n    encode(i) {\n      return js(i, s, t);\n    },\n    decode(i) {\n      return Vs(i, s, t, o);\n    }\n  }),\n  qs = ne({\n    prefix: \"\\0\",\n    name: \"identity\",\n    encode: o => Us(o),\n    decode: o => ks(o)\n  });\nvar Gs = Object.freeze({\n  __proto__: null,\n  identity: qs\n});\nconst Hs = _({\n  prefix: \"0\",\n  name: \"base2\",\n  alphabet: \"01\",\n  bitsPerChar: 1\n});\nvar Ys = Object.freeze({\n  __proto__: null,\n  base2: Hs\n});\nconst Js = _({\n  prefix: \"7\",\n  name: \"base8\",\n  alphabet: \"01234567\",\n  bitsPerChar: 3\n});\nvar Xs = Object.freeze({\n  __proto__: null,\n  base8: Js\n});\nconst Ws = W({\n  prefix: \"9\",\n  name: \"base10\",\n  alphabet: \"0123456789\"\n});\nvar Zs = Object.freeze({\n  __proto__: null,\n  base10: Ws\n});\nconst Qs = _({\n    prefix: \"f\",\n    name: \"base16\",\n    alphabet: \"0123456789abcdef\",\n    bitsPerChar: 4\n  }),\n  er = _({\n    prefix: \"F\",\n    name: \"base16upper\",\n    alphabet: \"0123456789ABCDEF\",\n    bitsPerChar: 4\n  });\nvar tr = Object.freeze({\n  __proto__: null,\n  base16: Qs,\n  base16upper: er\n});\nconst ir = _({\n    prefix: \"b\",\n    name: \"base32\",\n    alphabet: \"abcdefghijklmnopqrstuvwxyz234567\",\n    bitsPerChar: 5\n  }),\n  sr = _({\n    prefix: \"B\",\n    name: \"base32upper\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n    bitsPerChar: 5\n  }),\n  rr = _({\n    prefix: \"c\",\n    name: \"base32pad\",\n    alphabet: \"abcdefghijklmnopqrstuvwxyz234567=\",\n    bitsPerChar: 5\n  }),\n  nr = _({\n    prefix: \"C\",\n    name: \"base32padupper\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=\",\n    bitsPerChar: 5\n  }),\n  or = _({\n    prefix: \"v\",\n    name: \"base32hex\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuv\",\n    bitsPerChar: 5\n  }),\n  ar = _({\n    prefix: \"V\",\n    name: \"base32hexupper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\",\n    bitsPerChar: 5\n  }),\n  cr = _({\n    prefix: \"t\",\n    name: \"base32hexpad\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuv=\",\n    bitsPerChar: 5\n  }),\n  hr = _({\n    prefix: \"T\",\n    name: \"base32hexpadupper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV=\",\n    bitsPerChar: 5\n  }),\n  lr = _({\n    prefix: \"h\",\n    name: \"base32z\",\n    alphabet: \"ybndrfg8ejkmcpqxot1uwisza345h769\",\n    bitsPerChar: 5\n  });\nvar ur = Object.freeze({\n  __proto__: null,\n  base32: ir,\n  base32upper: sr,\n  base32pad: rr,\n  base32padupper: nr,\n  base32hex: or,\n  base32hexupper: ar,\n  base32hexpad: cr,\n  base32hexpadupper: hr,\n  base32z: lr\n});\nconst dr = W({\n    prefix: \"k\",\n    name: \"base36\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuvwxyz\"\n  }),\n  pr = W({\n    prefix: \"K\",\n    name: \"base36upper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  });\nvar gr = Object.freeze({\n  __proto__: null,\n  base36: dr,\n  base36upper: pr\n});\nconst yr = W({\n    name: \"base58btc\",\n    prefix: \"z\",\n    alphabet: \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n  }),\n  Dr = W({\n    name: \"base58flickr\",\n    prefix: \"Z\",\n    alphabet: \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\"\n  });\nvar mr = Object.freeze({\n  __proto__: null,\n  base58btc: yr,\n  base58flickr: Dr\n});\nconst br = _({\n    prefix: \"m\",\n    name: \"base64\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n    bitsPerChar: 6\n  }),\n  fr = _({\n    prefix: \"M\",\n    name: \"base64pad\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n    bitsPerChar: 6\n  }),\n  vr = _({\n    prefix: \"u\",\n    name: \"base64url\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\",\n    bitsPerChar: 6\n  }),\n  _r = _({\n    prefix: \"U\",\n    name: \"base64urlpad\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\",\n    bitsPerChar: 6\n  });\nvar Er = Object.freeze({\n  __proto__: null,\n  base64: br,\n  base64pad: fr,\n  base64url: vr,\n  base64urlpad: _r\n});\nconst Nt = Array.from(\"\\u{1F680}\\u{1FA90}\\u2604\\u{1F6F0}\\u{1F30C}\\u{1F311}\\u{1F312}\\u{1F313}\\u{1F314}\\u{1F315}\\u{1F316}\\u{1F317}\\u{1F318}\\u{1F30D}\\u{1F30F}\\u{1F30E}\\u{1F409}\\u2600\\u{1F4BB}\\u{1F5A5}\\u{1F4BE}\\u{1F4BF}\\u{1F602}\\u2764\\u{1F60D}\\u{1F923}\\u{1F60A}\\u{1F64F}\\u{1F495}\\u{1F62D}\\u{1F618}\\u{1F44D}\\u{1F605}\\u{1F44F}\\u{1F601}\\u{1F525}\\u{1F970}\\u{1F494}\\u{1F496}\\u{1F499}\\u{1F622}\\u{1F914}\\u{1F606}\\u{1F644}\\u{1F4AA}\\u{1F609}\\u263A\\u{1F44C}\\u{1F917}\\u{1F49C}\\u{1F614}\\u{1F60E}\\u{1F607}\\u{1F339}\\u{1F926}\\u{1F389}\\u{1F49E}\\u270C\\u2728\\u{1F937}\\u{1F631}\\u{1F60C}\\u{1F338}\\u{1F64C}\\u{1F60B}\\u{1F497}\\u{1F49A}\\u{1F60F}\\u{1F49B}\\u{1F642}\\u{1F493}\\u{1F929}\\u{1F604}\\u{1F600}\\u{1F5A4}\\u{1F603}\\u{1F4AF}\\u{1F648}\\u{1F447}\\u{1F3B6}\\u{1F612}\\u{1F92D}\\u2763\\u{1F61C}\\u{1F48B}\\u{1F440}\\u{1F62A}\\u{1F611}\\u{1F4A5}\\u{1F64B}\\u{1F61E}\\u{1F629}\\u{1F621}\\u{1F92A}\\u{1F44A}\\u{1F973}\\u{1F625}\\u{1F924}\\u{1F449}\\u{1F483}\\u{1F633}\\u270B\\u{1F61A}\\u{1F61D}\\u{1F634}\\u{1F31F}\\u{1F62C}\\u{1F643}\\u{1F340}\\u{1F337}\\u{1F63B}\\u{1F613}\\u2B50\\u2705\\u{1F97A}\\u{1F308}\\u{1F608}\\u{1F918}\\u{1F4A6}\\u2714\\u{1F623}\\u{1F3C3}\\u{1F490}\\u2639\\u{1F38A}\\u{1F498}\\u{1F620}\\u261D\\u{1F615}\\u{1F33A}\\u{1F382}\\u{1F33B}\\u{1F610}\\u{1F595}\\u{1F49D}\\u{1F64A}\\u{1F639}\\u{1F5E3}\\u{1F4AB}\\u{1F480}\\u{1F451}\\u{1F3B5}\\u{1F91E}\\u{1F61B}\\u{1F534}\\u{1F624}\\u{1F33C}\\u{1F62B}\\u26BD\\u{1F919}\\u2615\\u{1F3C6}\\u{1F92B}\\u{1F448}\\u{1F62E}\\u{1F646}\\u{1F37B}\\u{1F343}\\u{1F436}\\u{1F481}\\u{1F632}\\u{1F33F}\\u{1F9E1}\\u{1F381}\\u26A1\\u{1F31E}\\u{1F388}\\u274C\\u270A\\u{1F44B}\\u{1F630}\\u{1F928}\\u{1F636}\\u{1F91D}\\u{1F6B6}\\u{1F4B0}\\u{1F353}\\u{1F4A2}\\u{1F91F}\\u{1F641}\\u{1F6A8}\\u{1F4A8}\\u{1F92C}\\u2708\\u{1F380}\\u{1F37A}\\u{1F913}\\u{1F619}\\u{1F49F}\\u{1F331}\\u{1F616}\\u{1F476}\\u{1F974}\\u25B6\\u27A1\\u2753\\u{1F48E}\\u{1F4B8}\\u2B07\\u{1F628}\\u{1F31A}\\u{1F98B}\\u{1F637}\\u{1F57A}\\u26A0\\u{1F645}\\u{1F61F}\\u{1F635}\\u{1F44E}\\u{1F932}\\u{1F920}\\u{1F927}\\u{1F4CC}\\u{1F535}\\u{1F485}\\u{1F9D0}\\u{1F43E}\\u{1F352}\\u{1F617}\\u{1F911}\\u{1F30A}\\u{1F92F}\\u{1F437}\\u260E\\u{1F4A7}\\u{1F62F}\\u{1F486}\\u{1F446}\\u{1F3A4}\\u{1F647}\\u{1F351}\\u2744\\u{1F334}\\u{1F4A3}\\u{1F438}\\u{1F48C}\\u{1F4CD}\\u{1F940}\\u{1F922}\\u{1F445}\\u{1F4A1}\\u{1F4A9}\\u{1F450}\\u{1F4F8}\\u{1F47B}\\u{1F910}\\u{1F92E}\\u{1F3BC}\\u{1F975}\\u{1F6A9}\\u{1F34E}\\u{1F34A}\\u{1F47C}\\u{1F48D}\\u{1F4E3}\\u{1F942}\"),\n  wr = Nt.reduce((o, e, t) => (o[t] = e, o), []),\n  Ir = Nt.reduce((o, e, t) => (o[e.codePointAt(0)] = t, o), []);\nfunction Tr(o) {\n  return o.reduce((e, t) => (e += wr[t], e), \"\");\n}\nfunction Cr(o) {\n  const e = [];\n  for (const t of o) {\n    const s = Ir[t.codePointAt(0)];\n    if (s === void 0) throw new Error(`Non-base256emoji character: ${t}`);\n    e.push(s);\n  }\n  return new Uint8Array(e);\n}\nconst Pr = ne({\n  prefix: \"\\u{1F680}\",\n  name: \"base256emoji\",\n  encode: Tr,\n  decode: Cr\n});\nvar Sr = Object.freeze({\n    __proto__: null,\n    base256emoji: Pr\n  }),\n  Rr = Lt,\n  zt = 128,\n  xr = 127,\n  Or = ~xr,\n  Ar = Math.pow(2, 31);\nfunction Lt(o, e, t) {\n  e = e || [], t = t || 0;\n  for (var s = t; o >= Ar;) e[t++] = o & 255 | zt, o /= 128;\n  for (; o & Or;) e[t++] = o & 255 | zt, o >>>= 7;\n  return e[t] = o | 0, Lt.bytes = t - s + 1, e;\n}\nvar Nr = _e,\n  zr = 128,\n  $t = 127;\nfunction _e(o, s) {\n  var t = 0,\n    s = s || 0,\n    i = 0,\n    r = s,\n    n,\n    a = o.length;\n  do {\n    if (r >= a) throw _e.bytes = 0, new RangeError(\"Could not decode varint\");\n    n = o[r++], t += i < 28 ? (n & $t) << i : (n & $t) * Math.pow(2, i), i += 7;\n  } while (n >= zr);\n  return _e.bytes = r - s, t;\n}\nvar Lr = Math.pow(2, 7),\n  $r = Math.pow(2, 14),\n  kr = Math.pow(2, 21),\n  Ur = Math.pow(2, 28),\n  Fr = Math.pow(2, 35),\n  Mr = Math.pow(2, 42),\n  Kr = Math.pow(2, 49),\n  Br = Math.pow(2, 56),\n  Vr = Math.pow(2, 63),\n  jr = function (o) {\n    return o < Lr ? 1 : o < $r ? 2 : o < kr ? 3 : o < Ur ? 4 : o < Fr ? 5 : o < Mr ? 6 : o < Kr ? 7 : o < Br ? 8 : o < Vr ? 9 : 10;\n  },\n  qr = {\n    encode: Rr,\n    decode: Nr,\n    encodingLength: jr\n  },\n  kt = qr;\nconst Ut = (o, e, t = 0) => (kt.encode(o, e, t), e),\n  Ft = o => kt.encodingLength(o),\n  Ee = (o, e) => {\n    const t = e.byteLength,\n      s = Ft(o),\n      i = s + Ft(t),\n      r = new Uint8Array(i + t);\n    return Ut(o, r, 0), Ut(t, r, s), r.set(e, i), new Gr(o, t, e, r);\n  };\nclass Gr {\n  constructor(e, t, s, i) {\n    this.code = e, this.size = t, this.digest = s, this.bytes = i;\n  }\n}\nconst Mt = ({\n  name: o,\n  code: e,\n  encode: t\n}) => new Hr(o, e, t);\nclass Hr {\n  constructor(e, t, s) {\n    this.name = e, this.code = t, this.encode = s;\n  }\n  digest(e) {\n    if (e instanceof Uint8Array) {\n      const t = this.encode(e);\n      return t instanceof Uint8Array ? Ee(this.code, t) : t.then(s => Ee(this.code, s));\n    } else throw Error(\"Unknown type, must be binary type\");\n  }\n}\nconst Kt = o => async e => new Uint8Array(await crypto.subtle.digest(o, e)),\n  Yr = Mt({\n    name: \"sha2-256\",\n    code: 18,\n    encode: Kt(\"SHA-256\")\n  }),\n  Jr = Mt({\n    name: \"sha2-512\",\n    code: 19,\n    encode: Kt(\"SHA-512\")\n  });\nvar Xr = Object.freeze({\n  __proto__: null,\n  sha256: Yr,\n  sha512: Jr\n});\nconst Bt = 0,\n  Wr = \"identity\",\n  Vt = Ot,\n  Zr = o => Ee(Bt, Vt(o)),\n  Qr = {\n    code: Bt,\n    name: Wr,\n    encode: Vt,\n    digest: Zr\n  };\nvar en = Object.freeze({\n  __proto__: null,\n  identity: Qr\n});\nnew TextEncoder(), new TextDecoder();\nconst jt = {\n  ...Gs,\n  ...Ys,\n  ...Xs,\n  ...Zs,\n  ...tr,\n  ...ur,\n  ...gr,\n  ...mr,\n  ...Er,\n  ...Sr\n};\n({\n  ...Xr,\n  ...en\n});\nfunction tn(o = 0) {\n  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(o) : new Uint8Array(o);\n}\nfunction qt(o, e, t, s) {\n  return {\n    name: o,\n    prefix: e,\n    encoder: {\n      name: o,\n      prefix: e,\n      encode: t\n    },\n    decoder: {\n      decode: s\n    }\n  };\n}\nconst Gt = qt(\"utf8\", \"u\", o => \"u\" + new TextDecoder(\"utf8\").decode(o), o => new TextEncoder().encode(o.substring(1))),\n  we = qt(\"ascii\", \"a\", o => {\n    let e = \"a\";\n    for (let t = 0; t < o.length; t++) e += String.fromCharCode(o[t]);\n    return e;\n  }, o => {\n    o = o.substring(1);\n    const e = tn(o.length);\n    for (let t = 0; t < o.length; t++) e[t] = o.charCodeAt(t);\n    return e;\n  }),\n  sn = {\n    utf8: Gt,\n    \"utf-8\": Gt,\n    hex: jt.base16,\n    latin1: we,\n    ascii: we,\n    binary: we,\n    ...jt\n  };\nfunction rn(o, e = \"utf8\") {\n  const t = sn[e];\n  if (!t) throw new Error(`Unsupported encoding \"${e}\"`);\n  return (e === \"utf8\" || e === \"utf-8\") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(o, \"utf8\") : t.decoder.decode(`${t.prefix}${o}`);\n}\nclass Ht {\n  constructor(e, t) {\n    this.core = e, this.logger = t, this.keychain = new Map(), this.name = et, this.version = tt, this.initialized = !1, this.storagePrefix = A, this.init = async () => {\n      if (!this.initialized) {\n        const s = await this.getKeyChain();\n        typeof s < \"u\" && (this.keychain = s), this.initialized = !0;\n      }\n    }, this.has = s => (this.isInitialized(), this.keychain.has(s)), this.set = async (s, i) => {\n      this.isInitialized(), this.keychain.set(s, i), await this.persist();\n    }, this.get = s => {\n      this.isInitialized();\n      const i = this.keychain.get(s);\n      if (typeof i > \"u\") {\n        const {\n          message: r\n        } = p(\"NO_MATCHING_KEY\", `${this.name}: ${s}`);\n        throw new Error(r);\n      }\n      return i;\n    }, this.del = async s => {\n      this.isInitialized(), this.keychain.delete(s), await this.persist();\n    }, this.core = e, this.logger = I(t, this.name);\n  }\n  get context() {\n    return S(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n  async setKeyChain(e) {\n    await this.core.storage.setItem(this.storageKey, xe(e));\n  }\n  async getKeyChain() {\n    const e = await this.core.storage.getItem(this.storageKey);\n    return typeof e < \"u\" ? Oe(e) : void 0;\n  }\n  async persist() {\n    await this.setKeyChain(this.keychain);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = p(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass Yt {\n  constructor(e, t, s) {\n    this.core = e, this.logger = t, this.name = Ze, this.randomSessionIdentifier = le(), this.initialized = !1, this.init = async () => {\n      this.initialized || (await this.keychain.init(), this.initialized = !0);\n    }, this.hasKeys = i => (this.isInitialized(), this.keychain.has(i)), this.getClientId = async () => {\n      this.isInitialized();\n      const i = await this.getClientSeed(),\n        r = ie.generateKeyPair(i);\n      return ie.encodeIss(r.publicKey);\n    }, this.generateKeyPair = () => {\n      this.isInitialized();\n      const i = Ki();\n      return this.setPrivateKey(i.publicKey, i.privateKey);\n    }, this.signJWT = async i => {\n      this.isInitialized();\n      const r = await this.getClientSeed(),\n        n = ie.generateKeyPair(r),\n        a = this.randomSessionIdentifier,\n        c = Qe;\n      return await ie.signJWT(a, i, c, n);\n    }, this.generateSharedKey = (i, r, n) => {\n      this.isInitialized();\n      const a = this.getPrivateKey(i),\n        c = Bi(a, r);\n      return this.setSymKey(c, n);\n    }, this.setSymKey = async (i, r) => {\n      this.isInitialized();\n      const n = r || Vi(i);\n      return await this.keychain.set(n, i), n;\n    }, this.deleteKeyPair = async i => {\n      this.isInitialized(), await this.keychain.del(i);\n    }, this.deleteSymKey = async i => {\n      this.isInitialized(), await this.keychain.del(i);\n    }, this.encode = async (i, r, n) => {\n      this.isInitialized();\n      const a = ji(n),\n        c = Mi(r);\n      if (Ae(a)) return qi(c, n?.encoding);\n      if (Ne(a)) {\n        const y = a.senderPublicKey,\n          m = a.receiverPublicKey;\n        i = await this.generateSharedKey(y, m);\n      }\n      const h = this.getSymKey(i),\n        {\n          type: u,\n          senderPublicKey: d\n        } = a;\n      return Gi({\n        type: u,\n        symKey: h,\n        message: c,\n        senderPublicKey: d,\n        encoding: n?.encoding\n      });\n    }, this.decode = async (i, r, n) => {\n      this.isInitialized();\n      const a = Hi(r, n);\n      if (Ae(a)) {\n        const c = Yi(r, n?.encoding);\n        return Se(c);\n      }\n      if (Ne(a)) {\n        const c = a.receiverPublicKey,\n          h = a.senderPublicKey;\n        i = await this.generateSharedKey(c, h);\n      }\n      try {\n        const c = this.getSymKey(i),\n          h = Ji({\n            symKey: c,\n            encoded: r,\n            encoding: n?.encoding\n          });\n        return Se(h);\n      } catch (c) {\n        this.logger.error(`Failed to decode message from topic: '${i}', clientId: '${await this.getClientId()}'`), this.logger.error(c);\n      }\n    }, this.getPayloadType = (i, r = Le) => {\n      const n = ze({\n        encoded: i,\n        encoding: r\n      });\n      return Xi(n.type);\n    }, this.getPayloadSenderPublicKey = (i, r = Le) => {\n      const n = ze({\n        encoded: i,\n        encoding: r\n      });\n      return n.senderPublicKey ? Ds(n.senderPublicKey, Wi) : void 0;\n    }, this.core = e, this.logger = I(t, this.name), this.keychain = s || new Ht(this.core, this.logger);\n  }\n  get context() {\n    return S(this.logger);\n  }\n  async setPrivateKey(e, t) {\n    return await this.keychain.set(e, t), e;\n  }\n  getPrivateKey(e) {\n    return this.keychain.get(e);\n  }\n  async getClientSeed() {\n    let e = \"\";\n    try {\n      e = this.keychain.get(me);\n    } catch {\n      e = le(), await this.keychain.set(me, e);\n    }\n    return rn(e, \"base16\");\n  }\n  getSymKey(e) {\n    return this.keychain.get(e);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = p(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass Jt extends Pi {\n  constructor(e, t) {\n    super(e, t), this.logger = e, this.core = t, this.messages = new Map(), this.name = it, this.version = st, this.initialized = !1, this.storagePrefix = A, this.init = async () => {\n      if (!this.initialized) {\n        this.logger.trace(\"Initialized\");\n        try {\n          const s = await this.getRelayerMessages();\n          typeof s < \"u\" && (this.messages = s), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({\n            type: \"method\",\n            method: \"restore\",\n            size: this.messages.size\n          });\n        } catch (s) {\n          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(s);\n        } finally {\n          this.initialized = !0;\n        }\n      }\n    }, this.set = async (s, i) => {\n      this.isInitialized();\n      const r = ue(i);\n      let n = this.messages.get(s);\n      return typeof n > \"u\" && (n = {}), typeof n[r] < \"u\" || (n[r] = i, this.messages.set(s, n), await this.persist()), r;\n    }, this.get = s => {\n      this.isInitialized();\n      let i = this.messages.get(s);\n      return typeof i > \"u\" && (i = {}), i;\n    }, this.has = (s, i) => {\n      this.isInitialized();\n      const r = this.get(s),\n        n = ue(i);\n      return typeof r[n] < \"u\";\n    }, this.del = async s => {\n      this.isInitialized(), this.messages.delete(s), await this.persist();\n    }, this.logger = I(e, this.name), this.core = t;\n  }\n  get context() {\n    return S(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n  async setRelayerMessages(e) {\n    await this.core.storage.setItem(this.storageKey, xe(e));\n  }\n  async getRelayerMessages() {\n    const e = await this.core.storage.getItem(this.storageKey);\n    return typeof e < \"u\" ? Oe(e) : void 0;\n  }\n  async persist() {\n    await this.setRelayerMessages(this.messages);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = p(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nvar nn = Object.defineProperty,\n  on = Object.defineProperties,\n  an = Object.getOwnPropertyDescriptors,\n  Xt = Object.getOwnPropertySymbols,\n  cn = Object.prototype.hasOwnProperty,\n  hn = Object.prototype.propertyIsEnumerable,\n  Wt = (o, e, t) => e in o ? nn(o, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : o[e] = t,\n  Zt = (o, e) => {\n    for (var t in e || (e = {})) cn.call(e, t) && Wt(o, t, e[t]);\n    if (Xt) for (var t of Xt(e)) hn.call(e, t) && Wt(o, t, e[t]);\n    return o;\n  },\n  Qt = (o, e) => on(o, an(e));\nclass ln extends Si {\n  constructor(e, t) {\n    super(e, t), this.relayer = e, this.logger = t, this.events = new K(), this.name = rt, this.queue = new Map(), this.publishTimeout = E(Ce), this.initialPublishTimeout = E(F * 15), this.needsTransportRestart = !1, this.publish = async (s, i, r) => {\n      var n;\n      this.logger.debug(\"Publishing Payload\"), this.logger.trace({\n        type: \"method\",\n        method: \"publish\",\n        params: {\n          topic: s,\n          message: i,\n          opts: r\n        }\n      });\n      const a = r?.ttl || be,\n        c = se(r),\n        h = r?.prompt || !1,\n        u = r?.tag || 0,\n        d = r?.id || je().toString(),\n        y = {\n          topic: s,\n          message: i,\n          opts: {\n            ttl: a,\n            relay: c,\n            prompt: h,\n            tag: u,\n            id: d,\n            attestation: r?.attestation\n          }\n        },\n        m = `Failed to publish payload, please try again. id:${d} tag:${u}`;\n      try {\n        const l = new Promise(async g => {\n          const w = ({\n            id: D\n          }) => {\n            y.opts.id === D && (this.removeRequestFromQueue(D), this.relayer.events.removeListener(v.publish, w), g(y));\n          };\n          this.relayer.events.on(v.publish, w);\n          const b = U(new Promise((D, P) => {\n            this.rpcPublish({\n              topic: s,\n              message: i,\n              ttl: a,\n              prompt: h,\n              tag: u,\n              id: d,\n              attestation: r?.attestation\n            }).then(D).catch(f => {\n              this.logger.warn(f, f?.message), P(f);\n            });\n          }), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${d} tag:${u}`);\n          try {\n            await b, this.events.removeListener(v.publish, w);\n          } catch (D) {\n            this.queue.set(d, Qt(Zt({}, y), {\n              attempt: 1\n            })), this.logger.warn(D, D?.message);\n          }\n        });\n        this.logger.trace({\n          type: \"method\",\n          method: \"publish\",\n          params: {\n            id: d,\n            topic: s,\n            message: i,\n            opts: r\n          }\n        }), await U(l, this.publishTimeout, m);\n      } catch (l) {\n        if (this.logger.debug(\"Failed to Publish Payload\"), this.logger.error(l), (n = r?.internal) != null && n.throwOnFailedPublish) throw l;\n      } finally {\n        this.queue.delete(d);\n      }\n    }, this.on = (s, i) => {\n      this.events.on(s, i);\n    }, this.once = (s, i) => {\n      this.events.once(s, i);\n    }, this.off = (s, i) => {\n      this.events.off(s, i);\n    }, this.removeListener = (s, i) => {\n      this.events.removeListener(s, i);\n    }, this.relayer = e, this.logger = I(t, this.name), this.registerEventListeners();\n  }\n  get context() {\n    return S(this.logger);\n  }\n  async rpcPublish(e) {\n    var t, s, i, r;\n    const {\n        topic: n,\n        message: a,\n        ttl: c = be,\n        prompt: h,\n        tag: u,\n        id: d,\n        attestation: y\n      } = e,\n      m = {\n        method: G(se().protocol).publish,\n        params: {\n          topic: n,\n          message: a,\n          ttl: c,\n          prompt: h,\n          tag: u,\n          attestation: y\n        },\n        id: d\n      };\n    de((t = m.params) == null ? void 0 : t.prompt) && ((s = m.params) == null || delete s.prompt), de((i = m.params) == null ? void 0 : i.tag) && ((r = m.params) == null || delete r.tag), this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"message\",\n      direction: \"outgoing\",\n      request: m\n    });\n    const l = await this.relayer.request(m);\n    return this.relayer.events.emit(v.publish, e), this.logger.debug(\"Successfully Published Payload\"), l;\n  }\n  removeRequestFromQueue(e) {\n    this.queue.delete(e);\n  }\n  checkQueue() {\n    this.queue.forEach(async (e, t) => {\n      const s = e.attempt + 1;\n      this.queue.set(t, Qt(Zt({}, e), {\n        attempt: s\n      }));\n      const {\n        topic: i,\n        message: r,\n        opts: n,\n        attestation: a\n      } = e;\n      this.logger.warn({}, `Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${s}`), await this.rpcPublish({\n        topic: i,\n        message: r,\n        ttl: n.ttl,\n        prompt: n.prompt,\n        tag: n.tag,\n        id: n.id,\n        attestation: a\n      }), this.logger.warn({}, `Publisher: queue->published: ${e.opts.id}`);\n    });\n  }\n  registerEventListeners() {\n    this.relayer.core.heartbeat.on(q.pulse, () => {\n      if (this.needsTransportRestart) {\n        this.needsTransportRestart = !1, this.relayer.events.emit(v.connection_stalled);\n        return;\n      }\n      this.checkQueue();\n    }), this.relayer.on(v.message_ack, e => {\n      this.removeRequestFromQueue(e.id.toString());\n    });\n  }\n}\nclass un {\n  constructor() {\n    this.map = new Map(), this.set = (e, t) => {\n      const s = this.get(e);\n      this.exists(e, t) || this.map.set(e, [...s, t]);\n    }, this.get = e => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {\n      if (typeof t > \"u\") {\n        this.map.delete(e);\n        return;\n      }\n      if (!this.map.has(e)) return;\n      const s = this.get(e);\n      if (!this.exists(e, t)) return;\n      const i = s.filter(r => r !== t);\n      if (!i.length) {\n        this.map.delete(e);\n        return;\n      }\n      this.map.set(e, i);\n    }, this.clear = () => {\n      this.map.clear();\n    };\n  }\n  get topics() {\n    return Array.from(this.map.keys());\n  }\n}\nvar dn = Object.defineProperty,\n  pn = Object.defineProperties,\n  gn = Object.getOwnPropertyDescriptors,\n  ei = Object.getOwnPropertySymbols,\n  yn = Object.prototype.hasOwnProperty,\n  Dn = Object.prototype.propertyIsEnumerable,\n  ti = (o, e, t) => e in o ? dn(o, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : o[e] = t,\n  Z = (o, e) => {\n    for (var t in e || (e = {})) yn.call(e, t) && ti(o, t, e[t]);\n    if (ei) for (var t of ei(e)) Dn.call(e, t) && ti(o, t, e[t]);\n    return o;\n  },\n  Ie = (o, e) => pn(o, gn(e));\nclass ii extends Ri {\n  constructor(e, t) {\n    super(e, t), this.relayer = e, this.logger = t, this.subscriptions = new Map(), this.topicMap = new un(), this.events = new K(), this.name = dt, this.version = pt, this.pending = new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = \"pending_sub_watch_label\", this.pollingInterval = 20, this.storagePrefix = A, this.subscribeTimeout = E(Ce), this.initialSubscribeTimeout = E(F * 15), this.batchSubscribeTopicsLimit = 500, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId(), await this.restore()), this.initialized = !0;\n    }, this.subscribe = async (s, i) => {\n      this.isInitialized(), this.logger.debug(\"Subscribing Topic\"), this.logger.trace({\n        type: \"method\",\n        method: \"subscribe\",\n        params: {\n          topic: s,\n          opts: i\n        }\n      });\n      try {\n        const r = se(i),\n          n = {\n            topic: s,\n            relay: r,\n            transportType: i?.transportType\n          };\n        this.pending.set(s, n);\n        const a = await this.rpcSubscribe(s, r, i);\n        return typeof a == \"string\" && (this.onSubscribe(a, n), this.logger.debug(\"Successfully Subscribed Topic\"), this.logger.trace({\n          type: \"method\",\n          method: \"subscribe\",\n          params: {\n            topic: s,\n            opts: i\n          }\n        })), a;\n      } catch (r) {\n        throw this.logger.debug(\"Failed to Subscribe Topic\"), this.logger.error(r), r;\n      }\n    }, this.unsubscribe = async (s, i) => {\n      await this.restartToComplete(), this.isInitialized(), typeof i?.id < \"u\" ? await this.unsubscribeById(s, i.id, i) : await this.unsubscribeByTopic(s, i);\n    }, this.isSubscribed = async s => {\n      if (this.topics.includes(s)) return !0;\n      const i = `${this.pendingSubscriptionWatchLabel}_${s}`;\n      return await new Promise((r, n) => {\n        const a = new Fi();\n        a.start(i);\n        const c = setInterval(() => {\n          (!this.pending.has(s) && this.topics.includes(s) || this.cached.some(h => h.topic === s)) && (clearInterval(c), a.stop(i), r(!0)), a.elapsed(i) >= gt && (clearInterval(c), a.stop(i), n(new Error(\"Subscription resolution timeout\")));\n        }, this.pollingInterval);\n      }).catch(() => !1);\n    }, this.on = (s, i) => {\n      this.events.on(s, i);\n    }, this.once = (s, i) => {\n      this.events.once(s, i);\n    }, this.off = (s, i) => {\n      this.events.off(s, i);\n    }, this.removeListener = (s, i) => {\n      this.events.removeListener(s, i);\n    }, this.start = async () => {\n      await this.onConnect();\n    }, this.stop = async () => {\n      await this.onDisconnect();\n    }, this.restart = async () => {\n      await this.restore(), await this.onRestart();\n    }, this.checkPending = async () => {\n      if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) return;\n      const s = [];\n      this.pending.forEach(i => {\n        s.push(i);\n      }), await this.batchSubscribe(s);\n    }, this.registerEventListeners = () => {\n      this.relayer.core.heartbeat.on(q.pulse, async () => {\n        await this.checkPending();\n      }), this.events.on(T.created, async s => {\n        const i = T.created;\n        this.logger.info(`Emitting ${i}`), this.logger.debug({\n          type: \"event\",\n          event: i,\n          data: s\n        }), await this.persist();\n      }), this.events.on(T.deleted, async s => {\n        const i = T.deleted;\n        this.logger.info(`Emitting ${i}`), this.logger.debug({\n          type: \"event\",\n          event: i,\n          data: s\n        }), await this.persist();\n      });\n    }, this.relayer = e, this.logger = I(t, this.name), this.clientId = \"\";\n  }\n  get context() {\n    return S(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + \"//\" + this.name;\n  }\n  get length() {\n    return this.subscriptions.size;\n  }\n  get ids() {\n    return Array.from(this.subscriptions.keys());\n  }\n  get values() {\n    return Array.from(this.subscriptions.values());\n  }\n  get topics() {\n    return this.topicMap.topics;\n  }\n  hasSubscription(e, t) {\n    let s = !1;\n    try {\n      s = this.getSubscription(e).topic === t;\n    } catch {}\n    return s;\n  }\n  reset() {\n    this.cached = [], this.initialized = !0;\n  }\n  onDisable() {\n    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();\n  }\n  async unsubscribeByTopic(e, t) {\n    const s = this.topicMap.get(e);\n    await Promise.all(s.map(async i => await this.unsubscribeById(e, i, t)));\n  }\n  async unsubscribeById(e, t, s) {\n    this.logger.debug(\"Unsubscribing Topic\"), this.logger.trace({\n      type: \"method\",\n      method: \"unsubscribe\",\n      params: {\n        topic: e,\n        id: t,\n        opts: s\n      }\n    });\n    try {\n      const i = se(s);\n      await this.rpcUnsubscribe(e, t, i);\n      const r = H(\"USER_DISCONNECTED\", `${this.name}, ${e}`);\n      await this.onUnsubscribe(e, t, r), this.logger.debug(\"Successfully Unsubscribed Topic\"), this.logger.trace({\n        type: \"method\",\n        method: \"unsubscribe\",\n        params: {\n          topic: e,\n          id: t,\n          opts: s\n        }\n      });\n    } catch (i) {\n      throw this.logger.debug(\"Failed to Unsubscribe Topic\"), this.logger.error(i), i;\n    }\n  }\n  async rpcSubscribe(e, t, s) {\n    var i;\n    s?.transportType === M.relay && (await this.restartToComplete());\n    const r = {\n      method: G(t.protocol).subscribe,\n      params: {\n        topic: e\n      }\n    };\n    this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"outgoing\",\n      request: r\n    });\n    const n = (i = s?.internal) == null ? void 0 : i.throwOnFailedPublish;\n    try {\n      const a = this.getSubscriptionId(e);\n      if (s?.transportType === M.link_mode) return setTimeout(() => {\n        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(r).catch(u => this.logger.warn(u));\n      }, E(F)), a;\n      const c = new Promise(async u => {\n          const d = y => {\n            y.topic === e && (this.events.removeListener(T.created, d), u(y.id));\n          };\n          this.events.on(T.created, d);\n          try {\n            const y = await U(new Promise((m, l) => {\n              this.relayer.request(r).catch(g => {\n                this.logger.warn(g, g?.message), l(g);\n              }).then(m);\n            }), this.initialSubscribeTimeout, `Subscribing to ${e} failed, please try again`);\n            this.events.removeListener(T.created, d), u(y);\n          } catch {}\n        }),\n        h = await U(c, this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);\n      if (!h && n) throw new Error(`Subscribing to ${e} failed, please try again`);\n      return h ? a : null;\n    } catch (a) {\n      if (this.logger.debug(\"Outgoing Relay Subscribe Payload stalled\"), this.relayer.events.emit(v.connection_stalled), n) throw a;\n    }\n    return null;\n  }\n  async rpcBatchSubscribe(e) {\n    if (!e.length) return;\n    const t = e[0].relay,\n      s = {\n        method: G(t.protocol).batchSubscribe,\n        params: {\n          topics: e.map(i => i.topic)\n        }\n      };\n    this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"outgoing\",\n      request: s\n    });\n    try {\n      await await U(new Promise(i => {\n        this.relayer.request(s).catch(r => this.logger.warn(r)).then(i);\n      }), this.subscribeTimeout, \"rpcBatchSubscribe failed, please try again\");\n    } catch {\n      this.relayer.events.emit(v.connection_stalled);\n    }\n  }\n  async rpcBatchFetchMessages(e) {\n    if (!e.length) return;\n    const t = e[0].relay,\n      s = {\n        method: G(t.protocol).batchFetchMessages,\n        params: {\n          topics: e.map(r => r.topic)\n        }\n      };\n    this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"outgoing\",\n      request: s\n    });\n    let i;\n    try {\n      i = await await U(new Promise((r, n) => {\n        this.relayer.request(s).catch(a => {\n          this.logger.warn(a), n(a);\n        }).then(r);\n      }), this.subscribeTimeout, \"rpcBatchFetchMessages failed, please try again\");\n    } catch {\n      this.relayer.events.emit(v.connection_stalled);\n    }\n    return i;\n  }\n  rpcUnsubscribe(e, t, s) {\n    const i = {\n      method: G(s.protocol).unsubscribe,\n      params: {\n        topic: e,\n        id: t\n      }\n    };\n    return this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"outgoing\",\n      request: i\n    }), this.relayer.request(i);\n  }\n  onSubscribe(e, t) {\n    this.setSubscription(e, Ie(Z({}, t), {\n      id: e\n    })), this.pending.delete(t.topic);\n  }\n  onBatchSubscribe(e) {\n    e.length && e.forEach(t => {\n      this.setSubscription(t.id, Z({}, t)), this.pending.delete(t.topic);\n    });\n  }\n  async onUnsubscribe(e, t, s) {\n    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, s), await this.relayer.messages.del(e);\n  }\n  async setRelayerSubscriptions(e) {\n    await this.relayer.core.storage.setItem(this.storageKey, e);\n  }\n  async getRelayerSubscriptions() {\n    return await this.relayer.core.storage.getItem(this.storageKey);\n  }\n  setSubscription(e, t) {\n    this.logger.debug(\"Setting subscription\"), this.logger.trace({\n      type: \"method\",\n      method: \"setSubscription\",\n      id: e,\n      subscription: t\n    }), this.addSubscription(e, t);\n  }\n  addSubscription(e, t) {\n    this.subscriptions.set(e, Z({}, t)), this.topicMap.set(t.topic, e), this.events.emit(T.created, t);\n  }\n  getSubscription(e) {\n    this.logger.debug(\"Getting subscription\"), this.logger.trace({\n      type: \"method\",\n      method: \"getSubscription\",\n      id: e\n    });\n    const t = this.subscriptions.get(e);\n    if (!t) {\n      const {\n        message: s\n      } = p(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw new Error(s);\n    }\n    return t;\n  }\n  deleteSubscription(e, t) {\n    this.logger.debug(\"Deleting subscription\"), this.logger.trace({\n      type: \"method\",\n      method: \"deleteSubscription\",\n      id: e,\n      reason: t\n    });\n    const s = this.getSubscription(e);\n    this.subscriptions.delete(e), this.topicMap.delete(s.topic, e), this.events.emit(T.deleted, Ie(Z({}, s), {\n      reason: t\n    }));\n  }\n  async persist() {\n    await this.setRelayerSubscriptions(this.values), this.events.emit(T.sync);\n  }\n  async onRestart() {\n    if (this.cached.length) {\n      const e = [...this.cached],\n        t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);\n      for (let s = 0; s < t; s++) {\n        const i = e.splice(0, this.batchSubscribeTopicsLimit);\n        await this.batchSubscribe(i);\n      }\n    }\n    this.events.emit(T.resubscribed);\n  }\n  async restore() {\n    try {\n      const e = await this.getRelayerSubscriptions();\n      if (typeof e > \"u\" || !e.length) return;\n      if (this.subscriptions.size) {\n        const {\n          message: t\n        } = p(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        subscriptions: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);\n    }\n  }\n  async batchSubscribe(e) {\n    e.length && (await this.rpcBatchSubscribe(e), this.onBatchSubscribe(e.map(t => Ie(Z({}, t), {\n      id: this.getSubscriptionId(t.topic)\n    }))));\n  }\n  async batchFetchMessages(e) {\n    if (!e.length) return;\n    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);\n    const t = await this.rpcBatchFetchMessages(e);\n    t && t.messages && (await Zi(E(F)), await this.relayer.handleBatchMessageEvents(t.messages));\n  }\n  async onConnect() {\n    await this.restart(), this.reset();\n  }\n  onDisconnect() {\n    this.onDisable();\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = p(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  async restartToComplete() {\n    !this.relayer.connected && !this.relayer.connecting && (await this.relayer.transportOpen());\n  }\n  getSubscriptionId(e) {\n    return ue(e + this.clientId);\n  }\n}\nvar mn = Object.defineProperty,\n  si = Object.getOwnPropertySymbols,\n  bn = Object.prototype.hasOwnProperty,\n  fn = Object.prototype.propertyIsEnumerable,\n  ri = (o, e, t) => e in o ? mn(o, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : o[e] = t,\n  ni = (o, e) => {\n    for (var t in e || (e = {})) bn.call(e, t) && ri(o, t, e[t]);\n    if (si) for (var t of si(e)) fn.call(e, t) && ri(o, t, e[t]);\n    return o;\n  };\nclass oi extends xi {\n  constructor(e) {\n    super(e), this.protocol = \"wc\", this.version = 2, this.events = new K(), this.name = at, this.transportExplicitlyClosed = !1, this.initialized = !1, this.connectionAttemptInProgress = !1, this.hasExperiencedNetworkDisruption = !1, this.heartBeatTimeout = E(ce + ae), this.requestsInFlight = [], this.connectTimeout = E(F * 15), this.request = async t => {\n      var s, i;\n      this.logger.debug(\"Publishing Request Payload\");\n      const r = t.id || je().toString();\n      await this.toEstablishConnection();\n      try {\n        this.logger.trace({\n          id: r,\n          method: t.method,\n          topic: (s = t.params) == null ? void 0 : s.topic\n        }, \"relayer.request - publishing...\");\n        const n = `${r}:${((i = t.params) == null ? void 0 : i.tag) || \"\"}`;\n        this.requestsInFlight.push(n);\n        const a = await this.provider.request(t);\n        return this.requestsInFlight = this.requestsInFlight.filter(c => c !== n), a;\n      } catch (n) {\n        throw this.logger.debug(`Failed to Publish Request: ${r}`), n;\n      }\n    }, this.resetPingTimeout = () => {\n      if ($e()) try {\n        clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {\n          var t, s, i;\n          this.logger.debug({}, \"pingTimeout: Connection stalled, terminating...\"), (i = (s = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : s.socket) == null || i.terminate();\n        }, this.heartBeatTimeout);\n      } catch (t) {\n        this.logger.warn(t, t?.message);\n      }\n    }, this.onPayloadHandler = t => {\n      this.onProviderPayload(t), this.resetPingTimeout();\n    }, this.onConnectHandler = () => {\n      this.logger.warn({}, \"Relayer connected \\u{1F6DC}\"), this.startPingTimeout(), this.events.emit(v.connect);\n    }, this.onDisconnectHandler = () => {\n      this.logger.warn({}, \"Relayer disconnected \\u{1F6D1}\"), this.requestsInFlight = [], this.onProviderDisconnect();\n    }, this.onProviderErrorHandler = t => {\n      this.logger.fatal(t, `Fatal socket error: ${t?.message}`), this.events.emit(v.error, t), this.logger.fatal(\"Fatal socket error received, closing transport\"), this.transportClose();\n    }, this.registerProviderListeners = () => {\n      this.provider.on(C.payload, this.onPayloadHandler), this.provider.on(C.connect, this.onConnectHandler), this.provider.on(C.disconnect, this.onDisconnectHandler), this.provider.on(C.error, this.onProviderErrorHandler);\n    }, this.core = e.core, this.logger = typeof e.logger < \"u\" && typeof e.logger != \"string\" ? I(e.logger, this.name) : Ti(Te({\n      level: e.logger || ot\n    })), this.messages = new Jt(this.logger, e.core), this.subscriber = new ii(this, this.logger), this.publisher = new ln(this, this.logger), this.relayUrl = e?.relayUrl || fe, this.projectId = e.projectId, Qi() ? this.packageName = ke() : es() && (this.bundleId = ke()), this.provider = {};\n  }\n  async init() {\n    if (this.logger.trace(\"Initialized\"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = !0, this.subscriber.cached.length > 0) try {\n      await this.transportOpen();\n    } catch (e) {\n      this.logger.warn(e, e?.message);\n    }\n  }\n  get context() {\n    return S(this.logger);\n  }\n  get connected() {\n    var e, t, s;\n    return ((s = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : s.readyState) === 1;\n  }\n  get connecting() {\n    var e, t, s;\n    return ((s = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : s.readyState) === 0;\n  }\n  async publish(e, t, s) {\n    this.isInitialized(), await this.publisher.publish(e, t, s), await this.recordMessageEvent({\n      topic: e,\n      message: t,\n      publishedAt: Date.now(),\n      transportType: M.relay\n    });\n  }\n  async subscribe(e, t) {\n    var s, i, r;\n    this.isInitialized(), (!(t != null && t.transportType) || t?.transportType === \"relay\") && (await this.toEstablishConnection());\n    const n = typeof ((s = t?.internal) == null ? void 0 : s.throwOnFailedPublish) > \"u\" ? !0 : (i = t?.internal) == null ? void 0 : i.throwOnFailedPublish;\n    let a = ((r = this.subscriber.topicMap.get(e)) == null ? void 0 : r[0]) || \"\",\n      c;\n    const h = u => {\n      u.topic === e && (this.subscriber.off(T.created, h), c());\n    };\n    return await Promise.all([new Promise(u => {\n      c = u, this.subscriber.on(T.created, h);\n    }), new Promise(async (u, d) => {\n      a = (await this.subscriber.subscribe(e, ni({\n        internal: {\n          throwOnFailedPublish: n\n        }\n      }, t)).catch(y => {\n        n && d(y);\n      })) || a, u();\n    })]), a;\n  }\n  async unsubscribe(e, t) {\n    this.isInitialized(), await this.subscriber.unsubscribe(e, t);\n  }\n  on(e, t) {\n    this.events.on(e, t);\n  }\n  once(e, t) {\n    this.events.once(e, t);\n  }\n  off(e, t) {\n    this.events.off(e, t);\n  }\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n  async transportDisconnect() {\n    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await U(this.provider.disconnect(), 2e3, \"provider.disconnect()\").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();\n  }\n  async transportClose() {\n    this.transportExplicitlyClosed = !0, await this.transportDisconnect();\n  }\n  async transportOpen(e) {\n    if (this.connectPromise ? (this.logger.debug({}, \"Waiting for existing connection attempt to resolve...\"), await this.connectPromise, this.logger.debug({}, \"Existing connection attempt resolved\")) : (this.connectPromise = new Promise(async (t, s) => {\n      await this.connect(e).then(t).catch(s).finally(() => {\n        this.connectPromise = void 0;\n      });\n    }), await this.connectPromise), !this.connected) throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);\n  }\n  async restartTransport(e) {\n    this.logger.debug({}, \"Restarting transport...\"), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());\n  }\n  async confirmOnlineStateOrThrow() {\n    if (!(await Ue())) throw new Error(\"No internet connection detected. Please restart your network and try again.\");\n  }\n  async handleBatchMessageEvents(e) {\n    if (e?.length === 0) {\n      this.logger.trace(\"Batch message events is empty. Ignoring...\");\n      return;\n    }\n    const t = e.sort((s, i) => s.publishedAt - i.publishedAt);\n    this.logger.debug(`Batch of ${t.length} message events sorted`);\n    for (const s of t) try {\n      await this.onMessageEvent(s);\n    } catch (i) {\n      this.logger.warn(i, \"Error while processing batch message event: \" + i?.message);\n    }\n    this.logger.trace(`Batch of ${t.length} message events processed`);\n  }\n  async onLinkMessageEvent(e, t) {\n    const {\n      topic: s\n    } = e;\n    if (!t.sessionExists) {\n      const i = Y(he),\n        r = {\n          topic: s,\n          expiry: i,\n          relay: {\n            protocol: \"irn\"\n          },\n          active: !1\n        };\n      await this.core.pairing.pairings.set(s, r);\n    }\n    this.events.emit(v.message, e), await this.recordMessageEvent(e);\n  }\n  async connect(e) {\n    await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), this.connectionAttemptInProgress = !0, this.transportExplicitlyClosed = !1;\n    let t = 1;\n    for (; t < 6;) {\n      try {\n        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t}...`), await this.createProvider(), await new Promise(async (s, i) => {\n          const r = () => {\n            i(new Error(\"Connection interrupted while trying to subscribe\"));\n          };\n          this.provider.once(C.disconnect, r), await U(new Promise((n, a) => {\n            this.provider.connect().then(n).catch(a);\n          }), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch(n => {\n            i(n);\n          }).finally(() => {\n            this.provider.off(C.disconnect, r), clearTimeout(this.reconnectTimeout), this.reconnectTimeout = void 0;\n          }), await new Promise(async (n, a) => {\n            const c = () => {\n              a(new Error(\"Connection interrupted while trying to subscribe\"));\n            };\n            this.provider.once(C.disconnect, c), await this.subscriber.start().then(n).catch(a).finally(() => {\n              this.provider.off(C.disconnect, c);\n            });\n          }), this.hasExperiencedNetworkDisruption = !1, s();\n        });\n      } catch (s) {\n        await this.subscriber.stop();\n        const i = s;\n        this.logger.warn({}, i.message), this.hasExperiencedNetworkDisruption = !0;\n      } finally {\n        this.connectionAttemptInProgress = !1;\n      }\n      if (this.connected) {\n        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t}`);\n        break;\n      }\n      await new Promise(s => setTimeout(s, E(t * 1))), t++;\n    }\n  }\n  startPingTimeout() {\n    var e, t, s, i, r;\n    if ($e()) try {\n      (t = (e = this.provider) == null ? void 0 : e.connection) != null && t.socket && ((r = (i = (s = this.provider) == null ? void 0 : s.connection) == null ? void 0 : i.socket) == null || r.on(\"ping\", () => {\n        this.resetPingTimeout();\n      })), this.resetPingTimeout();\n    } catch (n) {\n      this.logger.warn(n, n?.message);\n    }\n  }\n  async createProvider() {\n    this.provider.connection && this.unregisterProviderListeners();\n    const e = await this.core.crypto.signJWT(this.relayUrl);\n    this.provider = new ms(new vs(ts({\n      sdkVersion: re,\n      protocol: this.protocol,\n      version: this.version,\n      relayUrl: this.relayUrl,\n      projectId: this.projectId,\n      auth: e,\n      useOnCloseEvent: !0,\n      bundleId: this.bundleId,\n      packageName: this.packageName\n    }))), this.registerProviderListeners();\n  }\n  async recordMessageEvent(e) {\n    const {\n      topic: t,\n      message: s\n    } = e;\n    await this.messages.set(t, s);\n  }\n  async shouldIgnoreMessageEvent(e) {\n    const {\n      topic: t,\n      message: s\n    } = e;\n    if (!s || s.length === 0) return this.logger.warn(`Ignoring invalid/empty message: ${s}`), !0;\n    if (!(await this.subscriber.isSubscribed(t))) return this.logger.warn(`Ignoring message for non-subscribed topic ${t}`), !0;\n    const i = this.messages.has(t, s);\n    return i && this.logger.warn(`Ignoring duplicate message: ${s}`), i;\n  }\n  async onProviderPayload(e) {\n    if (this.logger.debug(\"Incoming Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"incoming\",\n      payload: e\n    }), qe(e)) {\n      if (!e.method.endsWith(ct)) return;\n      const t = e.params,\n        {\n          topic: s,\n          message: i,\n          publishedAt: r,\n          attestation: n\n        } = t.data,\n        a = {\n          topic: s,\n          message: i,\n          publishedAt: r,\n          transportType: M.relay,\n          attestation: n\n        };\n      this.logger.debug(\"Emitting Relayer Payload\"), this.logger.trace(ni({\n        type: \"event\",\n        event: t.id\n      }, a)), this.events.emit(t.id, a), await this.acknowledgePayload(e), await this.onMessageEvent(a);\n    } else Ge(e) && this.events.emit(v.message_ack, e);\n  }\n  async onMessageEvent(e) {\n    (await this.shouldIgnoreMessageEvent(e)) || (this.events.emit(v.message, e), await this.recordMessageEvent(e));\n  }\n  async acknowledgePayload(e) {\n    const t = He(e.id, !0);\n    await this.provider.connection.send(t);\n  }\n  unregisterProviderListeners() {\n    this.provider.off(C.payload, this.onPayloadHandler), this.provider.off(C.connect, this.onConnectHandler), this.provider.off(C.disconnect, this.onDisconnectHandler), this.provider.off(C.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);\n  }\n  async registerEventListeners() {\n    let e = await Ue();\n    is(async t => {\n      e !== t && (e = t, t ? await this.transportOpen().catch(s => this.logger.error(s, s?.message)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportDisconnect(), this.transportExplicitlyClosed = !1));\n    });\n  }\n  async onProviderDisconnect() {\n    await this.subscriber.stop(), clearTimeout(this.pingTimeout), this.events.emit(v.disconnect), this.connectionAttemptInProgress = !1, !this.transportExplicitlyClosed && (this.reconnectTimeout || this.connectPromise || (this.reconnectTimeout = setTimeout(async () => {\n      clearTimeout(this.reconnectTimeout), await this.transportOpen().catch(e => this.logger.error(e, e?.message));\n    }, E(ht))));\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = p(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  async toEstablishConnection() {\n    await this.confirmOnlineStateOrThrow(), !this.connected && (await this.transportOpen());\n  }\n}\nvar vn = Object.defineProperty,\n  ai = Object.getOwnPropertySymbols,\n  _n = Object.prototype.hasOwnProperty,\n  En = Object.prototype.propertyIsEnumerable,\n  ci = (o, e, t) => e in o ? vn(o, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : o[e] = t,\n  hi = (o, e) => {\n    for (var t in e || (e = {})) _n.call(e, t) && ci(o, t, e[t]);\n    if (ai) for (var t of ai(e)) En.call(e, t) && ci(o, t, e[t]);\n    return o;\n  };\nclass li extends Oi {\n  constructor(e, t, s, i = A, r = void 0) {\n    super(e, t, s, i), this.core = e, this.logger = t, this.name = s, this.map = new Map(), this.version = lt, this.cached = [], this.initialized = !1, this.storagePrefix = A, this.recentlyDeleted = [], this.recentlyDeletedLimit = 200, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach(n => {\n        this.getKey && n !== null && !de(n) ? this.map.set(this.getKey(n), n) : ss(n) ? this.map.set(n.id, n) : rs(n) && this.map.set(n.topic, n);\n      }), this.cached = [], this.initialized = !0);\n    }, this.set = async (n, a) => {\n      this.isInitialized(), this.map.has(n) ? await this.update(n, a) : (this.logger.debug(\"Setting value\"), this.logger.trace({\n        type: \"method\",\n        method: \"set\",\n        key: n,\n        value: a\n      }), this.map.set(n, a), await this.persist());\n    }, this.get = n => (this.isInitialized(), this.logger.debug(\"Getting value\"), this.logger.trace({\n      type: \"method\",\n      method: \"get\",\n      key: n\n    }), this.getData(n)), this.getAll = n => (this.isInitialized(), n ? this.values.filter(a => Object.keys(n).every(c => _s(a[c], n[c]))) : this.values), this.update = async (n, a) => {\n      this.isInitialized(), this.logger.debug(\"Updating value\"), this.logger.trace({\n        type: \"method\",\n        method: \"update\",\n        key: n,\n        update: a\n      });\n      const c = hi(hi({}, this.getData(n)), a);\n      this.map.set(n, c), await this.persist();\n    }, this.delete = async (n, a) => {\n      this.isInitialized(), this.map.has(n) && (this.logger.debug(\"Deleting value\"), this.logger.trace({\n        type: \"method\",\n        method: \"delete\",\n        key: n,\n        reason: a\n      }), this.map.delete(n), this.addToRecentlyDeleted(n), await this.persist());\n    }, this.logger = I(t, this.name), this.storagePrefix = i, this.getKey = r;\n  }\n  get context() {\n    return S(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n  get length() {\n    return this.map.size;\n  }\n  get keys() {\n    return Array.from(this.map.keys());\n  }\n  get values() {\n    return Array.from(this.map.values());\n  }\n  addToRecentlyDeleted(e) {\n    this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);\n  }\n  async setDataStore(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getDataStore() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  getData(e) {\n    const t = this.map.get(e);\n    if (!t) {\n      if (this.recentlyDeleted.includes(e)) {\n        const {\n          message: i\n        } = p(\"MISSING_OR_INVALID\", `Record was recently deleted - ${this.name}: ${e}`);\n        throw this.logger.error(i), new Error(i);\n      }\n      const {\n        message: s\n      } = p(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw this.logger.error(s), new Error(s);\n    }\n    return t;\n  }\n  async persist() {\n    await this.setDataStore(this.values);\n  }\n  async restore() {\n    try {\n      const e = await this.getDataStore();\n      if (typeof e > \"u\" || !e.length) return;\n      if (this.map.size) {\n        const {\n          message: t\n        } = p(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        value: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);\n    }\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = p(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass ui {\n  constructor(e, t) {\n    this.core = e, this.logger = t, this.name = yt, this.version = Dt, this.events = new Ei(), this.initialized = !1, this.storagePrefix = A, this.ignoredPayloadTypes = [ns], this.registeredMethods = [], this.init = async () => {\n      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace(\"Initialized\"));\n    }, this.register = ({\n      methods: s\n    }) => {\n      this.isInitialized(), this.registeredMethods = [...new Set([...this.registeredMethods, ...s])];\n    }, this.create = async s => {\n      this.isInitialized();\n      const i = le(),\n        r = await this.core.crypto.setSymKey(i),\n        n = Y(he),\n        a = {\n          protocol: nt\n        },\n        c = {\n          topic: r,\n          expiry: n,\n          relay: a,\n          active: !1,\n          methods: s?.methods\n        },\n        h = Fe({\n          protocol: this.core.protocol,\n          version: this.core.version,\n          topic: r,\n          symKey: i,\n          relay: a,\n          expiryTimestamp: n,\n          methods: s?.methods\n        });\n      return this.events.emit(j.create, c), this.core.expirer.set(r, n), await this.pairings.set(r, c), await this.core.relayer.subscribe(r, {\n        transportType: s?.transportType\n      }), {\n        topic: r,\n        uri: h\n      };\n    }, this.pair = async s => {\n      this.isInitialized();\n      const i = this.core.eventClient.createEvent({\n        properties: {\n          topic: s?.uri,\n          trace: [z.pairing_started]\n        }\n      });\n      this.isValidPair(s, i);\n      const {\n        topic: r,\n        symKey: n,\n        relay: a,\n        expiryTimestamp: c,\n        methods: h\n      } = Me(s.uri);\n      i.props.properties.topic = r, i.addTrace(z.pairing_uri_validation_success), i.addTrace(z.pairing_uri_not_expired);\n      let u;\n      if (this.pairings.keys.includes(r)) {\n        if (u = this.pairings.get(r), i.addTrace(z.existing_pairing), u.active) throw i.setError($.active_pairing_already_exists), new Error(`Pairing already exists: ${r}. Please try again with a new connection URI.`);\n        i.addTrace(z.pairing_not_expired);\n      }\n      const d = c || Y(he),\n        y = {\n          topic: r,\n          relay: a,\n          expiry: d,\n          active: !1,\n          methods: h\n        };\n      this.core.expirer.set(r, d), await this.pairings.set(r, y), i.addTrace(z.store_new_pairing), s.activatePairing && (await this.activate({\n        topic: r\n      })), this.events.emit(j.create, y), i.addTrace(z.emit_inactive_pairing), this.core.crypto.keychain.has(r) || (await this.core.crypto.setSymKey(n, r)), i.addTrace(z.subscribing_pairing_topic);\n      try {\n        await this.core.relayer.confirmOnlineStateOrThrow();\n      } catch {\n        i.setError($.no_internet_connection);\n      }\n      try {\n        await this.core.relayer.subscribe(r, {\n          relay: a\n        });\n      } catch (m) {\n        throw i.setError($.subscribe_pairing_topic_failure), m;\n      }\n      return i.addTrace(z.subscribe_pairing_topic_success), y;\n    }, this.activate = async ({\n      topic: s\n    }) => {\n      this.isInitialized();\n      const i = Y(te);\n      this.core.expirer.set(s, i), await this.pairings.update(s, {\n        active: !0,\n        expiry: i\n      });\n    }, this.ping = async s => {\n      this.isInitialized(), await this.isValidPing(s);\n      const {\n        topic: i\n      } = s;\n      if (this.pairings.keys.includes(i)) {\n        const r = await this.sendRequest(i, \"wc_pairingPing\", {}),\n          {\n            done: n,\n            resolve: a,\n            reject: c\n          } = os();\n        this.events.once(pe(\"pairing_ping\", r), ({\n          error: h\n        }) => {\n          h ? c(h) : a();\n        }), await n();\n      }\n    }, this.updateExpiry = async ({\n      topic: s,\n      expiry: i\n    }) => {\n      this.isInitialized(), await this.pairings.update(s, {\n        expiry: i\n      });\n    }, this.updateMetadata = async ({\n      topic: s,\n      metadata: i\n    }) => {\n      this.isInitialized(), await this.pairings.update(s, {\n        peerMetadata: i\n      });\n    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async s => {\n      this.isInitialized(), await this.isValidDisconnect(s);\n      const {\n        topic: i\n      } = s;\n      this.pairings.keys.includes(i) && (await this.sendRequest(i, \"wc_pairingDelete\", H(\"USER_DISCONNECTED\")), await this.deletePairing(i));\n    }, this.formatUriFromPairing = s => {\n      this.isInitialized();\n      const {\n          topic: i,\n          relay: r,\n          expiry: n,\n          methods: a\n        } = s,\n        c = this.core.crypto.keychain.get(i);\n      return Fe({\n        protocol: this.core.protocol,\n        version: this.core.version,\n        topic: i,\n        symKey: c,\n        relay: r,\n        expiryTimestamp: n,\n        methods: a\n      });\n    }, this.sendRequest = async (s, i, r) => {\n      const n = Ye(i, r),\n        a = await this.core.crypto.encode(s, n),\n        c = V[i].req;\n      return this.core.history.set(s, n), this.core.relayer.publish(s, a, c), n.id;\n    }, this.sendResult = async (s, i, r) => {\n      const n = He(s, r),\n        a = await this.core.crypto.encode(i, n),\n        c = await this.core.history.get(i, s),\n        h = V[c.request.method].res;\n      await this.core.relayer.publish(i, a, h), await this.core.history.resolve(n);\n    }, this.sendError = async (s, i, r) => {\n      const n = bs(s, r),\n        a = await this.core.crypto.encode(i, n),\n        c = await this.core.history.get(i, s),\n        h = V[c.request.method] ? V[c.request.method].res : V.unregistered_method.res;\n      await this.core.relayer.publish(i, a, h), await this.core.history.resolve(n);\n    }, this.deletePairing = async (s, i) => {\n      await this.core.relayer.unsubscribe(s), await Promise.all([this.pairings.delete(s, H(\"USER_DISCONNECTED\")), this.core.crypto.deleteSymKey(s), i ? Promise.resolve() : this.core.expirer.del(s)]);\n    }, this.cleanup = async () => {\n      const s = this.pairings.getAll().filter(i => Ke(i.expiry));\n      await Promise.all(s.map(i => this.deletePairing(i.topic)));\n    }, this.onRelayEventRequest = s => {\n      const {\n        topic: i,\n        payload: r\n      } = s;\n      switch (r.method) {\n        case \"wc_pairingPing\":\n          return this.onPairingPingRequest(i, r);\n        case \"wc_pairingDelete\":\n          return this.onPairingDeleteRequest(i, r);\n        default:\n          return this.onUnknownRpcMethodRequest(i, r);\n      }\n    }, this.onRelayEventResponse = async s => {\n      const {\n          topic: i,\n          payload: r\n        } = s,\n        n = (await this.core.history.get(i, r.id)).request.method;\n      switch (n) {\n        case \"wc_pairingPing\":\n          return this.onPairingPingResponse(i, r);\n        default:\n          return this.onUnknownRpcMethodResponse(n);\n      }\n    }, this.onPairingPingRequest = async (s, i) => {\n      const {\n        id: r\n      } = i;\n      try {\n        this.isValidPing({\n          topic: s\n        }), await this.sendResult(r, s, !0), this.events.emit(j.ping, {\n          id: r,\n          topic: s\n        });\n      } catch (n) {\n        await this.sendError(r, s, n), this.logger.error(n);\n      }\n    }, this.onPairingPingResponse = (s, i) => {\n      const {\n        id: r\n      } = i;\n      setTimeout(() => {\n        fs(i) ? this.events.emit(pe(\"pairing_ping\", r), {}) : Je(i) && this.events.emit(pe(\"pairing_ping\", r), {\n          error: i.error\n        });\n      }, 500);\n    }, this.onPairingDeleteRequest = async (s, i) => {\n      const {\n        id: r\n      } = i;\n      try {\n        this.isValidDisconnect({\n          topic: s\n        }), await this.deletePairing(s), this.events.emit(j.delete, {\n          id: r,\n          topic: s\n        });\n      } catch (n) {\n        await this.sendError(r, s, n), this.logger.error(n);\n      }\n    }, this.onUnknownRpcMethodRequest = async (s, i) => {\n      const {\n        id: r,\n        method: n\n      } = i;\n      try {\n        if (this.registeredMethods.includes(n)) return;\n        const a = H(\"WC_METHOD_UNSUPPORTED\", n);\n        await this.sendError(r, s, a), this.logger.error(a);\n      } catch (a) {\n        await this.sendError(r, s, a), this.logger.error(a);\n      }\n    }, this.onUnknownRpcMethodResponse = s => {\n      this.registeredMethods.includes(s) || this.logger.error(H(\"WC_METHOD_UNSUPPORTED\", s));\n    }, this.isValidPair = (s, i) => {\n      var r;\n      if (!ge(s)) {\n        const {\n          message: a\n        } = p(\"MISSING_OR_INVALID\", `pair() params: ${s}`);\n        throw i.setError($.malformed_pairing_uri), new Error(a);\n      }\n      if (!as(s.uri)) {\n        const {\n          message: a\n        } = p(\"MISSING_OR_INVALID\", `pair() uri: ${s.uri}`);\n        throw i.setError($.malformed_pairing_uri), new Error(a);\n      }\n      const n = Me(s?.uri);\n      if (!((r = n?.relay) != null && r.protocol)) {\n        const {\n          message: a\n        } = p(\"MISSING_OR_INVALID\", \"pair() uri#relay-protocol\");\n        throw i.setError($.malformed_pairing_uri), new Error(a);\n      }\n      if (!(n != null && n.symKey)) {\n        const {\n          message: a\n        } = p(\"MISSING_OR_INVALID\", \"pair() uri#symKey\");\n        throw i.setError($.malformed_pairing_uri), new Error(a);\n      }\n      if (n != null && n.expiryTimestamp && E(n?.expiryTimestamp) < Date.now()) {\n        i.setError($.pairing_expired);\n        const {\n          message: a\n        } = p(\"EXPIRED\", \"pair() URI has expired. Please try again with a new connection URI.\");\n        throw new Error(a);\n      }\n    }, this.isValidPing = async s => {\n      if (!ge(s)) {\n        const {\n          message: r\n        } = p(\"MISSING_OR_INVALID\", `ping() params: ${s}`);\n        throw new Error(r);\n      }\n      const {\n        topic: i\n      } = s;\n      await this.isValidPairingTopic(i);\n    }, this.isValidDisconnect = async s => {\n      if (!ge(s)) {\n        const {\n          message: r\n        } = p(\"MISSING_OR_INVALID\", `disconnect() params: ${s}`);\n        throw new Error(r);\n      }\n      const {\n        topic: i\n      } = s;\n      await this.isValidPairingTopic(i);\n    }, this.isValidPairingTopic = async s => {\n      if (!cs(s, !1)) {\n        const {\n          message: i\n        } = p(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${s}`);\n        throw new Error(i);\n      }\n      if (!this.pairings.keys.includes(s)) {\n        const {\n          message: i\n        } = p(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${s}`);\n        throw new Error(i);\n      }\n      if (Ke(this.pairings.get(s).expiry)) {\n        await this.deletePairing(s);\n        const {\n          message: i\n        } = p(\"EXPIRED\", `pairing topic: ${s}`);\n        throw new Error(i);\n      }\n    }, this.core = e, this.logger = I(t, this.name), this.pairings = new li(this.core, this.logger, this.name, this.storagePrefix);\n  }\n  get context() {\n    return S(this.logger);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = p(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  registerRelayerEvents() {\n    this.core.relayer.on(v.message, async e => {\n      const {\n        topic: t,\n        message: s,\n        transportType: i\n      } = e;\n      if (!this.pairings.keys.includes(t) || i === M.link_mode || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s))) return;\n      const r = await this.core.crypto.decode(t, s);\n      try {\n        qe(r) ? (this.core.history.set(t, r), this.onRelayEventRequest({\n          topic: t,\n          payload: r\n        })) : Ge(r) && (await this.core.history.resolve(r), await this.onRelayEventResponse({\n          topic: t,\n          payload: r\n        }), this.core.history.delete(t, r.id));\n      } catch (n) {\n        this.logger.error(n);\n      }\n    });\n  }\n  registerExpirerEvents() {\n    this.core.expirer.on(x.expired, async e => {\n      const {\n        topic: t\n      } = hs(e.target);\n      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, !0), this.events.emit(j.expire, {\n        topic: t\n      }));\n    });\n  }\n}\nclass di extends Ai {\n  constructor(e, t) {\n    super(e, t), this.core = e, this.logger = t, this.records = new Map(), this.events = new K(), this.name = mt, this.version = bt, this.cached = [], this.initialized = !1, this.storagePrefix = A, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach(s => this.records.set(s.id, s)), this.cached = [], this.registerEventListeners(), this.initialized = !0);\n    }, this.set = (s, i, r) => {\n      if (this.isInitialized(), this.logger.debug(\"Setting JSON-RPC request history record\"), this.logger.trace({\n        type: \"method\",\n        method: \"set\",\n        topic: s,\n        request: i,\n        chainId: r\n      }), this.records.has(i.id)) return;\n      const n = {\n        id: i.id,\n        topic: s,\n        request: {\n          method: i.method,\n          params: i.params || null\n        },\n        chainId: r,\n        expiry: Y(te)\n      };\n      this.records.set(n.id, n), this.persist(), this.events.emit(R.created, n);\n    }, this.resolve = async s => {\n      if (this.isInitialized(), this.logger.debug(\"Updating JSON-RPC response history record\"), this.logger.trace({\n        type: \"method\",\n        method: \"update\",\n        response: s\n      }), !this.records.has(s.id)) return;\n      const i = await this.getRecord(s.id);\n      typeof i.response > \"u\" && (i.response = Je(s) ? {\n        error: s.error\n      } : {\n        result: s.result\n      }, this.records.set(i.id, i), this.persist(), this.events.emit(R.updated, i));\n    }, this.get = async (s, i) => (this.isInitialized(), this.logger.debug(\"Getting record\"), this.logger.trace({\n      type: \"method\",\n      method: \"get\",\n      topic: s,\n      id: i\n    }), await this.getRecord(i)), this.delete = (s, i) => {\n      this.isInitialized(), this.logger.debug(\"Deleting record\"), this.logger.trace({\n        type: \"method\",\n        method: \"delete\",\n        id: i\n      }), this.values.forEach(r => {\n        if (r.topic === s) {\n          if (typeof i < \"u\" && r.id !== i) return;\n          this.records.delete(r.id), this.events.emit(R.deleted, r);\n        }\n      }), this.persist();\n    }, this.exists = async (s, i) => (this.isInitialized(), this.records.has(i) ? (await this.getRecord(i)).topic === s : !1), this.on = (s, i) => {\n      this.events.on(s, i);\n    }, this.once = (s, i) => {\n      this.events.once(s, i);\n    }, this.off = (s, i) => {\n      this.events.off(s, i);\n    }, this.removeListener = (s, i) => {\n      this.events.removeListener(s, i);\n    }, this.logger = I(t, this.name);\n  }\n  get context() {\n    return S(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n  get size() {\n    return this.records.size;\n  }\n  get keys() {\n    return Array.from(this.records.keys());\n  }\n  get values() {\n    return Array.from(this.records.values());\n  }\n  get pending() {\n    const e = [];\n    return this.values.forEach(t => {\n      if (typeof t.response < \"u\") return;\n      const s = {\n        topic: t.topic,\n        request: Ye(t.request.method, t.request.params, t.id),\n        chainId: t.chainId\n      };\n      return e.push(s);\n    }), e;\n  }\n  async setJsonRpcRecords(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getJsonRpcRecords() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  getRecord(e) {\n    this.isInitialized();\n    const t = this.records.get(e);\n    if (!t) {\n      const {\n        message: s\n      } = p(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw new Error(s);\n    }\n    return t;\n  }\n  async persist() {\n    await this.setJsonRpcRecords(this.values), this.events.emit(R.sync);\n  }\n  async restore() {\n    try {\n      const e = await this.getJsonRpcRecords();\n      if (typeof e > \"u\" || !e.length) return;\n      if (this.records.size) {\n        const {\n          message: t\n        } = p(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        records: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);\n    }\n  }\n  registerEventListeners() {\n    this.events.on(R.created, e => {\n      const t = R.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        record: e\n      });\n    }), this.events.on(R.updated, e => {\n      const t = R.updated;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        record: e\n      });\n    }), this.events.on(R.deleted, e => {\n      const t = R.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        record: e\n      });\n    }), this.core.heartbeat.on(q.pulse, () => {\n      this.cleanup();\n    });\n  }\n  cleanup() {\n    try {\n      this.isInitialized();\n      let e = !1;\n      this.records.forEach(t => {\n        E(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(R.deleted, t, !1), e = !0);\n      }), e && this.persist();\n    } catch (e) {\n      this.logger.warn(e);\n    }\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = p(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass pi extends Ni {\n  constructor(e, t) {\n    super(e, t), this.core = e, this.logger = t, this.expirations = new Map(), this.events = new K(), this.name = ft, this.version = vt, this.cached = [], this.initialized = !1, this.storagePrefix = A, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach(s => this.expirations.set(s.target, s)), this.cached = [], this.registerEventListeners(), this.initialized = !0);\n    }, this.has = s => {\n      try {\n        const i = this.formatTarget(s);\n        return typeof this.getExpiration(i) < \"u\";\n      } catch {\n        return !1;\n      }\n    }, this.set = (s, i) => {\n      this.isInitialized();\n      const r = this.formatTarget(s),\n        n = {\n          target: r,\n          expiry: i\n        };\n      this.expirations.set(r, n), this.checkExpiry(r, n), this.events.emit(x.created, {\n        target: r,\n        expiration: n\n      });\n    }, this.get = s => {\n      this.isInitialized();\n      const i = this.formatTarget(s);\n      return this.getExpiration(i);\n    }, this.del = s => {\n      if (this.isInitialized(), this.has(s)) {\n        const i = this.formatTarget(s),\n          r = this.getExpiration(i);\n        this.expirations.delete(i), this.events.emit(x.deleted, {\n          target: i,\n          expiration: r\n        });\n      }\n    }, this.on = (s, i) => {\n      this.events.on(s, i);\n    }, this.once = (s, i) => {\n      this.events.once(s, i);\n    }, this.off = (s, i) => {\n      this.events.off(s, i);\n    }, this.removeListener = (s, i) => {\n      this.events.removeListener(s, i);\n    }, this.logger = I(t, this.name);\n  }\n  get context() {\n    return S(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n  get length() {\n    return this.expirations.size;\n  }\n  get keys() {\n    return Array.from(this.expirations.keys());\n  }\n  get values() {\n    return Array.from(this.expirations.values());\n  }\n  formatTarget(e) {\n    if (typeof e == \"string\") return ls(e);\n    if (typeof e == \"number\") return us(e);\n    const {\n      message: t\n    } = p(\"UNKNOWN_TYPE\", `Target type: ${typeof e}`);\n    throw new Error(t);\n  }\n  async setExpirations(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getExpirations() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  async persist() {\n    await this.setExpirations(this.values), this.events.emit(x.sync);\n  }\n  async restore() {\n    try {\n      const e = await this.getExpirations();\n      if (typeof e > \"u\" || !e.length) return;\n      if (this.expirations.size) {\n        const {\n          message: t\n        } = p(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        expirations: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);\n    }\n  }\n  getExpiration(e) {\n    const t = this.expirations.get(e);\n    if (!t) {\n      const {\n        message: s\n      } = p(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw this.logger.warn(s), new Error(s);\n    }\n    return t;\n  }\n  checkExpiry(e, t) {\n    const {\n      expiry: s\n    } = t;\n    E(s) - Date.now() <= 0 && this.expire(e, t);\n  }\n  expire(e, t) {\n    this.expirations.delete(e), this.events.emit(x.expired, {\n      target: e,\n      expiration: t\n    });\n  }\n  checkExpirations() {\n    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));\n  }\n  registerEventListeners() {\n    this.core.heartbeat.on(q.pulse, () => this.checkExpirations()), this.events.on(x.created, e => {\n      const t = x.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), this.persist();\n    }), this.events.on(x.expired, e => {\n      const t = x.expired;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), this.persist();\n    }), this.events.on(x.deleted, e => {\n      const t = x.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), this.persist();\n    });\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = p(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass gi extends zi {\n  constructor(e, t, s) {\n    super(e, t, s), this.core = e, this.logger = t, this.store = s, this.name = _t, this.verifyUrlV3 = wt, this.storagePrefix = A, this.version = De, this.init = async () => {\n      var i;\n      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && E((i = this.publicKey) == null ? void 0 : i.expiresAt) < Date.now() && (this.logger.debug(\"verify v2 public key expired\"), await this.removePublicKey()));\n    }, this.register = async i => {\n      if (!ds() || this.isDevEnv) return;\n      const r = window.location.origin,\n        {\n          id: n,\n          decryptedId: a\n        } = i,\n        c = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${r}&id=${n}&decryptedId=${a}`;\n      try {\n        const h = Es(),\n          u = this.startAbortTimer(F * 5),\n          d = await new Promise((y, m) => {\n            const l = () => {\n              window.removeEventListener(\"message\", w), h.body.removeChild(g), m(\"attestation aborted\");\n            };\n            this.abortController.signal.addEventListener(\"abort\", l);\n            const g = h.createElement(\"iframe\");\n            g.src = c, g.style.display = \"none\", g.addEventListener(\"error\", l, {\n              signal: this.abortController.signal\n            });\n            const w = b => {\n              if (b.data && typeof b.data == \"string\") try {\n                const D = JSON.parse(b.data);\n                if (D.type === \"verify_attestation\") {\n                  if (Re(D.attestation).payload.id !== n) return;\n                  clearInterval(u), h.body.removeChild(g), this.abortController.signal.removeEventListener(\"abort\", l), window.removeEventListener(\"message\", w), y(D.attestation === null ? \"\" : D.attestation);\n                }\n              } catch (D) {\n                this.logger.warn(D);\n              }\n            };\n            h.body.appendChild(g), window.addEventListener(\"message\", w, {\n              signal: this.abortController.signal\n            });\n          });\n        return this.logger.debug(\"jwt attestation\", d), d;\n      } catch (h) {\n        this.logger.warn(h);\n      }\n      return \"\";\n    }, this.resolve = async i => {\n      if (this.isDevEnv) return \"\";\n      const {\n        attestationId: r,\n        hash: n,\n        encryptedId: a\n      } = i;\n      if (r === \"\") {\n        this.logger.debug(\"resolve: attestationId is empty, skipping\");\n        return;\n      }\n      if (r) {\n        if (Re(r).payload.id !== a) return;\n        const h = await this.isValidJwtAttestation(r);\n        if (h) {\n          if (!h.isVerified) {\n            this.logger.warn(\"resolve: jwt attestation: origin url not verified\");\n            return;\n          }\n          return h;\n        }\n      }\n      if (!n) return;\n      const c = this.getVerifyUrl(i?.verifyUrl);\n      return this.fetchAttestation(n, c);\n    }, this.fetchAttestation = async (i, r) => {\n      this.logger.debug(`resolving attestation: ${i} from url: ${r}`);\n      const n = this.startAbortTimer(F * 5),\n        a = await fetch(`${r}/attestation/${i}?v2Supported=true`, {\n          signal: this.abortController.signal\n        });\n      return clearTimeout(n), a.status === 200 ? await a.json() : void 0;\n    }, this.getVerifyUrl = i => {\n      let r = i || X;\n      return It.includes(r) || (this.logger.info(`verify url: ${r}, not included in trusted list, assigning default: ${X}`), r = X), r;\n    }, this.fetchPublicKey = async () => {\n      try {\n        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);\n        const i = this.startAbortTimer(ae),\n          r = await fetch(`${this.verifyUrlV3}/public-key`, {\n            signal: this.abortController.signal\n          });\n        return clearTimeout(i), await r.json();\n      } catch (i) {\n        this.logger.warn(i);\n      }\n    }, this.persistPublicKey = async i => {\n      this.logger.debug(\"persisting public key to local storage\", i), await this.store.setItem(this.storeKey, i), this.publicKey = i;\n    }, this.removePublicKey = async () => {\n      this.logger.debug(\"removing verify v2 public key from storage\"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;\n    }, this.isValidJwtAttestation = async i => {\n      const r = await this.getPublicKey();\n      try {\n        if (r) return this.validateAttestation(i, r);\n      } catch (a) {\n        this.logger.error(a), this.logger.warn(\"error validating attestation\");\n      }\n      const n = await this.fetchAndPersistPublicKey();\n      try {\n        if (n) return this.validateAttestation(i, n);\n      } catch (a) {\n        this.logger.error(a), this.logger.warn(\"error validating attestation\");\n      }\n    }, this.getPublicKey = async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey(), this.fetchAndPersistPublicKey = async () => {\n      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;\n      this.fetchPromise = new Promise(async r => {\n        const n = await this.fetchPublicKey();\n        n && (await this.persistPublicKey(n), r(n));\n      });\n      const i = await this.fetchPromise;\n      return this.fetchPromise = void 0, i;\n    }, this.validateAttestation = (i, r) => {\n      const n = ps(i, r.publicKey),\n        a = {\n          hasExpired: E(n.exp) < Date.now(),\n          payload: n\n        };\n      if (a.hasExpired) throw this.logger.warn(\"resolve: jwt attestation expired\"), new Error(\"JWT attestation expired\");\n      return {\n        origin: a.payload.origin,\n        isScam: a.payload.isScam,\n        isVerified: a.payload.isVerified\n      };\n    }, this.logger = I(t, this.name), this.abortController = new AbortController(), this.isDevEnv = Be(), this.init();\n  }\n  get storeKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//verify:public:key\";\n  }\n  get context() {\n    return S(this.logger);\n  }\n  startAbortTimer(e) {\n    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), E(e));\n  }\n}\nclass yi extends Li {\n  constructor(e, t) {\n    super(e, t), this.projectId = e, this.logger = t, this.context = Tt, this.registerDeviceToken = async s => {\n      const {\n          clientId: i,\n          token: r,\n          notificationType: n,\n          enableEncrypted: a = !1\n        } = s,\n        c = `${Ct}/${this.projectId}/clients`;\n      await fetch(c, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          client_id: i,\n          type: n,\n          token: r,\n          always_raw: a\n        })\n      });\n    }, this.logger = I(t, this.context);\n  }\n}\nvar wn = Object.defineProperty,\n  Di = Object.getOwnPropertySymbols,\n  In = Object.prototype.hasOwnProperty,\n  Tn = Object.prototype.propertyIsEnumerable,\n  mi = (o, e, t) => e in o ? wn(o, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : o[e] = t,\n  Q = (o, e) => {\n    for (var t in e || (e = {})) In.call(e, t) && mi(o, t, e[t]);\n    if (Di) for (var t of Di(e)) Tn.call(e, t) && mi(o, t, e[t]);\n    return o;\n  };\nclass bi extends $i {\n  constructor(e, t, s = !0) {\n    super(e, t, s), this.core = e, this.logger = t, this.context = St, this.storagePrefix = A, this.storageVersion = Pt, this.events = new Map(), this.shouldPersist = !1, this.init = async () => {\n      if (!Be()) try {\n        const i = {\n          eventId: Ve(),\n          timestamp: Date.now(),\n          domain: this.getAppDomain(),\n          props: {\n            event: \"INIT\",\n            type: \"\",\n            properties: {\n              client_id: await this.core.crypto.getClientId(),\n              user_agent: gs(this.core.relayer.protocol, this.core.relayer.version, re)\n            }\n          }\n        };\n        await this.sendEvent([i]);\n      } catch (i) {\n        this.logger.warn(i);\n      }\n    }, this.createEvent = i => {\n      const {\n          event: r = \"ERROR\",\n          type: n = \"\",\n          properties: {\n            topic: a,\n            trace: c\n          }\n        } = i,\n        h = Ve(),\n        u = this.core.projectId || \"\",\n        d = Date.now(),\n        y = Q({\n          eventId: h,\n          timestamp: d,\n          props: {\n            event: r,\n            type: n,\n            properties: {\n              topic: a,\n              trace: c\n            }\n          },\n          bundleId: u,\n          domain: this.getAppDomain()\n        }, this.setMethods(h));\n      return this.telemetryEnabled && (this.events.set(h, y), this.shouldPersist = !0), y;\n    }, this.getEvent = i => {\n      const {\n        eventId: r,\n        topic: n\n      } = i;\n      if (r) return this.events.get(r);\n      const a = Array.from(this.events.values()).find(c => c.props.properties.topic === n);\n      if (a) return Q(Q({}, a), this.setMethods(a.eventId));\n    }, this.deleteEvent = i => {\n      const {\n        eventId: r\n      } = i;\n      this.events.delete(r), this.shouldPersist = !0;\n    }, this.setEventListeners = () => {\n      this.core.heartbeat.on(q.pulse, async () => {\n        this.shouldPersist && (await this.persist()), this.events.forEach(i => {\n          Pe(Date.now()) - Pe(i.timestamp) > Rt && (this.events.delete(i.eventId), this.shouldPersist = !0);\n        });\n      });\n    }, this.setMethods = i => ({\n      addTrace: r => this.addTrace(i, r),\n      setError: r => this.setError(i, r)\n    }), this.addTrace = (i, r) => {\n      const n = this.events.get(i);\n      n && (n.props.properties.trace.push(r), this.events.set(i, n), this.shouldPersist = !0);\n    }, this.setError = (i, r) => {\n      const n = this.events.get(i);\n      n && (n.props.type = r, n.timestamp = Date.now(), this.events.set(i, n), this.shouldPersist = !0);\n    }, this.persist = async () => {\n      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = !1;\n    }, this.restore = async () => {\n      try {\n        const i = (await this.core.storage.getItem(this.storageKey)) || [];\n        if (!i.length) return;\n        i.forEach(r => {\n          this.events.set(r.eventId, Q(Q({}, r), this.setMethods(r.eventId)));\n        });\n      } catch (i) {\n        this.logger.warn(i);\n      }\n    }, this.submit = async () => {\n      if (!this.telemetryEnabled || this.events.size === 0) return;\n      const i = [];\n      for (const [r, n] of this.events) n.props.type && i.push(n);\n      if (i.length !== 0) try {\n        if ((await this.sendEvent(i)).ok) for (const r of i) this.events.delete(r.eventId), this.shouldPersist = !0;\n      } catch (r) {\n        this.logger.warn(r);\n      }\n    }, this.sendEvent = async i => {\n      const r = this.getAppDomain() ? \"\" : \"&sp=desktop\";\n      return await fetch(`${xt}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${re}${r}`, {\n        method: \"POST\",\n        body: JSON.stringify(i)\n      });\n    }, this.getAppDomain = () => ys().url, this.logger = I(t, this.context), this.telemetryEnabled = s, s ? this.restore().then(async () => {\n      await this.submit(), this.setEventListeners();\n    }) : this.persist();\n  }\n  get storageKey() {\n    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + \"//\" + this.context;\n  }\n}\nvar Cn = Object.defineProperty,\n  fi = Object.getOwnPropertySymbols,\n  Pn = Object.prototype.hasOwnProperty,\n  Sn = Object.prototype.propertyIsEnumerable,\n  vi = (o, e, t) => e in o ? Cn(o, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : o[e] = t,\n  _i = (o, e) => {\n    for (var t in e || (e = {})) Pn.call(e, t) && vi(o, t, e[t]);\n    if (fi) for (var t of fi(e)) Sn.call(e, t) && vi(o, t, e[t]);\n    return o;\n  };\nclass oe extends ki {\n  constructor(e) {\n    var t;\n    super(e), this.protocol = ye, this.version = De, this.name = J, this.events = new K(), this.initialized = !1, this.on = (n, a) => this.events.on(n, a), this.once = (n, a) => this.events.once(n, a), this.off = (n, a) => this.events.off(n, a), this.removeListener = (n, a) => this.events.removeListener(n, a), this.dispatchEnvelope = ({\n      topic: n,\n      message: a,\n      sessionExists: c\n    }) => {\n      if (!n || !a) return;\n      const h = {\n        topic: n,\n        message: a,\n        publishedAt: Date.now(),\n        transportType: M.link_mode\n      };\n      this.relayer.onLinkMessageEvent(h, {\n        sessionExists: c\n      });\n    }, this.projectId = e?.projectId, this.relayUrl = e?.relayUrl || fe, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : \"\";\n    const s = Te({\n        level: typeof e?.logger == \"string\" && e.logger ? e.logger : Xe.logger,\n        name: J\n      }),\n      {\n        logger: i,\n        chunkLoggerController: r\n      } = Ci({\n        opts: s,\n        maxSizeInBytes: e?.maxLogBlobSizeInBytes,\n        loggerOverride: e?.logger\n      });\n    this.logChunkController = r, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {\n      var n, a;\n      (n = this.logChunkController) != null && n.downloadLogsBlobInBrowser && ((a = this.logChunkController) == null || a.downloadLogsBlobInBrowser({\n        clientId: await this.crypto.getClientId()\n      }));\n    }), this.logger = I(i, this.name), this.heartbeat = new wi(), this.crypto = new Yt(this, this.logger, e?.keychain), this.history = new di(this, this.logger), this.expirer = new pi(this, this.logger), this.storage = e != null && e.storage ? e.storage : new Ii(_i(_i({}, We), e?.storageOptions)), this.relayer = new oi({\n      core: this,\n      logger: this.logger,\n      relayUrl: this.relayUrl,\n      projectId: this.projectId\n    }), this.pairing = new ui(this, this.logger), this.verify = new gi(this, this.logger, this.storage), this.echoClient = new yi(this.projectId || \"\", this.logger), this.linkModeSupportedApps = [], this.eventClient = new bi(this, this.logger, e?.telemetryEnabled);\n  }\n  static async init(e) {\n    const t = new oe(e);\n    await t.initialize();\n    const s = await t.crypto.getClientId();\n    return await t.storage.setItem(ut, s), t;\n  }\n  get context() {\n    return S(this.logger);\n  }\n  async start() {\n    this.initialized || (await this.initialize());\n  }\n  async getLogsBlob() {\n    var e;\n    return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({\n      clientId: await this.crypto.getClientId()\n    });\n  }\n  async addLinkModeSupportedApp(e) {\n    this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(ve, this.linkModeSupportedApps));\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.eventClient.init(), this.linkModeSupportedApps = (await this.storage.getItem(ve)) || [], this.initialized = !0, this.logger.info(\"Core Initialization Success\");\n    } catch (e) {\n      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;\n    }\n  }\n}\nconst Rn = oe;\nexport { J as CORE_CONTEXT, Xe as CORE_DEFAULT, ye as CORE_PROTOCOL, We as CORE_STORAGE_OPTIONS, A as CORE_STORAGE_PREFIX, De as CORE_VERSION, me as CRYPTO_CLIENT_SEED, Ze as CRYPTO_CONTEXT, Qe as CRYPTO_JWT_TTL, Rn as Core, Yt as Crypto, Tt as ECHO_CONTEXT, Ct as ECHO_URL, xt as EVENTS_CLIENT_API_URL, Rt as EVENTS_STORAGE_CLEANUP_INTERVAL, St as EVENTS_STORAGE_CONTEXT, Pt as EVENTS_STORAGE_VERSION, Ns as EVENT_CLIENT_AUTHENTICATE_ERRORS, As as EVENT_CLIENT_AUTHENTICATE_TRACES, Rs as EVENT_CLIENT_CONTEXT, $ as EVENT_CLIENT_PAIRING_ERRORS, z as EVENT_CLIENT_PAIRING_TRACES, Os as EVENT_CLIENT_SESSION_ERRORS, xs as EVENT_CLIENT_SESSION_TRACES, ft as EXPIRER_CONTEXT, Ps as EXPIRER_DEFAULT_TTL, x as EXPIRER_EVENTS, vt as EXPIRER_STORAGE_VERSION, yi as EchoClient, bi as EventClient, pi as Expirer, mt as HISTORY_CONTEXT, R as HISTORY_EVENTS, bt as HISTORY_STORAGE_VERSION, di as JsonRpcHistory, et as KEYCHAIN_CONTEXT, tt as KEYCHAIN_STORAGE_VERSION, Ht as KeyChain, it as MESSAGES_CONTEXT, st as MESSAGES_STORAGE_VERSION, Jt as MessageTracker, yt as PAIRING_CONTEXT, Cs as PAIRING_DEFAULT_TTL, j as PAIRING_EVENTS, V as PAIRING_RPC_OPTS, Dt as PAIRING_STORAGE_VERSION, gt as PENDING_SUB_RESOLUTION_TIMEOUT, rt as PUBLISHER_CONTEXT, be as PUBLISHER_DEFAULT_TTL, ui as Pairing, at as RELAYER_CONTEXT, ot as RELAYER_DEFAULT_LOGGER, nt as RELAYER_DEFAULT_PROTOCOL, fe as RELAYER_DEFAULT_RELAY_URL, v as RELAYER_EVENTS, C as RELAYER_PROVIDER_EVENTS, ht as RELAYER_RECONNECT_TIMEOUT, re as RELAYER_SDK_VERSION, ws as RELAYER_STORAGE_OPTIONS, ct as RELAYER_SUBSCRIBER_SUFFIX, Is as RELAYER_TRANSPORT_CUTOFF, oi as Relayer, lt as STORE_STORAGE_VERSION, dt as SUBSCRIBER_CONTEXT, Ts as SUBSCRIBER_DEFAULT_TTL, T as SUBSCRIBER_EVENTS, pt as SUBSCRIBER_STORAGE_VERSION, li as Store, ii as Subscriber, M as TRANSPORT_TYPES, It as TRUSTED_VERIFY_URLS, _t as VERIFY_CONTEXT, X as VERIFY_SERVER, wt as VERIFY_SERVER_V3, gi as Verify, ut as WALLETCONNECT_CLIENT_ID, ve as WALLETCONNECT_LINK_MODE_APPS, oe as default };\n//# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}