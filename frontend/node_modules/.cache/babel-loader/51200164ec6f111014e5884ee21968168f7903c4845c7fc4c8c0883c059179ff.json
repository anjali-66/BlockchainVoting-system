{"ast":null,"code":"import { getCachedChain } from \"../../chains/utils.js\";\nimport { getContract } from \"../../contract/contract.js\";\nimport { isAddress } from \"../address.js\";\n/**\n * Parses the NFT metadata and options to create an NFT object.\n * @param base - The base NFT metadata.\n * @param options - The options for parsing the NFT.\n * @returns The parsed NFT object.\n * @internal\n */\nexport function parseNFT(base, options) {\n  switch (options.type) {\n    case \"ERC721\":\n      return {\n        metadata: base,\n        owner: options?.owner ?? null,\n        id: options.tokenId,\n        tokenURI: options.tokenUri,\n        type: options.type\n      };\n    case \"ERC1155\":\n      return {\n        metadata: base,\n        owner: options?.owner ?? null,\n        id: options.tokenId,\n        tokenURI: options.tokenUri,\n        type: options.type,\n        supply: options.supply\n      };\n    default:\n      throw new Error(\"Invalid NFT type\");\n  }\n}\n/**\n * Parses an NFT URI.\n * @param options - The options for parsing an NFT URI.\n * @param options.client - The Thirdweb client.\n * @param options.uri - The NFT URI to parse.\n * @returns A promise that resolves to the NFT URI, or null if the URI could not be parsed.\n *\n * @example\n * ```ts\n * import { parseNftUri } from \"thirdweb/utils/ens\";\n * const nftUri = await parseNftUri({\n *    client,\n *    uri: \"eip155:1/erc1155:0xb32979486938aa9694bfc898f35dbed459f44424/10063\",\n * });\n *\n * console.log(nftUri); // ipfs://bafybeiemxf5abjwjbikoz4mc3a3dla6ual3jsgpdr4cjr3oz3evfyavhwq/\n * ```\n *\n * @extension ENS\n *\n */\nexport async function parseNftUri(options) {\n  let uri = options.uri;\n  // parse valid nft spec (CAIP-22/CAIP-29)\n  // @see: https://github.com/ChainAgnostic/CAIPs/tree/master/CAIPs\n  if (uri.startsWith(\"did:nft:\")) {\n    // convert DID to CAIP\n    uri = uri.replace(\"did:nft:\", \"\").replace(/_/g, \"/\");\n  }\n  const [reference = \"\", asset_namespace = \"\", tokenID = \"\"] = uri.split(\"/\");\n  const [eip_namespace, chainID] = reference.split(\":\");\n  const [erc_namespace, contractAddress] = asset_namespace.split(\":\");\n  if (!eip_namespace || eip_namespace.toLowerCase() !== \"eip155\") {\n    throw new Error(`Invalid EIP namespace, expected EIP155, got: \"${eip_namespace}\"`);\n  }\n  if (!chainID) {\n    throw new Error(\"Chain ID not found\");\n  }\n  if (!contractAddress || !isAddress(contractAddress)) {\n    throw new Error(\"Contract address not found\");\n  }\n  if (!tokenID) {\n    throw new Error(\"Token ID not found\");\n  }\n  const chain = getCachedChain(Number(chainID));\n  const contract = getContract({\n    client: options.client,\n    chain,\n    address: contractAddress\n  });\n  switch (erc_namespace) {\n    case \"erc721\":\n      {\n        const {\n          getNFT\n        } = await import(\"../../extensions/erc721/read/getNFT.js\");\n        const nft = await getNFT({\n          contract,\n          tokenId: BigInt(tokenID)\n        });\n        return nft.metadata.image ?? null;\n      }\n    case \"erc1155\":\n      {\n        const {\n          getNFT\n        } = await import(\"../../extensions/erc1155/read/getNFT.js\");\n        const nft = await getNFT({\n          contract,\n          tokenId: BigInt(tokenID)\n        });\n        return nft.metadata.image ?? null;\n      }\n    default:\n      {\n        throw new Error(`Invalid ERC namespace, expected ERC721 or ERC1155, got: \"${erc_namespace}\"`);\n      }\n  }\n}\n//# sourceMappingURL=parseNft.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}