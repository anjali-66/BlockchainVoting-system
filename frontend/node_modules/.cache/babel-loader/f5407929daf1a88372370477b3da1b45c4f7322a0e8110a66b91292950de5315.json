{"ast":null,"code":"\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport { isEcosystemWallet } from \"../../../../wallets/ecosystem/is-ecosystem-wallet.js\";\nimport { ClientScopedStorage } from \"../../../../wallets/in-app/core/authentication/client-scoped-storage.js\";\nimport { getUrlToken } from \"../../../../wallets/in-app/web/lib/get-url-token.js\";\nimport { getLastConnectedChain, getStoredActiveWalletId, getStoredConnectedWalletIds } from \"../../../../wallets/manager/index.js\";\nimport { useConnectionManagerCtx } from \"../../providers/connection-manager.js\";\nimport { setLastAuthProvider } from \"../../utils/storage.js\";\nimport { timeoutPromise } from \"../../utils/timeoutPromise.js\";\nimport { useConnect } from \"./useConnect.js\";\nimport { useSetActiveWalletConnectionStatus } from \"./useSetActiveWalletConnectionStatus.js\";\nexport function useAutoConnectCore(storage, props, createWalletFn, getInstalledWallets) {\n  const manager = useConnectionManagerCtx(\"useAutoConnect\");\n  const setConnectionStatus = useSetActiveWalletConnectionStatus();\n  const {\n    connect\n  } = useConnect({\n    client: props.client,\n    accountAbstraction: props.accountAbstraction\n  });\n  const {\n    isAutoConnecting\n  } = manager;\n  const {\n    wallets,\n    onConnect\n  } = props;\n  const timeout = props.timeout ?? 15000;\n  // get the supported wallets from thirdweb provider\n  // check the storage for last connected wallets and connect them all\n  // check the storage for last active wallet and set it as active\n  const autoConnect = async () => {\n    let autoConnected = false;\n    isAutoConnecting.setValue(true);\n    let [lastConnectedWalletIds, lastActiveWalletId] = await Promise.all([getStoredConnectedWalletIds(storage), getStoredActiveWalletId(storage)]);\n    const {\n      authResult,\n      walletId,\n      authProvider,\n      authCookie\n    } = getUrlToken();\n    const wallet = wallets.find(w => w.id === walletId);\n    // If an auth cookie is found and this site supports the wallet, we'll set the auth cookie in the client storage\n    if (authCookie && wallet) {\n      const clientStorage = new ClientScopedStorage({\n        storage,\n        clientId: props.client.clientId,\n        ecosystem: isEcosystemWallet(wallet) ? {\n          id: wallet.id,\n          partnerId: wallet.getConfig()?.partnerId\n        } : undefined\n      });\n      await clientStorage.saveAuthCookie(authCookie);\n    }\n    if (walletId) {\n      lastActiveWalletId = walletId;\n      lastConnectedWalletIds = lastConnectedWalletIds?.includes(walletId) ? lastConnectedWalletIds : [walletId, ...(lastConnectedWalletIds || [])];\n    }\n    if (authProvider) {\n      await setLastAuthProvider(authProvider, storage);\n    }\n    // if no wallets were last connected or we didn't receive an auth token\n    if (!lastConnectedWalletIds) {\n      return autoConnected;\n    }\n    // this flow can actually be used for a first connection in the case of a redirect\n    // in that case, we default to the passed chain to connect to\n    const lastConnectedChain = (await getLastConnectedChain(storage)) || props.chain;\n    async function handleWalletConnection(wallet) {\n      return wallet.autoConnect({\n        client: props.client,\n        chain: lastConnectedChain ?? undefined,\n        authResult\n      });\n    }\n    const availableWallets = [...wallets, ...(getInstalledWallets?.() ?? [])];\n    const activeWallet = lastActiveWalletId && (availableWallets.find(w => w.id === lastActiveWalletId) || createWalletFn(lastActiveWalletId));\n    if (activeWallet) {\n      try {\n        setConnectionStatus(\"connecting\"); // only set connecting status if we are connecting the last active EOA\n        await timeoutPromise(handleWalletConnection(activeWallet), {\n          ms: timeout,\n          message: `AutoConnect timeout: ${timeout}ms limit exceeded.`\n        });\n        // connected wallet could be activeWallet or smart wallet\n        const connectedWallet = await connect(activeWallet);\n        if (connectedWallet) {\n          if (onConnect) {\n            try {\n              onConnect(connectedWallet);\n              autoConnected = true;\n            } catch {\n              // ignore\n            }\n          }\n        } else {\n          setConnectionStatus(\"disconnected\");\n        }\n      } catch (e) {\n        if (e instanceof Error) {\n          console.warn(\"Error auto connecting wallet:\", e.message);\n        }\n        setConnectionStatus(\"disconnected\");\n      }\n    } else {\n      setConnectionStatus(\"disconnected\");\n    }\n    // then connect wallets that were last connected but were not set as active\n    const otherWallets = availableWallets.filter(w => w.id !== lastActiveWalletId && lastConnectedWalletIds.includes(w.id));\n    for (const wallet of otherWallets) {\n      try {\n        await handleWalletConnection(wallet);\n        manager.addConnectedWallet(wallet);\n      } catch {\n        // no-op\n      }\n    }\n    isAutoConnecting.setValue(false);\n    return autoConnected; // useQuery needs a return value\n  };\n  // trigger the auto connect on first mount only\n  const query = useQuery({\n    queryKey: [\"autoConnect\", props.client.clientId],\n    queryFn: autoConnect,\n    refetchOnMount: false,\n    refetchOnWindowFocus: false\n  });\n  return query;\n}\n//# sourceMappingURL=useAutoConnect.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}