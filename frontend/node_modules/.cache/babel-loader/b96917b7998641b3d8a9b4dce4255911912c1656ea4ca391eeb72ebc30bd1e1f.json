{"ast":null,"code":"import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { IdCardIcon } from \"@radix-ui/react-icons\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { getCachedChain } from \"../../../../../../../chains/utils.js\";\nimport { NATIVE_TOKEN_ADDRESS } from \"../../../../../../../constants/addresses.js\";\nimport { getWalletBalance } from \"../../../../../../../wallets/utils/getWalletBalance.js\";\nimport { useCustomTheme } from \"../../../../../../core/design-system/CustomThemeProvider.js\";\nimport { iconSize, radius, spacing } from \"../../../../../../core/design-system/index.js\";\nimport { useChainMetadata } from \"../../../../../../core/hooks/others/useChainQuery.js\";\nimport { useActiveAccount } from \"../../../../../../core/hooks/wallets/useActiveAccount.js\";\nimport { useConnectedWallets } from \"../../../../../../core/hooks/wallets/useConnectedWallets.js\";\nimport { LoadingScreen } from \"../../../../../wallets/shared/LoadingScreen.js\";\nimport { Spacer } from \"../../../../components/Spacer.js\";\nimport { Container } from \"../../../../components/basic.js\";\nimport { Button } from \"../../../../components/buttons.js\";\nimport { Text } from \"../../../../components/text.js\";\nimport { OutlineWalletIcon } from \"../../../icons/OutlineWalletIcon.js\";\nimport { isNativeToken } from \"../../nativeToken.js\";\nimport { WalletRowWithBalances } from \"../WalletSelectorButton.js\";\nexport function PaymentSelectionScreen(props) {\n  const theme = useCustomTheme();\n  const connectedWallets = useConnectedWallets();\n  // if all wallets are connected and showAll wallets is disabled, hide the connect button\n  const hideConnectButton = !props.showAllWallets && props.wallets?.every(w => connectedWallets.includes(w));\n  const chainInfo = useChainMetadata(props.toChain);\n  const activeAccount = useActiveAccount();\n  const walletsAndBalances = useQuery({\n    queryKey: [\"wallets-and-balances\", connectedWallets.map(w => w.getAccount()?.address), props.sourceSupportedTokens, props.toChain.id, props.toToken, props.tokenAmount, props.mode, activeAccount?.address],\n    queryFn: async () => {\n      // in parallel, get the balances of all the wallets on each of the sourceSupportedTokens\n      const walletBalanceMap = new Map();\n      const balancePromises = connectedWallets.flatMap(wallet => {\n        const account = wallet.getAccount();\n        if (!account) return [];\n        walletBalanceMap.set(wallet, []);\n        // inject the destination token too since it can be used as well to pay/transfer\n        const toToken = isNativeToken(props.toToken) ? {\n          address: NATIVE_TOKEN_ADDRESS,\n          name: chainInfo.data?.nativeCurrency.name || \"\",\n          symbol: chainInfo.data?.nativeCurrency.symbol || \"\",\n          icon: chainInfo.data?.icon?.url\n        } : props.toToken;\n        const tokens = {\n          ...props.sourceSupportedTokens,\n          [props.toChain.id]: [toToken, ...(props.sourceSupportedTokens?.[props.toChain.id] || [])]\n        };\n        return Object.entries(tokens).flatMap(([chainId, tokens]) => {\n          return tokens.map(async token => {\n            try {\n              const chain = getCachedChain(Number(chainId));\n              const balance = await getWalletBalance({\n                address: account.address,\n                chain,\n                tokenAddress: isNativeToken(token) ? undefined : token.address,\n                client: props.client\n              });\n              // show the token if:\n              // - its not the destination token and balance is greater than 0\n              // - its the destination token and balance is greater than the token amount AND we the account is not the default account in fund_wallet mode\n              const shouldInclude = token.address === toToken.address && chain.id === props.toChain.id ? props.mode === \"fund_wallet\" && account.address === activeAccount?.address ? false : Number(balance.displayValue) > Number(props.tokenAmount) : balance.value > 0n;\n              if (shouldInclude) {\n                const existingBalances = walletBalanceMap.get(wallet) || [];\n                existingBalances.push({\n                  balance,\n                  chain,\n                  token\n                });\n                existingBalances.sort((a, b) => {\n                  if (a.chain.id === props.toChain.id && a.token.address === toToken.address) return -1;\n                  if (b.chain.id === props.toChain.id && b.token.address === toToken.address) return 1;\n                  if (a.chain.id === props.toChain.id) return -1;\n                  if (b.chain.id === props.toChain.id) return 1;\n                  return a.chain.id > b.chain.id ? 1 : -1;\n                });\n              }\n            } catch (error) {\n              console.error(`Failed to fetch balance for wallet ${wallet.id} on chain ${chainId} for token ${token.symbol}:`, error);\n            }\n          });\n        });\n      });\n      await Promise.all(balancePromises);\n      return walletBalanceMap;\n    },\n    enabled: !!props.sourceSupportedTokens && !!chainInfo.data\n  });\n  if (walletsAndBalances.isLoading || !walletsAndBalances.data) {\n    return _jsx(LoadingScreen, {});\n  }\n  return _jsxs(Container, {\n    children: [_jsxs(Container, {\n      flex: \"column\",\n      gap: \"xs\",\n      children: [Array.from(walletsAndBalances.data?.entries() || []).filter(([w]) => !props.hiddenWallets?.includes(w.id)).map(([w, balances]) => {\n        const address = w.getAccount()?.address;\n        if (!address) return null;\n        return _jsx(WalletRowWithBalances, {\n          wallet: w,\n          balances: balances,\n          client: props.client,\n          address: address,\n          onClick: props.onSelect\n        }, w.id);\n      }), !hideConnectButton && _jsx(Button, {\n        variant: \"secondary\",\n        fullWidth: true,\n        onClick: props.onConnect,\n        gap: \"xs\",\n        bg: \"tertiaryBg\",\n        style: {\n          borderRadius: radius.lg,\n          border: `1px solid ${theme.colors.borderColor}`,\n          padding: spacing.sm\n        },\n        children: _jsxs(Container, {\n          flex: \"row\",\n          gap: \"sm\",\n          center: \"y\",\n          expand: true,\n          color: \"secondaryIconColor\",\n          children: [_jsx(OutlineWalletIcon, {\n            size: iconSize.md\n          }), _jsx(Text, {\n            size: \"sm\",\n            color: \"primaryText\",\n            children: \"Pay with another wallet\"\n          })]\n        })\n      }), props.payWithFiatEnabled && _jsx(Button, {\n        variant: \"secondary\",\n        fullWidth: true,\n        gap: \"xs\",\n        bg: \"tertiaryBg\",\n        onClick: props.onSelectFiat,\n        style: {\n          borderRadius: radius.lg,\n          border: `1px solid ${theme.colors.borderColor}`,\n          padding: spacing.sm\n        },\n        children: _jsxs(Container, {\n          flex: \"row\",\n          gap: \"sm\",\n          center: \"y\",\n          expand: true,\n          color: \"secondaryIconColor\",\n          children: [_jsx(IdCardIcon, {\n            style: {\n              width: iconSize.md,\n              height: iconSize.md\n            }\n          }), _jsx(Text, {\n            size: \"sm\",\n            color: \"primaryText\",\n            children: \"Pay with credit card\"\n          })]\n        })\n      })]\n    }), _jsx(Spacer, {\n      y: \"sm\"\n    })]\n  });\n}\n//# sourceMappingURL=PaymentSelectionScreen.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}