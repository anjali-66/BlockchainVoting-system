{"ast":null,"code":"import { getRpcUrlForChain } from \"../chains/utils.js\";\nimport { stringify } from \"../utils/json.js\";\nimport { fetchRpc, fetchSingleRpc } from \"./fetch-rpc.js\";\nconst RPC_CLIENT_MAP = new WeakMap();\n/**\n * @internal\n */\nfunction getRpcClientMap(client) {\n  if (RPC_CLIENT_MAP.has(client)) {\n    return RPC_CLIENT_MAP.get(client);\n  }\n  const rpcClientMap = new Map();\n  RPC_CLIENT_MAP.set(client, rpcClientMap);\n  return rpcClientMap;\n}\n/**\n * @internal\n */\nfunction rpcRequestKey(request) {\n  return `${request.method}:${stringify(request.params)}`;\n}\nconst DEFAULT_MAX_BATCH_SIZE = 100;\n// default to no timeout (next tick)\nconst DEFAULT_BATCH_TIMEOUT_MS = 0;\n/**\n * Returns an RPC request that can be used to make JSON-RPC requests.\n * @param options - The RPC options.\n * @returns The RPC request function.\n * @rpc\n * @example\n * ```ts\n * import { createThirdwebClient } from \"thirdweb\";\n * import { getRpcClient } from \"thirdweb/rpc\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const rpcRequest = getRpcClient({ client, chain: ethereum, });\n * const blockNumber = await rpcRequest({\n *  method: \"eth_blockNumber\",\n * });\n * ```\n */\nexport function getRpcClient(options) {\n  const rpcClientMap = getRpcClientMap(options.client);\n  const rpcUrl = options.chain.rpc;\n  if (rpcClientMap.has(rpcUrl)) {\n    return rpcClientMap.get(rpcUrl);\n  }\n  const rpcClient = (() => {\n    // we can do this upfront because it cannot change later\n    const rpcUrl = getRpcUrlForChain({\n      client: options.client,\n      chain: options.chain\n    });\n    const batchSize =\n    // look at the direct options passed\n    options.config?.maxBatchSize ??\n    // look at the client options\n    options.client.config?.rpc?.maxBatchSize ??\n    // use defaults\n    DEFAULT_MAX_BATCH_SIZE;\n    const batchTimeoutMs =\n    // look at the direct options passed\n    options.config?.batchTimeoutMs ??\n    // look at the client options\n    options.client.config?.rpc?.batchTimeoutMs ?? DEFAULT_BATCH_TIMEOUT_MS;\n    // inflight requests\n    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n    const inflightRequests = new Map();\n    let pendingBatch = [];\n    let pendingBatchTimeout = null;\n    /**\n     * Sends the pending batch of requests.\n     * @internal\n     */\n    function sendPendingBatch() {\n      // clear the timeout if any\n      if (pendingBatchTimeout) {\n        clearTimeout(pendingBatchTimeout);\n        pendingBatchTimeout = null;\n      }\n      // prepare the requests array (we know the size)\n      const requests = new Array(pendingBatch.length);\n      const activeBatch = pendingBatch.slice().map((inflight, index) => {\n        // assign the id to the request\n        inflight.request.id = index;\n        // also assign the jsonrpc version\n        inflight.request.jsonrpc = \"2.0\";\n        // assing the request to the requests array (so we don't have to map it again later)\n        requests[index] = inflight.request;\n        return inflight;\n      });\n      // reset pendingBatch to empty\n      pendingBatch = [];\n      fetchRpc(rpcUrl, options.client, {\n        requests,\n        requestTimeoutMs: options.config?.requestTimeoutMs\n      }).then(responses => {\n        // for each response, resolve the inflight request\n        activeBatch.forEach((inflight, index) => {\n          const response = responses[index];\n          // if we didn't get a response at all, reject the inflight request\n          if (!response) {\n            inflight.reject(new Error(\"No response\"));\n            return;\n          }\n          // handle errors in the response\n          if (response instanceof Error) {\n            inflight.reject(response);\n            return;\n          }\n          // handle strings as responses??\n          if (typeof response === \"string\") {\n            inflight.reject(new Error(response));\n            return;\n          }\n          if (\"error\" in response) {\n            inflight.reject(response.error);\n            // otherwise, resolve the inflight request\n          } else if (response.method === \"eth_subscription\") {\n            // TODO: handle subscription responses\n            throw new Error(\"Subscriptions not supported yet\");\n          } else {\n            inflight.resolve(response.result);\n          }\n          // remove the inflight request from the inflightRequests map\n          inflightRequests.delete(inflight.requestKey);\n        });\n      }).catch(err => {\n        // http call failed, reject all inflight requests\n        for (const inflight of activeBatch) {\n          inflight.reject(err);\n          // remove the inflight request from the inflightRequests map\n          inflightRequests.delete(inflight.requestKey);\n        }\n      });\n    }\n    // shortcut everything if we do not need to batch\n    if (batchSize === 1) {\n      return async request => {\n        // we can hard-code the id and jsonrpc version\n        // we also mutate the request object here to avoid copying it\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n        request.id = 1;\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n        request.jsonrpc = \"2.0\";\n        const rpcResponse = await fetchSingleRpc(rpcUrl, options.client, {\n          request: request,\n          requestTimeoutMs: options.config?.requestTimeoutMs\n        });\n        if (!rpcResponse) {\n          throw new Error(\"No response\");\n        }\n        if (\"error\" in rpcResponse) {\n          throw rpcResponse.error;\n        }\n        return rpcResponse.result;\n      };\n    }\n    return async request => {\n      const requestKey = rpcRequestKey(request);\n      // if the request for this key is already inflight, return the promise directly\n      if (inflightRequests.has(requestKey)) {\n        // biome-ignore lint/style/noNonNullAssertion: the `has` check ensures this is defined\n        return inflightRequests.get(requestKey);\n      }\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      let resolve;\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      let reject;\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      const promise = new Promise((resolve_, reject_) => {\n        resolve = resolve_;\n        reject = reject_;\n      });\n      inflightRequests.set(requestKey, promise);\n      // @ts-expect-error - they *are* definitely assgined within the promise constructor\n      pendingBatch.push({\n        request,\n        resolve,\n        reject,\n        requestKey\n      });\n      if (batchSize > 1) {\n        // if there is no timeout, set one\n        if (!pendingBatchTimeout) {\n          pendingBatchTimeout = setTimeout(sendPendingBatch, batchTimeoutMs);\n        }\n        // if the batch is full, send it\n        if (pendingBatch.length >= batchSize) {\n          sendPendingBatch();\n        }\n      } else {\n        sendPendingBatch();\n      }\n      return promise;\n    };\n  })();\n  rpcClientMap.set(rpcUrl, rpcClient);\n  return rpcClient;\n}\n//# sourceMappingURL=rpc.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}