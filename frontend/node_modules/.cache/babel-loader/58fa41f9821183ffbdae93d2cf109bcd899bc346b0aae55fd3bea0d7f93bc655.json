{"ast":null,"code":"\"use client\";\n\n// packages/react/dismissable-layer/src/DismissableLayer.tsx\nimport * as React from \"react\";\nimport { composeEventHandlers } from \"@radix-ui/primitive\";\nimport { Primitive, dispatchDiscreteCustomEvent } from \"@radix-ui/react-primitive\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { useEscapeKeydown } from \"@radix-ui/react-use-escape-keydown\";\nimport { jsx } from \"react/jsx-runtime\";\nvar DISMISSABLE_LAYER_NAME = \"DismissableLayer\";\nvar CONTEXT_UPDATE = \"dismissableLayer.update\";\nvar POINTER_DOWN_OUTSIDE = \"dismissableLayer.pointerDownOutside\";\nvar FOCUS_OUTSIDE = \"dismissableLayer.focusOutside\";\nvar originalBodyPointerEvents;\nvar DismissableLayerContext = React.createContext({\n  layers: /* @__PURE__ */new Set(),\n  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */new Set(),\n  branches: /* @__PURE__ */new Set()\n});\nvar DismissableLayer = React.forwardRef((props, forwardedRef) => {\n  const {\n    disableOutsidePointerEvents = false,\n    onEscapeKeyDown,\n    onPointerDownOutside,\n    onFocusOutside,\n    onInteractOutside,\n    onDismiss,\n    ...layerProps\n  } = props;\n  const context = React.useContext(DismissableLayerContext);\n  const [node, setNode] = React.useState(null);\n  const ownerDocument = node?.ownerDocument ?? globalThis?.document;\n  const [, force] = React.useState({});\n  const composedRefs = useComposedRefs(forwardedRef, node2 => setNode(node2));\n  const layers = Array.from(context.layers);\n  const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);\n  const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);\n  const index = node ? layers.indexOf(node) : -1;\n  const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;\n  const isPointerEventsEnabled = index >= highestLayerWithOutsidePointerEventsDisabledIndex;\n  const pointerDownOutside = usePointerDownOutside(event => {\n    const target = event.target;\n    const isPointerDownOnBranch = [...context.branches].some(branch => branch.contains(target));\n    if (!isPointerEventsEnabled || isPointerDownOnBranch) return;\n    onPointerDownOutside?.(event);\n    onInteractOutside?.(event);\n    if (!event.defaultPrevented) onDismiss?.();\n  }, ownerDocument);\n  const focusOutside = useFocusOutside(event => {\n    const target = event.target;\n    const isFocusInBranch = [...context.branches].some(branch => branch.contains(target));\n    if (isFocusInBranch) return;\n    onFocusOutside?.(event);\n    onInteractOutside?.(event);\n    if (!event.defaultPrevented) onDismiss?.();\n  }, ownerDocument);\n  useEscapeKeydown(event => {\n    const isHighestLayer = index === context.layers.size - 1;\n    if (!isHighestLayer) return;\n    onEscapeKeyDown?.(event);\n    if (!event.defaultPrevented && onDismiss) {\n      event.preventDefault();\n      onDismiss();\n    }\n  }, ownerDocument);\n  React.useEffect(() => {\n    if (!node) return;\n    if (disableOutsidePointerEvents) {\n      if (context.layersWithOutsidePointerEventsDisabled.size === 0) {\n        originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;\n        ownerDocument.body.style.pointerEvents = \"none\";\n      }\n      context.layersWithOutsidePointerEventsDisabled.add(node);\n    }\n    context.layers.add(node);\n    dispatchUpdate();\n    return () => {\n      if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {\n        ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;\n      }\n    };\n  }, [node, ownerDocument, disableOutsidePointerEvents, context]);\n  React.useEffect(() => {\n    return () => {\n      if (!node) return;\n      context.layers.delete(node);\n      context.layersWithOutsidePointerEventsDisabled.delete(node);\n      dispatchUpdate();\n    };\n  }, [node, context]);\n  React.useEffect(() => {\n    const handleUpdate = () => force({});\n    document.addEventListener(CONTEXT_UPDATE, handleUpdate);\n    return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);\n  }, []);\n  return /* @__PURE__ */jsx(Primitive.div, {\n    ...layerProps,\n    ref: composedRefs,\n    style: {\n      pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? \"auto\" : \"none\" : void 0,\n      ...props.style\n    },\n    onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),\n    onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),\n    onPointerDownCapture: composeEventHandlers(props.onPointerDownCapture, pointerDownOutside.onPointerDownCapture)\n  });\n});\nDismissableLayer.displayName = DISMISSABLE_LAYER_NAME;\nvar BRANCH_NAME = \"DismissableLayerBranch\";\nvar DismissableLayerBranch = React.forwardRef((props, forwardedRef) => {\n  const context = React.useContext(DismissableLayerContext);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      context.branches.add(node);\n      return () => {\n        context.branches.delete(node);\n      };\n    }\n  }, [context.branches]);\n  return /* @__PURE__ */jsx(Primitive.div, {\n    ...props,\n    ref: composedRefs\n  });\n});\nDismissableLayerBranch.displayName = BRANCH_NAME;\nfunction usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis?.document) {\n  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside);\n  const isPointerInsideReactTreeRef = React.useRef(false);\n  const handleClickRef = React.useRef(() => {});\n  React.useEffect(() => {\n    const handlePointerDown = event => {\n      if (event.target && !isPointerInsideReactTreeRef.current) {\n        let handleAndDispatchPointerDownOutsideEvent2 = function () {\n          handleAndDispatchCustomEvent(POINTER_DOWN_OUTSIDE, handlePointerDownOutside, eventDetail, {\n            discrete: true\n          });\n        };\n        var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2;\n        const eventDetail = {\n          originalEvent: event\n        };\n        if (event.pointerType === \"touch\") {\n          ownerDocument.removeEventListener(\"click\", handleClickRef.current);\n          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;\n          ownerDocument.addEventListener(\"click\", handleClickRef.current, {\n            once: true\n          });\n        } else {\n          handleAndDispatchPointerDownOutsideEvent2();\n        }\n      } else {\n        ownerDocument.removeEventListener(\"click\", handleClickRef.current);\n      }\n      isPointerInsideReactTreeRef.current = false;\n    };\n    const timerId = window.setTimeout(() => {\n      ownerDocument.addEventListener(\"pointerdown\", handlePointerDown);\n    }, 0);\n    return () => {\n      window.clearTimeout(timerId);\n      ownerDocument.removeEventListener(\"pointerdown\", handlePointerDown);\n      ownerDocument.removeEventListener(\"click\", handleClickRef.current);\n    };\n  }, [ownerDocument, handlePointerDownOutside]);\n  return {\n    // ensures we check React component tree (not just DOM tree)\n    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true\n  };\n}\nfunction useFocusOutside(onFocusOutside, ownerDocument = globalThis?.document) {\n  const handleFocusOutside = useCallbackRef(onFocusOutside);\n  const isFocusInsideReactTreeRef = React.useRef(false);\n  React.useEffect(() => {\n    const handleFocus = event => {\n      if (event.target && !isFocusInsideReactTreeRef.current) {\n        const eventDetail = {\n          originalEvent: event\n        };\n        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {\n          discrete: false\n        });\n      }\n    };\n    ownerDocument.addEventListener(\"focusin\", handleFocus);\n    return () => ownerDocument.removeEventListener(\"focusin\", handleFocus);\n  }, [ownerDocument, handleFocusOutside]);\n  return {\n    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,\n    onBlurCapture: () => isFocusInsideReactTreeRef.current = false\n  };\n}\nfunction dispatchUpdate() {\n  const event = new CustomEvent(CONTEXT_UPDATE);\n  document.dispatchEvent(event);\n}\nfunction handleAndDispatchCustomEvent(name, handler, detail, {\n  discrete\n}) {\n  const target = detail.originalEvent.target;\n  const event = new CustomEvent(name, {\n    bubbles: false,\n    cancelable: true,\n    detail\n  });\n  if (handler) target.addEventListener(name, handler, {\n    once: true\n  });\n  if (discrete) {\n    dispatchDiscreteCustomEvent(target, event);\n  } else {\n    target.dispatchEvent(event);\n  }\n}\nvar Root = DismissableLayer;\nvar Branch = DismissableLayerBranch;\nexport { Branch, DismissableLayer, DismissableLayerBranch, Root };\n//# sourceMappingURL=index.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}