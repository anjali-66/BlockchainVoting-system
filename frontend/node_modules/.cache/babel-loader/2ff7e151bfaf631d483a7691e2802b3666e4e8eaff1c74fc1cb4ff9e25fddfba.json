{"ast":null,"code":"import { fetchTokenMetadata } from \"../../../utils/nft/fetchTokenMetadata.js\";\nimport { parseNFT } from \"../../../utils/nft/parseNft.js\";\nimport { tokenURI } from \"../__generated__/IERC721A/read/tokenURI.js\";\nexport { isTokenURISupported as isGetNFTSupported } from \"../__generated__/IERC721A/read/tokenURI.js\";\n/**\n * Retrieves information about a specific ERC721 non-fungible token (NFT).\n * @param options - The options for retrieving the NFT.\n * @returns A promise that resolves to the NFT object.\n * @extension ERC721\n * @example\n * ```ts\n * import { getNFT } from \"thirdweb/extensions/erc721\";\n * const nft = await getNFT({\n *  contract,\n *  tokenId: 1n,\n * });\n * ```\n */\nexport async function getNFT(options) {\n  const [uri, owner] = await Promise.all([tokenURI(options).catch(() => null), options.includeOwner ? import(\"../__generated__/IERC721A/read/ownerOf.js\").then(m => m.ownerOf(options)).catch(() => null) : null]);\n  if (!uri?.trim()) {\n    return parseNFT({\n      id: options.tokenId,\n      type: \"ERC721\",\n      uri: \"\"\n    }, {\n      tokenId: options.tokenId,\n      tokenUri: \"\",\n      type: \"ERC721\",\n      owner\n    });\n  }\n  return parseNFT(await fetchTokenMetadata({\n    client: options.contract.client,\n    tokenId: options.tokenId,\n    tokenUri: uri\n  }).catch(() => ({\n    id: options.tokenId,\n    type: \"ERC721\",\n    uri\n  })), {\n    tokenId: options.tokenId,\n    tokenUri: uri,\n    type: \"ERC721\",\n    owner\n  });\n}\n//# sourceMappingURL=getNFT.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}