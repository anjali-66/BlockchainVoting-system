{"ast":null,"code":"\"use client\";\n\n// packages/react/popper/src/Popper.tsx\nimport * as React from \"react\";\nimport { useFloating, autoUpdate, offset, shift, limitShift, hide, arrow as floatingUIarrow, flip, size } from \"@floating-ui/react-dom\";\nimport * as ArrowPrimitive from \"@radix-ui/react-arrow\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { useLayoutEffect } from \"@radix-ui/react-use-layout-effect\";\nimport { useSize } from \"@radix-ui/react-use-size\";\nimport { jsx } from \"react/jsx-runtime\";\nvar SIDE_OPTIONS = [\"top\", \"right\", \"bottom\", \"left\"];\nvar ALIGN_OPTIONS = [\"start\", \"center\", \"end\"];\nvar POPPER_NAME = \"Popper\";\nvar [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);\nvar [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);\nvar Popper = props => {\n  const {\n    __scopePopper,\n    children\n  } = props;\n  const [anchor, setAnchor] = React.useState(null);\n  return /* @__PURE__ */jsx(PopperProvider, {\n    scope: __scopePopper,\n    anchor,\n    onAnchorChange: setAnchor,\n    children\n  });\n};\nPopper.displayName = POPPER_NAME;\nvar ANCHOR_NAME = \"PopperAnchor\";\nvar PopperAnchor = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopePopper,\n    virtualRef,\n    ...anchorProps\n  } = props;\n  const context = usePopperContext(ANCHOR_NAME, __scopePopper);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  React.useEffect(() => {\n    context.onAnchorChange(virtualRef?.current || ref.current);\n  });\n  return virtualRef ? null : /* @__PURE__ */jsx(Primitive.div, {\n    ...anchorProps,\n    ref: composedRefs\n  });\n});\nPopperAnchor.displayName = ANCHOR_NAME;\nvar CONTENT_NAME = \"PopperContent\";\nvar [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME);\nvar PopperContent = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopePopper,\n    side = \"bottom\",\n    sideOffset = 0,\n    align = \"center\",\n    alignOffset = 0,\n    arrowPadding = 0,\n    avoidCollisions = true,\n    collisionBoundary = [],\n    collisionPadding: collisionPaddingProp = 0,\n    sticky = \"partial\",\n    hideWhenDetached = false,\n    updatePositionStrategy = \"optimized\",\n    onPlaced,\n    ...contentProps\n  } = props;\n  const context = usePopperContext(CONTENT_NAME, __scopePopper);\n  const [content, setContent] = React.useState(null);\n  const composedRefs = useComposedRefs(forwardedRef, node => setContent(node));\n  const [arrow, setArrow] = React.useState(null);\n  const arrowSize = useSize(arrow);\n  const arrowWidth = arrowSize?.width ?? 0;\n  const arrowHeight = arrowSize?.height ?? 0;\n  const desiredPlacement = side + (align !== \"center\" ? \"-\" + align : \"\");\n  const collisionPadding = typeof collisionPaddingProp === \"number\" ? collisionPaddingProp : {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...collisionPaddingProp\n  };\n  const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];\n  const hasExplicitBoundaries = boundary.length > 0;\n  const detectOverflowOptions = {\n    padding: collisionPadding,\n    boundary: boundary.filter(isNotNull),\n    // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries\n    altBoundary: hasExplicitBoundaries\n  };\n  const {\n    refs,\n    floatingStyles,\n    placement,\n    isPositioned,\n    middlewareData\n  } = useFloating({\n    // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues\n    strategy: \"fixed\",\n    placement: desiredPlacement,\n    whileElementsMounted: (...args) => {\n      const cleanup = autoUpdate(...args, {\n        animationFrame: updatePositionStrategy === \"always\"\n      });\n      return cleanup;\n    },\n    elements: {\n      reference: context.anchor\n    },\n    middleware: [offset({\n      mainAxis: sideOffset + arrowHeight,\n      alignmentAxis: alignOffset\n    }), avoidCollisions && shift({\n      mainAxis: true,\n      crossAxis: false,\n      limiter: sticky === \"partial\" ? limitShift() : void 0,\n      ...detectOverflowOptions\n    }), avoidCollisions && flip({\n      ...detectOverflowOptions\n    }), size({\n      ...detectOverflowOptions,\n      apply: ({\n        elements,\n        rects,\n        availableWidth,\n        availableHeight\n      }) => {\n        const {\n          width: anchorWidth,\n          height: anchorHeight\n        } = rects.reference;\n        const contentStyle = elements.floating.style;\n        contentStyle.setProperty(\"--radix-popper-available-width\", `${availableWidth}px`);\n        contentStyle.setProperty(\"--radix-popper-available-height\", `${availableHeight}px`);\n        contentStyle.setProperty(\"--radix-popper-anchor-width\", `${anchorWidth}px`);\n        contentStyle.setProperty(\"--radix-popper-anchor-height\", `${anchorHeight}px`);\n      }\n    }), arrow && floatingUIarrow({\n      element: arrow,\n      padding: arrowPadding\n    }), transformOrigin({\n      arrowWidth,\n      arrowHeight\n    }), hideWhenDetached && hide({\n      strategy: \"referenceHidden\",\n      ...detectOverflowOptions\n    })]\n  });\n  const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n  const handlePlaced = useCallbackRef(onPlaced);\n  useLayoutEffect(() => {\n    if (isPositioned) {\n      handlePlaced?.();\n    }\n  }, [isPositioned, handlePlaced]);\n  const arrowX = middlewareData.arrow?.x;\n  const arrowY = middlewareData.arrow?.y;\n  const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\n  const [contentZIndex, setContentZIndex] = React.useState();\n  useLayoutEffect(() => {\n    if (content) setContentZIndex(window.getComputedStyle(content).zIndex);\n  }, [content]);\n  return /* @__PURE__ */jsx(\"div\", {\n    ref: refs.setFloating,\n    \"data-radix-popper-content-wrapper\": \"\",\n    style: {\n      ...floatingStyles,\n      transform: isPositioned ? floatingStyles.transform : \"translate(0, -200%)\",\n      // keep off the page when measuring\n      minWidth: \"max-content\",\n      zIndex: contentZIndex,\n      [\"--radix-popper-transform-origin\"]: [middlewareData.transformOrigin?.x, middlewareData.transformOrigin?.y].join(\" \"),\n      // hide the content if using the hide middleware and should be hidden\n      // set visibility to hidden and disable pointer events so the UI behaves\n      // as if the PopperContent isn't there at all\n      ...(middlewareData.hide?.referenceHidden && {\n        visibility: \"hidden\",\n        pointerEvents: \"none\"\n      })\n    },\n    dir: props.dir,\n    children: /* @__PURE__ */jsx(PopperContentProvider, {\n      scope: __scopePopper,\n      placedSide,\n      onArrowChange: setArrow,\n      arrowX,\n      arrowY,\n      shouldHideArrow: cannotCenterArrow,\n      children: /* @__PURE__ */jsx(Primitive.div, {\n        \"data-side\": placedSide,\n        \"data-align\": placedAlign,\n        ...contentProps,\n        ref: composedRefs,\n        style: {\n          ...contentProps.style,\n          // if the PopperContent hasn't been placed yet (not all measurements done)\n          // we prevent animations so that users's animation don't kick in too early referring wrong sides\n          animation: !isPositioned ? \"none\" : void 0\n        }\n      })\n    })\n  });\n});\nPopperContent.displayName = CONTENT_NAME;\nvar ARROW_NAME = \"PopperArrow\";\nvar OPPOSITE_SIDE = {\n  top: \"bottom\",\n  right: \"left\",\n  bottom: \"top\",\n  left: \"right\"\n};\nvar PopperArrow = React.forwardRef(function PopperArrow2(props, forwardedRef) {\n  const {\n    __scopePopper,\n    ...arrowProps\n  } = props;\n  const contentContext = useContentContext(ARROW_NAME, __scopePopper);\n  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];\n  return (\n    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)\n    // doesn't report size as we'd expect on SVG elements.\n    // it reports their bounding box which is effectively the largest path inside the SVG.\n    /* @__PURE__ */\n    jsx(\"span\", {\n      ref: contentContext.onArrowChange,\n      style: {\n        position: \"absolute\",\n        left: contentContext.arrowX,\n        top: contentContext.arrowY,\n        [baseSide]: 0,\n        transformOrigin: {\n          top: \"\",\n          right: \"0 0\",\n          bottom: \"center 0\",\n          left: \"100% 0\"\n        }[contentContext.placedSide],\n        transform: {\n          top: \"translateY(100%)\",\n          right: \"translateY(50%) rotate(90deg) translateX(-50%)\",\n          bottom: `rotate(180deg)`,\n          left: \"translateY(50%) rotate(-90deg) translateX(50%)\"\n        }[contentContext.placedSide],\n        visibility: contentContext.shouldHideArrow ? \"hidden\" : void 0\n      },\n      children: /* @__PURE__ */jsx(ArrowPrimitive.Root, {\n        ...arrowProps,\n        ref: forwardedRef,\n        style: {\n          ...arrowProps.style,\n          // ensures the element can be measured correctly (mostly for if SVG)\n          display: \"block\"\n        }\n      })\n    })\n  );\n});\nPopperArrow.displayName = ARROW_NAME;\nfunction isNotNull(value) {\n  return value !== null;\n}\nvar transformOrigin = options => ({\n  name: \"transformOrigin\",\n  options,\n  fn(data) {\n    const {\n      placement,\n      rects,\n      middlewareData\n    } = data;\n    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\n    const isArrowHidden = cannotCenterArrow;\n    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;\n    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;\n    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n    const noArrowAlign = {\n      start: \"0%\",\n      center: \"50%\",\n      end: \"100%\"\n    }[placedAlign];\n    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;\n    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;\n    let x = \"\";\n    let y = \"\";\n    if (placedSide === \"bottom\") {\n      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n      y = `${-arrowHeight}px`;\n    } else if (placedSide === \"top\") {\n      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n      y = `${rects.floating.height + arrowHeight}px`;\n    } else if (placedSide === \"right\") {\n      x = `${-arrowHeight}px`;\n      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n    } else if (placedSide === \"left\") {\n      x = `${rects.floating.width + arrowHeight}px`;\n      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n    }\n    return {\n      data: {\n        x,\n        y\n      }\n    };\n  }\n});\nfunction getSideAndAlignFromPlacement(placement) {\n  const [side, align = \"center\"] = placement.split(\"-\");\n  return [side, align];\n}\nvar Root2 = Popper;\nvar Anchor = PopperAnchor;\nvar Content = PopperContent;\nvar Arrow = PopperArrow;\nexport { ALIGN_OPTIONS, Anchor, Arrow, Content, Popper, PopperAnchor, PopperArrow, PopperContent, Root2 as Root, SIDE_OPTIONS, createPopperScope };\n//# sourceMappingURL=index.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}