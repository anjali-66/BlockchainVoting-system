{"ast":null,"code":"/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport * as mod from './modular.js';\nimport { bitLen, bitMask, concatBytes, notImplemented } from './utils.js';\n/*\nTowered extension fields\n\nRather than implementing a massive 12th-degree extension directly, it is more efficient\nto build it up from smaller extensions: a tower of extensions.\n\nFor BLS12-381, the Fp12 field is implemented as a quadratic (degree two) extension,\non top of a cubic (degree three) extension, on top of a quadratic extension of Fp.\n\nFor more info: \"Pairings for beginners\" by Costello, section 7.3.\n*/\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0),\n  _1n = BigInt(1),\n  _2n = BigInt(2),\n  _3n = BigInt(3);\nfunction calcFrobeniusCoefficients(Fp, nonResidue, modulus, degree, num = 1, divisor) {\n  const _divisor = BigInt(divisor === undefined ? degree : divisor);\n  const towerModulus = modulus ** BigInt(degree);\n  const res = [];\n  for (let i = 0; i < num; i++) {\n    const a = BigInt(i + 1);\n    const powers = [];\n    for (let j = 0, qPower = _1n; j < degree; j++) {\n      const power = (a * qPower - a) / _divisor % towerModulus;\n      powers.push(Fp.pow(nonResidue, power));\n      qPower *= modulus;\n    }\n    res.push(powers);\n  }\n  return res;\n}\n// This works same at least for bls12-381, bn254 and bls12-377\nexport function psiFrobenius(Fp, Fp2, base) {\n  // Ψ endomorphism\n  const PSI_X = Fp2.pow(base, (Fp.ORDER - _1n) / _3n); // u^((p-1)/3)\n  const PSI_Y = Fp2.pow(base, (Fp.ORDER - _1n) / _2n); // u^((p-1)/2)\n  function psi(x, y) {\n    // This x10 faster than previous version in bls12-381\n    const x2 = Fp2.mul(Fp2.frobeniusMap(x, 1), PSI_X);\n    const y2 = Fp2.mul(Fp2.frobeniusMap(y, 1), PSI_Y);\n    return [x2, y2];\n  }\n  // Ψ²(P) endomorphism (psi2(x) = psi(psi(x)))\n  const PSI2_X = Fp2.pow(base, (Fp.ORDER ** _2n - _1n) / _3n); // u^((p^2 - 1)/3)\n  // This equals -1, which causes y to be Fp2.neg(y).\n  // But not sure if there are case when this is not true?\n  const PSI2_Y = Fp2.pow(base, (Fp.ORDER ** _2n - _1n) / _2n); // u^((p^2 - 1)/3)\n  if (!Fp2.eql(PSI2_Y, Fp2.neg(Fp2.ONE))) throw new Error('psiFrobenius: PSI2_Y!==-1');\n  function psi2(x, y) {\n    return [Fp2.mul(x, PSI2_X), Fp2.neg(y)];\n  }\n  // Map points\n  const mapAffine = fn => (c, P) => {\n    const affine = P.toAffine();\n    const p = fn(affine.x, affine.y);\n    return c.fromAffine({\n      x: p[0],\n      y: p[1]\n    });\n  };\n  const G2psi = mapAffine(psi);\n  const G2psi2 = mapAffine(psi2);\n  return {\n    psi,\n    psi2,\n    G2psi,\n    G2psi2,\n    PSI_X,\n    PSI_Y,\n    PSI2_X,\n    PSI2_Y\n  };\n}\nexport function tower12(opts) {\n  const {\n    ORDER\n  } = opts;\n  // Fp\n  const Fp = mod.Field(ORDER);\n  const FpNONRESIDUE = Fp.create(opts.NONRESIDUE || BigInt(-1));\n  const FpLegendre = mod.FpLegendre(ORDER);\n  const Fpdiv2 = Fp.div(Fp.ONE, _2n); // 1/2\n  // Fp2\n  const FP2_FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp, FpNONRESIDUE, Fp.ORDER, 2)[0];\n  const Fp2Add = ({\n    c0,\n    c1\n  }, {\n    c0: r0,\n    c1: r1\n  }) => ({\n    c0: Fp.add(c0, r0),\n    c1: Fp.add(c1, r1)\n  });\n  const Fp2Subtract = ({\n    c0,\n    c1\n  }, {\n    c0: r0,\n    c1: r1\n  }) => ({\n    c0: Fp.sub(c0, r0),\n    c1: Fp.sub(c1, r1)\n  });\n  const Fp2Multiply = ({\n    c0,\n    c1\n  }, rhs) => {\n    if (typeof rhs === 'bigint') return {\n      c0: Fp.mul(c0, rhs),\n      c1: Fp.mul(c1, rhs)\n    };\n    // (a+bi)(c+di) = (ac−bd) + (ad+bc)i\n    const {\n      c0: r0,\n      c1: r1\n    } = rhs;\n    let t1 = Fp.mul(c0, r0); // c0 * o0\n    let t2 = Fp.mul(c1, r1); // c1 * o1\n    // (T1 - T2) + ((c0 + c1) * (r0 + r1) - (T1 + T2))*i\n    const o0 = Fp.sub(t1, t2);\n    const o1 = Fp.sub(Fp.mul(Fp.add(c0, c1), Fp.add(r0, r1)), Fp.add(t1, t2));\n    return {\n      c0: o0,\n      c1: o1\n    };\n  };\n  const Fp2Square = ({\n    c0,\n    c1\n  }) => {\n    const a = Fp.add(c0, c1);\n    const b = Fp.sub(c0, c1);\n    const c = Fp.add(c0, c0);\n    return {\n      c0: Fp.mul(a, b),\n      c1: Fp.mul(c, c1)\n    };\n  };\n  const Fp2fromBigTuple = tuple => {\n    if (tuple.length !== 2) throw new Error('invalid tuple');\n    const fps = tuple.map(n => Fp.create(n));\n    return {\n      c0: fps[0],\n      c1: fps[1]\n    };\n  };\n  const FP2_ORDER = ORDER * ORDER;\n  const Fp2Nonresidue = Fp2fromBigTuple(opts.FP2_NONRESIDUE);\n  const Fp2 = {\n    ORDER: FP2_ORDER,\n    NONRESIDUE: Fp2Nonresidue,\n    BITS: bitLen(FP2_ORDER),\n    BYTES: Math.ceil(bitLen(FP2_ORDER) / 8),\n    MASK: bitMask(bitLen(FP2_ORDER)),\n    ZERO: {\n      c0: Fp.ZERO,\n      c1: Fp.ZERO\n    },\n    ONE: {\n      c0: Fp.ONE,\n      c1: Fp.ZERO\n    },\n    create: num => num,\n    isValid: ({\n      c0,\n      c1\n    }) => typeof c0 === 'bigint' && typeof c1 === 'bigint',\n    is0: ({\n      c0,\n      c1\n    }) => Fp.is0(c0) && Fp.is0(c1),\n    eql: ({\n      c0,\n      c1\n    }, {\n      c0: r0,\n      c1: r1\n    }) => Fp.eql(c0, r0) && Fp.eql(c1, r1),\n    neg: ({\n      c0,\n      c1\n    }) => ({\n      c0: Fp.neg(c0),\n      c1: Fp.neg(c1)\n    }),\n    pow: (num, power) => mod.FpPow(Fp2, num, power),\n    invertBatch: nums => mod.FpInvertBatch(Fp2, nums),\n    // Normalized\n    add: Fp2Add,\n    sub: Fp2Subtract,\n    mul: Fp2Multiply,\n    sqr: Fp2Square,\n    // NonNormalized stuff\n    addN: Fp2Add,\n    subN: Fp2Subtract,\n    mulN: Fp2Multiply,\n    sqrN: Fp2Square,\n    // Why inversion for bigint inside Fp instead of Fp2? it is even used in that context?\n    div: (lhs, rhs) => Fp2.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp2.inv(rhs)),\n    inv: ({\n      c0: a,\n      c1: b\n    }) => {\n      // We wish to find the multiplicative inverse of a nonzero\n      // element a + bu in Fp2. We leverage an identity\n      //\n      // (a + bu)(a - bu) = a² + b²\n      //\n      // which holds because u² = -1. This can be rewritten as\n      //\n      // (a + bu)(a - bu)/(a² + b²) = 1\n      //\n      // because a² + b² = 0 has no nonzero solutions for (a, b).\n      // This gives that (a - bu)/(a² + b²) is the inverse\n      // of (a + bu). Importantly, this can be computing using\n      // only a single inversion in Fp.\n      const factor = Fp.inv(Fp.create(a * a + b * b));\n      return {\n        c0: Fp.mul(factor, Fp.create(a)),\n        c1: Fp.mul(factor, Fp.create(-b))\n      };\n    },\n    sqrt: num => {\n      if (opts.Fp2sqrt) return opts.Fp2sqrt(num);\n      // This is generic for all quadratic extensions (Fp2)\n      const {\n        c0,\n        c1\n      } = num;\n      if (Fp.is0(c1)) {\n        // if c0 is quadratic residue\n        if (Fp.eql(FpLegendre(Fp, c0), Fp.ONE)) return Fp2.create({\n          c0: Fp.sqrt(c0),\n          c1: Fp.ZERO\n        });else return Fp2.create({\n          c0: Fp.ZERO,\n          c1: Fp.sqrt(Fp.div(c0, FpNONRESIDUE))\n        });\n      }\n      const a = Fp.sqrt(Fp.sub(Fp.sqr(c0), Fp.mul(Fp.sqr(c1), FpNONRESIDUE)));\n      let d = Fp.mul(Fp.add(a, c0), Fpdiv2);\n      const legendre = FpLegendre(Fp, d);\n      // -1, Quadratic non residue\n      if (!Fp.is0(legendre) && !Fp.eql(legendre, Fp.ONE)) d = Fp.sub(d, a);\n      const a0 = Fp.sqrt(d);\n      const candidateSqrt = Fp2.create({\n        c0: a0,\n        c1: Fp.div(Fp.mul(c1, Fpdiv2), a0)\n      });\n      if (!Fp2.eql(Fp2.sqr(candidateSqrt), num)) throw new Error('Cannot find square root');\n      // Normalize root: at this point candidateSqrt ** 2 = num, but also -candidateSqrt ** 2 = num\n      const x1 = candidateSqrt;\n      const x2 = Fp2.neg(x1);\n      const {\n        re: re1,\n        im: im1\n      } = Fp2.reim(x1);\n      const {\n        re: re2,\n        im: im2\n      } = Fp2.reim(x2);\n      if (im1 > im2 || im1 === im2 && re1 > re2) return x1;\n      return x2;\n    },\n    // Same as sgn0_m_eq_2 in RFC 9380\n    isOdd: x => {\n      const {\n        re: x0,\n        im: x1\n      } = Fp2.reim(x);\n      const sign_0 = x0 % _2n;\n      const zero_0 = x0 === _0n;\n      const sign_1 = x1 % _2n;\n      return BigInt(sign_0 || zero_0 && sign_1) == _1n;\n    },\n    // Bytes util\n    fromBytes(b) {\n      if (b.length !== Fp2.BYTES) throw new Error('fromBytes invalid length=' + b.length);\n      return {\n        c0: Fp.fromBytes(b.subarray(0, Fp.BYTES)),\n        c1: Fp.fromBytes(b.subarray(Fp.BYTES))\n      };\n    },\n    toBytes: ({\n      c0,\n      c1\n    }) => concatBytes(Fp.toBytes(c0), Fp.toBytes(c1)),\n    cmov: ({\n      c0,\n      c1\n    }, {\n      c0: r0,\n      c1: r1\n    }, c) => ({\n      c0: Fp.cmov(c0, r0, c),\n      c1: Fp.cmov(c1, r1, c)\n    }),\n    reim: ({\n      c0,\n      c1\n    }) => ({\n      re: c0,\n      im: c1\n    }),\n    // multiply by u + 1\n    mulByNonresidue: ({\n      c0,\n      c1\n    }) => Fp2.mul({\n      c0,\n      c1\n    }, Fp2Nonresidue),\n    mulByB: opts.Fp2mulByB,\n    fromBigTuple: Fp2fromBigTuple,\n    frobeniusMap: ({\n      c0,\n      c1\n    }, power) => ({\n      c0,\n      c1: Fp.mul(c1, FP2_FROBENIUS_COEFFICIENTS[power % 2])\n    })\n  };\n  // Fp6\n  const Fp6Add = ({\n    c0,\n    c1,\n    c2\n  }, {\n    c0: r0,\n    c1: r1,\n    c2: r2\n  }) => ({\n    c0: Fp2.add(c0, r0),\n    c1: Fp2.add(c1, r1),\n    c2: Fp2.add(c2, r2)\n  });\n  const Fp6Subtract = ({\n    c0,\n    c1,\n    c2\n  }, {\n    c0: r0,\n    c1: r1,\n    c2: r2\n  }) => ({\n    c0: Fp2.sub(c0, r0),\n    c1: Fp2.sub(c1, r1),\n    c2: Fp2.sub(c2, r2)\n  });\n  const Fp6Multiply = ({\n    c0,\n    c1,\n    c2\n  }, rhs) => {\n    if (typeof rhs === 'bigint') {\n      return {\n        c0: Fp2.mul(c0, rhs),\n        c1: Fp2.mul(c1, rhs),\n        c2: Fp2.mul(c2, rhs)\n      };\n    }\n    const {\n      c0: r0,\n      c1: r1,\n      c2: r2\n    } = rhs;\n    const t0 = Fp2.mul(c0, r0); // c0 * o0\n    const t1 = Fp2.mul(c1, r1); // c1 * o1\n    const t2 = Fp2.mul(c2, r2); // c2 * o2\n    return {\n      // t0 + (c1 + c2) * (r1 * r2) - (T1 + T2) * (u + 1)\n      c0: Fp2.add(t0, Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), Fp2.add(r1, r2)), Fp2.add(t1, t2)))),\n      // (c0 + c1) * (r0 + r1) - (T0 + T1) + T2 * (u + 1)\n      c1: Fp2.add(Fp2.sub(Fp2.mul(Fp2.add(c0, c1), Fp2.add(r0, r1)), Fp2.add(t0, t1)), Fp2.mulByNonresidue(t2)),\n      // T1 + (c0 + c2) * (r0 + r2) - T0 + T2\n      c2: Fp2.sub(Fp2.add(t1, Fp2.mul(Fp2.add(c0, c2), Fp2.add(r0, r2))), Fp2.add(t0, t2))\n    };\n  };\n  const Fp6Square = ({\n    c0,\n    c1,\n    c2\n  }) => {\n    let t0 = Fp2.sqr(c0); // c0²\n    let t1 = Fp2.mul(Fp2.mul(c0, c1), _2n); // 2 * c0 * c1\n    let t3 = Fp2.mul(Fp2.mul(c1, c2), _2n); // 2 * c1 * c2\n    let t4 = Fp2.sqr(c2); // c2²\n    return {\n      c0: Fp2.add(Fp2.mulByNonresidue(t3), t0),\n      // T3 * (u + 1) + T0\n      c1: Fp2.add(Fp2.mulByNonresidue(t4), t1),\n      // T4 * (u + 1) + T1\n      // T1 + (c0 - c1 + c2)² + T3 - T0 - T4\n      c2: Fp2.sub(Fp2.sub(Fp2.add(Fp2.add(t1, Fp2.sqr(Fp2.add(Fp2.sub(c0, c1), c2))), t3), t0), t4)\n    };\n  };\n  const [FP6_FROBENIUS_COEFFICIENTS_1, FP6_FROBENIUS_COEFFICIENTS_2] = calcFrobeniusCoefficients(Fp2, Fp2Nonresidue, Fp.ORDER, 6, 2, 3);\n  const Fp6 = {\n    ORDER: Fp2.ORDER,\n    // TODO: unused, but need to verify\n    BITS: 3 * Fp2.BITS,\n    BYTES: 3 * Fp2.BYTES,\n    MASK: bitMask(3 * Fp2.BITS),\n    ZERO: {\n      c0: Fp2.ZERO,\n      c1: Fp2.ZERO,\n      c2: Fp2.ZERO\n    },\n    ONE: {\n      c0: Fp2.ONE,\n      c1: Fp2.ZERO,\n      c2: Fp2.ZERO\n    },\n    create: num => num,\n    isValid: ({\n      c0,\n      c1,\n      c2\n    }) => Fp2.isValid(c0) && Fp2.isValid(c1) && Fp2.isValid(c2),\n    is0: ({\n      c0,\n      c1,\n      c2\n    }) => Fp2.is0(c0) && Fp2.is0(c1) && Fp2.is0(c2),\n    neg: ({\n      c0,\n      c1,\n      c2\n    }) => ({\n      c0: Fp2.neg(c0),\n      c1: Fp2.neg(c1),\n      c2: Fp2.neg(c2)\n    }),\n    eql: ({\n      c0,\n      c1,\n      c2\n    }, {\n      c0: r0,\n      c1: r1,\n      c2: r2\n    }) => Fp2.eql(c0, r0) && Fp2.eql(c1, r1) && Fp2.eql(c2, r2),\n    sqrt: notImplemented,\n    // Do we need division by bigint at all? Should be done via order:\n    div: (lhs, rhs) => Fp6.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp6.inv(rhs)),\n    pow: (num, power) => mod.FpPow(Fp6, num, power),\n    invertBatch: nums => mod.FpInvertBatch(Fp6, nums),\n    // Normalized\n    add: Fp6Add,\n    sub: Fp6Subtract,\n    mul: Fp6Multiply,\n    sqr: Fp6Square,\n    // NonNormalized stuff\n    addN: Fp6Add,\n    subN: Fp6Subtract,\n    mulN: Fp6Multiply,\n    sqrN: Fp6Square,\n    inv: ({\n      c0,\n      c1,\n      c2\n    }) => {\n      let t0 = Fp2.sub(Fp2.sqr(c0), Fp2.mulByNonresidue(Fp2.mul(c2, c1))); // c0² - c2 * c1 * (u + 1)\n      let t1 = Fp2.sub(Fp2.mulByNonresidue(Fp2.sqr(c2)), Fp2.mul(c0, c1)); // c2² * (u + 1) - c0 * c1\n      let t2 = Fp2.sub(Fp2.sqr(c1), Fp2.mul(c0, c2)); // c1² - c0 * c2\n      // 1/(((c2 * T1 + c1 * T2) * v) + c0 * T0)\n      let t4 = Fp2.inv(Fp2.add(Fp2.mulByNonresidue(Fp2.add(Fp2.mul(c2, t1), Fp2.mul(c1, t2))), Fp2.mul(c0, t0)));\n      return {\n        c0: Fp2.mul(t4, t0),\n        c1: Fp2.mul(t4, t1),\n        c2: Fp2.mul(t4, t2)\n      };\n    },\n    // Bytes utils\n    fromBytes: b => {\n      if (b.length !== Fp6.BYTES) throw new Error('fromBytes invalid length=' + b.length);\n      return {\n        c0: Fp2.fromBytes(b.subarray(0, Fp2.BYTES)),\n        c1: Fp2.fromBytes(b.subarray(Fp2.BYTES, 2 * Fp2.BYTES)),\n        c2: Fp2.fromBytes(b.subarray(2 * Fp2.BYTES))\n      };\n    },\n    toBytes: ({\n      c0,\n      c1,\n      c2\n    }) => concatBytes(Fp2.toBytes(c0), Fp2.toBytes(c1), Fp2.toBytes(c2)),\n    cmov: ({\n      c0,\n      c1,\n      c2\n    }, {\n      c0: r0,\n      c1: r1,\n      c2: r2\n    }, c) => ({\n      c0: Fp2.cmov(c0, r0, c),\n      c1: Fp2.cmov(c1, r1, c),\n      c2: Fp2.cmov(c2, r2, c)\n    }),\n    fromBigSix: t => {\n      if (!Array.isArray(t) || t.length !== 6) throw new Error('invalid Fp6 usage');\n      return {\n        c0: Fp2.fromBigTuple(t.slice(0, 2)),\n        c1: Fp2.fromBigTuple(t.slice(2, 4)),\n        c2: Fp2.fromBigTuple(t.slice(4, 6))\n      };\n    },\n    frobeniusMap: ({\n      c0,\n      c1,\n      c2\n    }, power) => ({\n      c0: Fp2.frobeniusMap(c0, power),\n      c1: Fp2.mul(Fp2.frobeniusMap(c1, power), FP6_FROBENIUS_COEFFICIENTS_1[power % 6]),\n      c2: Fp2.mul(Fp2.frobeniusMap(c2, power), FP6_FROBENIUS_COEFFICIENTS_2[power % 6])\n    }),\n    mulByFp2: ({\n      c0,\n      c1,\n      c2\n    }, rhs) => ({\n      c0: Fp2.mul(c0, rhs),\n      c1: Fp2.mul(c1, rhs),\n      c2: Fp2.mul(c2, rhs)\n    }),\n    mulByNonresidue: ({\n      c0,\n      c1,\n      c2\n    }) => ({\n      c0: Fp2.mulByNonresidue(c2),\n      c1: c0,\n      c2: c1\n    }),\n    // Sparse multiplication\n    mul1: ({\n      c0,\n      c1,\n      c2\n    }, b1) => ({\n      c0: Fp2.mulByNonresidue(Fp2.mul(c2, b1)),\n      c1: Fp2.mul(c0, b1),\n      c2: Fp2.mul(c1, b1)\n    }),\n    // Sparse multiplication\n    mul01({\n      c0,\n      c1,\n      c2\n    }, b0, b1) {\n      let t0 = Fp2.mul(c0, b0); // c0 * b0\n      let t1 = Fp2.mul(c1, b1); // c1 * b1\n      return {\n        // ((c1 + c2) * b1 - T1) * (u + 1) + T0\n        c0: Fp2.add(Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), b1), t1)), t0),\n        // (b0 + b1) * (c0 + c1) - T0 - T1\n        c1: Fp2.sub(Fp2.sub(Fp2.mul(Fp2.add(b0, b1), Fp2.add(c0, c1)), t0), t1),\n        // (c0 + c2) * b0 - T0 + T1\n        c2: Fp2.add(Fp2.sub(Fp2.mul(Fp2.add(c0, c2), b0), t0), t1)\n      };\n    }\n  };\n  // Fp12\n  const FP12_FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp2, Fp2Nonresidue, Fp.ORDER, 12, 1, 6)[0];\n  const Fp12Add = ({\n    c0,\n    c1\n  }, {\n    c0: r0,\n    c1: r1\n  }) => ({\n    c0: Fp6.add(c0, r0),\n    c1: Fp6.add(c1, r1)\n  });\n  const Fp12Subtract = ({\n    c0,\n    c1\n  }, {\n    c0: r0,\n    c1: r1\n  }) => ({\n    c0: Fp6.sub(c0, r0),\n    c1: Fp6.sub(c1, r1)\n  });\n  const Fp12Multiply = ({\n    c0,\n    c1\n  }, rhs) => {\n    if (typeof rhs === 'bigint') return {\n      c0: Fp6.mul(c0, rhs),\n      c1: Fp6.mul(c1, rhs)\n    };\n    let {\n      c0: r0,\n      c1: r1\n    } = rhs;\n    let t1 = Fp6.mul(c0, r0); // c0 * r0\n    let t2 = Fp6.mul(c1, r1); // c1 * r1\n    return {\n      c0: Fp6.add(t1, Fp6.mulByNonresidue(t2)),\n      // T1 + T2 * v\n      // (c0 + c1) * (r0 + r1) - (T1 + T2)\n      c1: Fp6.sub(Fp6.mul(Fp6.add(c0, c1), Fp6.add(r0, r1)), Fp6.add(t1, t2))\n    };\n  };\n  const Fp12Square = ({\n    c0,\n    c1\n  }) => {\n    let ab = Fp6.mul(c0, c1); // c0 * c1\n    return {\n      // (c1 * v + c0) * (c0 + c1) - AB - AB * v\n      c0: Fp6.sub(Fp6.sub(Fp6.mul(Fp6.add(Fp6.mulByNonresidue(c1), c0), Fp6.add(c0, c1)), ab), Fp6.mulByNonresidue(ab)),\n      c1: Fp6.add(ab, ab)\n    }; // AB + AB\n  };\n  function Fp4Square(a, b) {\n    const a2 = Fp2.sqr(a);\n    const b2 = Fp2.sqr(b);\n    return {\n      first: Fp2.add(Fp2.mulByNonresidue(b2), a2),\n      // b² * Nonresidue + a²\n      second: Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(a, b)), a2), b2) // (a + b)² - a² - b²\n    };\n  }\n  const Fp12 = {\n    ORDER: Fp2.ORDER,\n    // TODO: unused, but need to verify\n    BITS: 2 * Fp2.BITS,\n    BYTES: 2 * Fp2.BYTES,\n    MASK: bitMask(2 * Fp2.BITS),\n    ZERO: {\n      c0: Fp6.ZERO,\n      c1: Fp6.ZERO\n    },\n    ONE: {\n      c0: Fp6.ONE,\n      c1: Fp6.ZERO\n    },\n    create: num => num,\n    isValid: ({\n      c0,\n      c1\n    }) => Fp6.isValid(c0) && Fp6.isValid(c1),\n    is0: ({\n      c0,\n      c1\n    }) => Fp6.is0(c0) && Fp6.is0(c1),\n    neg: ({\n      c0,\n      c1\n    }) => ({\n      c0: Fp6.neg(c0),\n      c1: Fp6.neg(c1)\n    }),\n    eql: ({\n      c0,\n      c1\n    }, {\n      c0: r0,\n      c1: r1\n    }) => Fp6.eql(c0, r0) && Fp6.eql(c1, r1),\n    sqrt: notImplemented,\n    inv: ({\n      c0,\n      c1\n    }) => {\n      let t = Fp6.inv(Fp6.sub(Fp6.sqr(c0), Fp6.mulByNonresidue(Fp6.sqr(c1)))); // 1 / (c0² - c1² * v)\n      return {\n        c0: Fp6.mul(c0, t),\n        c1: Fp6.neg(Fp6.mul(c1, t))\n      }; // ((C0 * T) * T) + (-C1 * T) * w\n    },\n    div: (lhs, rhs) => Fp12.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp12.inv(rhs)),\n    pow: (num, power) => mod.FpPow(Fp12, num, power),\n    invertBatch: nums => mod.FpInvertBatch(Fp12, nums),\n    // Normalized\n    add: Fp12Add,\n    sub: Fp12Subtract,\n    mul: Fp12Multiply,\n    sqr: Fp12Square,\n    // NonNormalized stuff\n    addN: Fp12Add,\n    subN: Fp12Subtract,\n    mulN: Fp12Multiply,\n    sqrN: Fp12Square,\n    // Bytes utils\n    fromBytes: b => {\n      if (b.length !== Fp12.BYTES) throw new Error('fromBytes invalid length=' + b.length);\n      return {\n        c0: Fp6.fromBytes(b.subarray(0, Fp6.BYTES)),\n        c1: Fp6.fromBytes(b.subarray(Fp6.BYTES))\n      };\n    },\n    toBytes: ({\n      c0,\n      c1\n    }) => concatBytes(Fp6.toBytes(c0), Fp6.toBytes(c1)),\n    cmov: ({\n      c0,\n      c1\n    }, {\n      c0: r0,\n      c1: r1\n    }, c) => ({\n      c0: Fp6.cmov(c0, r0, c),\n      c1: Fp6.cmov(c1, r1, c)\n    }),\n    // Utils\n    // toString() {\n    //   return '' + 'Fp12(' + this.c0 + this.c1 + '* w');\n    // },\n    // fromTuple(c: [Fp6, Fp6]) {\n    //   return new Fp12(...c);\n    // }\n    fromBigTwelve: t => ({\n      c0: Fp6.fromBigSix(t.slice(0, 6)),\n      c1: Fp6.fromBigSix(t.slice(6, 12))\n    }),\n    // Raises to q**i -th power\n    frobeniusMap(lhs, power) {\n      const {\n        c0,\n        c1,\n        c2\n      } = Fp6.frobeniusMap(lhs.c1, power);\n      const coeff = FP12_FROBENIUS_COEFFICIENTS[power % 12];\n      return {\n        c0: Fp6.frobeniusMap(lhs.c0, power),\n        c1: Fp6.create({\n          c0: Fp2.mul(c0, coeff),\n          c1: Fp2.mul(c1, coeff),\n          c2: Fp2.mul(c2, coeff)\n        })\n      };\n    },\n    mulByFp2: ({\n      c0,\n      c1\n    }, rhs) => ({\n      c0: Fp6.mulByFp2(c0, rhs),\n      c1: Fp6.mulByFp2(c1, rhs)\n    }),\n    conjugate: ({\n      c0,\n      c1\n    }) => ({\n      c0,\n      c1: Fp6.neg(c1)\n    }),\n    // Sparse multiplication\n    mul014: ({\n      c0,\n      c1\n    }, o0, o1, o4) => {\n      let t0 = Fp6.mul01(c0, o0, o1);\n      let t1 = Fp6.mul1(c1, o4);\n      return {\n        c0: Fp6.add(Fp6.mulByNonresidue(t1), t0),\n        // T1 * v + T0\n        // (c1 + c0) * [o0, o1+o4] - T0 - T1\n        c1: Fp6.sub(Fp6.sub(Fp6.mul01(Fp6.add(c1, c0), o0, Fp2.add(o1, o4)), t0), t1)\n      };\n    },\n    mul034: ({\n      c0,\n      c1\n    }, o0, o3, o4) => {\n      const a = Fp6.create({\n        c0: Fp2.mul(c0.c0, o0),\n        c1: Fp2.mul(c0.c1, o0),\n        c2: Fp2.mul(c0.c2, o0)\n      });\n      const b = Fp6.mul01(c1, o3, o4);\n      const e = Fp6.mul01(Fp6.add(c0, c1), Fp2.add(o0, o3), o4);\n      return {\n        c0: Fp6.add(Fp6.mulByNonresidue(b), a),\n        c1: Fp6.sub(e, Fp6.add(a, b))\n      };\n    },\n    // A cyclotomic group is a subgroup of Fp^n defined by\n    //   GΦₙ(p) = {α ∈ Fpⁿ : α^Φₙ(p) = 1}\n    // The result of any pairing is in a cyclotomic subgroup\n    // https://eprint.iacr.org/2009/565.pdf\n    _cyclotomicSquare: opts.Fp12cyclotomicSquare,\n    _cyclotomicExp: opts.Fp12cyclotomicExp,\n    // https://eprint.iacr.org/2010/354.pdf\n    // https://eprint.iacr.org/2009/565.pdf\n    finalExponentiate: opts.Fp12finalExponentiate\n  };\n  return {\n    Fp,\n    Fp2,\n    Fp6,\n    Fp4Square,\n    Fp12\n  };\n}\n//# sourceMappingURL=tower.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}