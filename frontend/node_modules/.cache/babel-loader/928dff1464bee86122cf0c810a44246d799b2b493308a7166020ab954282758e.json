{"ast":null,"code":"import W, { PROPOSAL_EXPIRY_MESSAGE as X } from \"@walletconnect/sign-client\";\nimport { isValidObject as Y, isCaipNamespace as N, parseNamespaceKey as P, mergeArrays as H, parseChainId as y, getSdkError as O, isValidArray as q } from \"@walletconnect/utils\";\nimport { pino as K, getDefaultLoggerOptions as Q } from \"@walletconnect/logger\";\nimport { merge as Z } from \"lodash\";\nimport u, { HttpConnection as tt } from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider as d } from \"@walletconnect/jsonrpc-provider\";\nimport { formatJsonRpcRequest as et, formatJsonRpcResult as st } from \"@walletconnect/jsonrpc-utils\";\nimport it from \"events\";\nconst D = \"error\",\n  rt = \"wss://relay.walletconnect.org\",\n  nt = \"wc\",\n  at = \"universal_provider\",\n  S = `${nt}@2:${at}:`,\n  _ = \"https://rpc.walletconnect.org/v1/\",\n  f = \"generic\",\n  ot = `${_}bundler`,\n  p = {\n    DEFAULT_CHAIN_CHANGED: \"default_chain_changed\"\n  };\nvar ct = Object.defineProperty,\n  ht = Object.defineProperties,\n  pt = Object.getOwnPropertyDescriptors,\n  j = Object.getOwnPropertySymbols,\n  dt = Object.prototype.hasOwnProperty,\n  ut = Object.prototype.propertyIsEnumerable,\n  R = (r, t, e) => t in r ? ct(r, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : r[t] = e,\n  g = (r, t) => {\n    for (var e in t || (t = {})) dt.call(t, e) && R(r, e, t[e]);\n    if (j) for (var e of j(t)) ut.call(t, e) && R(r, e, t[e]);\n    return r;\n  },\n  lt = (r, t) => ht(r, pt(t));\nfunction h(r, t, e) {\n  var s;\n  const i = y(r);\n  return ((s = t.rpcMap) == null ? void 0 : s[i.reference]) || `${_}?chainId=${i.namespace}:${i.reference}&projectId=${e}`;\n}\nfunction l(r) {\n  return r.includes(\":\") ? r.split(\":\")[1] : r;\n}\nfunction U(r) {\n  return r.map(t => `${t.split(\":\")[0]}:${t.split(\":\")[1]}`);\n}\nfunction mt(r, t) {\n  const e = Object.keys(t.namespaces).filter(i => i.includes(r));\n  if (!e.length) return [];\n  const s = [];\n  return e.forEach(i => {\n    const n = t.namespaces[i].accounts;\n    s.push(...n);\n  }), s;\n}\nfunction $(r = {}, t = {}) {\n  const e = T(r),\n    s = T(t);\n  return Z(e, s);\n}\nfunction T(r) {\n  var t, e, s, i;\n  const n = {};\n  if (!Y(r)) return n;\n  for (const [a, c] of Object.entries(r)) {\n    const m = N(a) ? [a] : c.chains,\n      I = c.methods || [],\n      V = c.events || [],\n      B = c.rpcMap || {},\n      v = P(a);\n    n[v] = lt(g(g({}, n[v]), c), {\n      chains: H(m, (t = n[v]) == null ? void 0 : t.chains),\n      methods: H(I, (e = n[v]) == null ? void 0 : e.methods),\n      events: H(V, (s = n[v]) == null ? void 0 : s.events),\n      rpcMap: g(g({}, B), (i = n[v]) == null ? void 0 : i.rpcMap)\n    });\n  }\n  return n;\n}\nfunction vt(r) {\n  return r.includes(\":\") ? r.split(\":\")[2] : r;\n}\nfunction k(r) {\n  const t = {};\n  for (const [e, s] of Object.entries(r)) {\n    const i = s.methods || [],\n      n = s.events || [],\n      a = s.accounts || [],\n      c = N(e) ? [e] : s.chains ? s.chains : U(s.accounts);\n    t[e] = {\n      chains: c,\n      methods: i,\n      events: n,\n      accounts: a\n    };\n  }\n  return t;\n}\nfunction E(r) {\n  return typeof r == \"number\" ? r : r.includes(\"0x\") ? parseInt(r, 16) : (r = r.includes(\":\") ? r.split(\":\")[1] : r, isNaN(Number(r)) ? r : Number(r));\n}\nconst L = {},\n  o = r => L[r],\n  b = (r, t) => {\n    L[r] = t;\n  };\nclass ft {\n  constructor(t) {\n    this.name = \"polkadot\", this.namespace = t.namespace, this.events = o(\"events\"), this.client = o(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n  setDefaultChain(t, e) {\n    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(p.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]) || [] : [];\n  }\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      var s;\n      const i = l(e);\n      t[i] = this.createHttpProvider(i, (s = this.namespace.rpcMap) == null ? void 0 : s[e]);\n    }), t;\n  }\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n      e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n  setHttpProvider(t, e) {\n    const s = this.createHttpProvider(t, e);\n    s && (this.httpProviders[t] = s);\n  }\n  createHttpProvider(t, e) {\n    const s = e || h(t, this.namespace, this.client.core.projectId);\n    if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);\n    return new d(new u(s, o(\"disableProviderPing\")));\n  }\n}\nvar Pt = Object.defineProperty,\n  gt = Object.defineProperties,\n  wt = Object.getOwnPropertyDescriptors,\n  F = Object.getOwnPropertySymbols,\n  Ct = Object.prototype.hasOwnProperty,\n  It = Object.prototype.propertyIsEnumerable,\n  G = (r, t, e) => t in r ? Pt(r, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : r[t] = e,\n  M = (r, t) => {\n    for (var e in t || (t = {})) Ct.call(t, e) && G(r, e, t[e]);\n    if (F) for (var e of F(t)) It.call(t, e) && G(r, e, t[e]);\n    return r;\n  },\n  x = (r, t) => gt(r, wt(t));\nclass Ht {\n  constructor(t) {\n    this.name = \"eip155\", this.namespace = t.namespace, this.events = o(\"events\"), this.client = o(\"client\"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());\n  }\n  async request(t) {\n    switch (t.request.method) {\n      case \"eth_requestAccounts\":\n        return this.getAccounts();\n      case \"eth_accounts\":\n        return this.getAccounts();\n      case \"wallet_switchEthereumChain\":\n        return await this.handleSwitchChain(t);\n      case \"eth_chainId\":\n        return parseInt(this.getDefaultChain());\n      case \"wallet_getCapabilities\":\n        return await this.getCapabilities(t);\n      case \"wallet_getCallsStatus\":\n        return await this.getCallStatus(t);\n    }\n    return this.namespace.methods.includes(t.request.method) ? await this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n  setDefaultChain(t, e) {\n    this.httpProviders[t] || this.setHttpProvider(parseInt(t), e), this.chainId = parseInt(t), this.events.emit(p.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId.toString();\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n  createHttpProvider(t, e) {\n    const s = e || h(`${this.name}:${t}`, this.namespace, this.client.core.projectId);\n    if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);\n    return new d(new tt(s, o(\"disableProviderPing\")));\n  }\n  setHttpProvider(t, e) {\n    const s = this.createHttpProvider(t, e);\n    s && (this.httpProviders[t] = s);\n  }\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      var s;\n      const i = parseInt(l(e));\n      t[i] = this.createHttpProvider(i, (s = this.namespace.rpcMap) == null ? void 0 : s[e]);\n    }), t;\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? [...new Set(t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]))] : [];\n  }\n  getHttpProvider() {\n    const t = this.chainId,\n      e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n  async handleSwitchChain(t) {\n    var e, s;\n    let i = t.request.params ? (e = t.request.params[0]) == null ? void 0 : e.chainId : \"0x0\";\n    i = i.startsWith(\"0x\") ? i : `0x${i}`;\n    const n = parseInt(i, 16);\n    if (this.isChainApproved(n)) this.setDefaultChain(`${n}`);else if (this.namespace.methods.includes(\"wallet_switchEthereumChain\")) await this.client.request({\n      topic: t.topic,\n      request: {\n        method: t.request.method,\n        params: [{\n          chainId: i\n        }]\n      },\n      chainId: (s = this.namespace.chains) == null ? void 0 : s[0]\n    }), this.setDefaultChain(`${n}`);else throw new Error(`Failed to switch to chain 'eip155:${n}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);\n    return null;\n  }\n  isChainApproved(t) {\n    return this.namespace.chains.includes(`${this.name}:${t}`);\n  }\n  async getCapabilities(t) {\n    var e, s, i;\n    const n = (s = (e = t.request) == null ? void 0 : e.params) == null ? void 0 : s[0];\n    if (!n) throw new Error(\"Missing address parameter in `wallet_getCapabilities` request\");\n    const a = this.client.session.get(t.topic),\n      c = ((i = a?.sessionProperties) == null ? void 0 : i.capabilities) || {};\n    if (c != null && c[n]) return c?.[n];\n    const m = await this.client.request(t);\n    try {\n      await this.client.session.update(t.topic, {\n        sessionProperties: x(M({}, a.sessionProperties || {}), {\n          capabilities: x(M({}, c || {}), {\n            [n]: m\n          })\n        })\n      });\n    } catch (I) {\n      console.warn(\"Failed to update session with capabilities\", I);\n    }\n    return m;\n  }\n  async getCallStatus(t) {\n    var e, s;\n    const i = this.client.session.get(t.topic),\n      n = (e = i.sessionProperties) == null ? void 0 : e.bundler_name;\n    if (n) {\n      const c = this.getBundlerUrl(t.chainId, n);\n      try {\n        return await this.getUserOperationReceipt(c, t);\n      } catch (m) {\n        console.warn(\"Failed to fetch call status from bundler\", m, c);\n      }\n    }\n    const a = (s = i.sessionProperties) == null ? void 0 : s.bundler_url;\n    if (a) try {\n      return await this.getUserOperationReceipt(a, t);\n    } catch (c) {\n      console.warn(\"Failed to fetch call status from custom bundler\", c, a);\n    }\n    if (this.namespace.methods.includes(t.request.method)) return await this.client.request(t);\n    throw new Error(\"Fetching call status not approved by the wallet.\");\n  }\n  async getUserOperationReceipt(t, e) {\n    var s;\n    const i = new URL(t),\n      n = await fetch(i, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(et(\"eth_getUserOperationReceipt\", [(s = e.request.params) == null ? void 0 : s[0]]))\n      });\n    if (!n.ok) throw new Error(`Failed to fetch user operation receipt - ${n.status}`);\n    return await n.json();\n  }\n  getBundlerUrl(t, e) {\n    return `${ot}?projectId=${this.client.core.projectId}&chainId=${t}&bundler=${e}`;\n  }\n}\nclass $t {\n  constructor(t) {\n    this.name = \"solana\", this.namespace = t.namespace, this.events = o(\"events\"), this.client = o(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n  setDefaultChain(t, e) {\n    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(p.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? [...new Set(t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      var s;\n      const i = l(e);\n      t[i] = this.createHttpProvider(i, (s = this.namespace.rpcMap) == null ? void 0 : s[e]);\n    }), t;\n  }\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n      e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n  setHttpProvider(t, e) {\n    const s = this.createHttpProvider(t, e);\n    s && (this.httpProviders[t] = s);\n  }\n  createHttpProvider(t, e) {\n    const s = e || h(t, this.namespace, this.client.core.projectId);\n    if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);\n    return new d(new u(s, o(\"disableProviderPing\")));\n  }\n}\nclass Et {\n  constructor(t) {\n    this.name = \"cosmos\", this.namespace = t.namespace, this.events = o(\"events\"), this.client = o(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n  setDefaultChain(t, e) {\n    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(p.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? [...new Set(t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      var s;\n      const i = l(e);\n      t[i] = this.createHttpProvider(i, (s = this.namespace.rpcMap) == null ? void 0 : s[e]);\n    }), t;\n  }\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n      e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n  setHttpProvider(t, e) {\n    const s = this.createHttpProvider(t, e);\n    s && (this.httpProviders[t] = s);\n  }\n  createHttpProvider(t, e) {\n    const s = e || h(t, this.namespace, this.client.core.projectId);\n    if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);\n    return new d(new u(s, o(\"disableProviderPing\")));\n  }\n}\nclass bt {\n  constructor(t) {\n    this.name = \"algorand\", this.namespace = t.namespace, this.events = o(\"events\"), this.client = o(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n  setDefaultChain(t, e) {\n    if (!this.httpProviders[t]) {\n      const s = e || h(`${this.name}:${t}`, this.namespace, this.client.core.projectId);\n      if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);\n      this.setHttpProvider(t, s);\n    }\n    this.chainId = t, this.events.emit(p.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? [...new Set(t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      var s;\n      t[e] = this.createHttpProvider(e, (s = this.namespace.rpcMap) == null ? void 0 : s[e]);\n    }), t;\n  }\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n      e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n  setHttpProvider(t, e) {\n    const s = this.createHttpProvider(t, e);\n    s && (this.httpProviders[t] = s);\n  }\n  createHttpProvider(t, e) {\n    const s = e || h(t, this.namespace, this.client.core.projectId);\n    return typeof s > \"u\" ? void 0 : new d(new u(s, o(\"disableProviderPing\")));\n  }\n}\nclass At {\n  constructor(t) {\n    this.name = \"cip34\", this.namespace = t.namespace, this.events = o(\"events\"), this.client = o(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n  setDefaultChain(t, e) {\n    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(p.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? [...new Set(t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      const s = this.getCardanoRPCUrl(e),\n        i = l(e);\n      t[i] = this.createHttpProvider(i, s);\n    }), t;\n  }\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n      e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n  getCardanoRPCUrl(t) {\n    const e = this.namespace.rpcMap;\n    if (e) return e[t];\n  }\n  setHttpProvider(t, e) {\n    const s = this.createHttpProvider(t, e);\n    s && (this.httpProviders[t] = s);\n  }\n  createHttpProvider(t, e) {\n    const s = e || this.getCardanoRPCUrl(t);\n    if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);\n    return new d(new u(s, o(\"disableProviderPing\")));\n  }\n}\nclass Nt {\n  constructor(t) {\n    this.name = \"elrond\", this.namespace = t.namespace, this.events = o(\"events\"), this.client = o(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n  setDefaultChain(t, e) {\n    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(p.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? [...new Set(t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      var s;\n      const i = l(e);\n      t[i] = this.createHttpProvider(i, (s = this.namespace.rpcMap) == null ? void 0 : s[e]);\n    }), t;\n  }\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n      e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n  setHttpProvider(t, e) {\n    const s = this.createHttpProvider(t, e);\n    s && (this.httpProviders[t] = s);\n  }\n  createHttpProvider(t, e) {\n    const s = e || h(t, this.namespace, this.client.core.projectId);\n    if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);\n    return new d(new u(s, o(\"disableProviderPing\")));\n  }\n}\nclass yt {\n  constructor(t) {\n    this.name = \"multiversx\", this.namespace = t.namespace, this.events = o(\"events\"), this.client = o(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n  setDefaultChain(t, e) {\n    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(p.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? [...new Set(t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      var s;\n      const i = l(e);\n      t[i] = this.createHttpProvider(i, (s = this.namespace.rpcMap) == null ? void 0 : s[e]);\n    }), t;\n  }\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n      e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n  setHttpProvider(t, e) {\n    const s = this.createHttpProvider(t, e);\n    s && (this.httpProviders[t] = s);\n  }\n  createHttpProvider(t, e) {\n    const s = e || h(t, this.namespace, this.client.core.projectId);\n    if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);\n    return new d(new u(s, o(\"disableProviderPing\")));\n  }\n}\nclass Ot {\n  constructor(t) {\n    this.name = \"near\", this.namespace = t.namespace, this.events = o(\"events\"), this.client = o(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n  setDefaultChain(t, e) {\n    if (this.chainId = t, !this.httpProviders[t]) {\n      const s = e || h(`${this.name}:${t}`, this.namespace);\n      if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);\n      this.setHttpProvider(t, s);\n    }\n    this.events.emit(p.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]) || [] : [];\n  }\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      var s;\n      t[e] = this.createHttpProvider(e, (s = this.namespace.rpcMap) == null ? void 0 : s[e]);\n    }), t;\n  }\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n      e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n  setHttpProvider(t, e) {\n    const s = this.createHttpProvider(t, e);\n    s && (this.httpProviders[t] = s);\n  }\n  createHttpProvider(t, e) {\n    const s = e || h(t, this.namespace);\n    return typeof s > \"u\" ? void 0 : new d(new u(s, o(\"disableProviderPing\")));\n  }\n}\nclass qt {\n  constructor(t) {\n    this.name = \"tezos\", this.namespace = t.namespace, this.events = o(\"events\"), this.client = o(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n  setDefaultChain(t, e) {\n    if (this.chainId = t, !this.httpProviders[t]) {\n      const s = e || h(`${this.name}:${t}`, this.namespace);\n      if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);\n      this.setHttpProvider(t, s);\n    }\n    this.events.emit(p.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]) || [] : [];\n  }\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      t[e] = this.createHttpProvider(e);\n    }), t;\n  }\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n      e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n  setHttpProvider(t, e) {\n    const s = this.createHttpProvider(t, e);\n    s && (this.httpProviders[t] = s);\n  }\n  createHttpProvider(t, e) {\n    const s = e || h(t, this.namespace);\n    return typeof s > \"u\" ? void 0 : new d(new u(s));\n  }\n}\nclass Dt {\n  constructor(t) {\n    this.name = f, this.namespace = t.namespace, this.events = o(\"events\"), this.client = o(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(t) {\n    this.namespace.chains = [...new Set((this.namespace.chains || []).concat(t.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(t.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(t.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(t.events || []))], this.httpProviders = this.createHttpProviders();\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider(t.chainId).request(t.request);\n  }\n  setDefaultChain(t, e) {\n    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(p.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? [...new Set(t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    var t, e;\n    const s = {};\n    return (e = (t = this.namespace) == null ? void 0 : t.accounts) == null || e.forEach(i => {\n      const n = y(i);\n      s[`${n.namespace}:${n.reference}`] = this.createHttpProvider(i);\n    }), s;\n  }\n  getHttpProvider(t) {\n    const e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n  setHttpProvider(t, e) {\n    const s = this.createHttpProvider(t, e);\n    s && (this.httpProviders[t] = s);\n  }\n  createHttpProvider(t, e) {\n    const s = e || h(t, this.namespace, this.client.core.projectId);\n    if (!s) throw new Error(`No RPC url provided for chainId: ${t}`);\n    return new d(new u(s, o(\"disableProviderPing\")));\n  }\n}\nvar St = Object.defineProperty,\n  _t = Object.defineProperties,\n  jt = Object.getOwnPropertyDescriptors,\n  J = Object.getOwnPropertySymbols,\n  Rt = Object.prototype.hasOwnProperty,\n  Ut = Object.prototype.propertyIsEnumerable,\n  z = (r, t, e) => t in r ? St(r, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : r[t] = e,\n  w = (r, t) => {\n    for (var e in t || (t = {})) Rt.call(t, e) && z(r, e, t[e]);\n    if (J) for (var e of J(t)) Ut.call(t, e) && z(r, e, t[e]);\n    return r;\n  },\n  A = (r, t) => _t(r, jt(t));\nclass C {\n  constructor(t) {\n    this.events = new it(), this.rpcProviders = {}, this.shouldAbortPairingAttempt = !1, this.maxPairingAttempts = 10, this.disableProviderPing = !1, this.providerOpts = t, this.logger = typeof t?.logger < \"u\" && typeof t?.logger != \"string\" ? t.logger : K(Q({\n      level: t?.logger || D\n    })), this.disableProviderPing = t?.disableProviderPing || !1;\n  }\n  static async init(t) {\n    const e = new C(t);\n    return await e.initialize(), e;\n  }\n  async request(t, e, s) {\n    const [i, n] = this.validateChain(e);\n    if (!this.session) throw new Error(\"Please call connect() before request()\");\n    return await this.getProvider(i).request({\n      request: w({}, t),\n      chainId: `${i}:${n}`,\n      topic: this.session.topic,\n      expiry: s\n    });\n  }\n  sendAsync(t, e, s, i) {\n    const n = new Date().getTime();\n    this.request(t, s, i).then(a => e(null, st(n, a))).catch(a => e(a, void 0));\n  }\n  async enable() {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    return this.session || (await this.connect({\n      namespaces: this.namespaces,\n      optionalNamespaces: this.optionalNamespaces,\n      sessionProperties: this.sessionProperties\n    })), await this.requestAccounts();\n  }\n  async disconnect() {\n    var t;\n    if (!this.session) throw new Error(\"Please call connect() before enable()\");\n    await this.client.disconnect({\n      topic: (t = this.session) == null ? void 0 : t.topic,\n      reason: O(\"USER_DISCONNECTED\")\n    }), await this.cleanup();\n  }\n  async connect(t) {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    if (this.setNamespaces(t), await this.cleanupPendingPairings(), !t.skipPairing) return await this.pair(t.pairingTopic);\n  }\n  async authenticate(t, e) {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    this.setNamespaces(t), await this.cleanupPendingPairings();\n    const {\n      uri: s,\n      response: i\n    } = await this.client.authenticate(t, e);\n    s && (this.uri = s, this.events.emit(\"display_uri\", s));\n    const n = await i();\n    if (this.session = n.session, this.session) {\n      const a = k(this.session.namespaces);\n      this.namespaces = $(this.namespaces, a), this.persist(\"namespaces\", this.namespaces), this.onConnect();\n    }\n    return n;\n  }\n  on(t, e) {\n    this.events.on(t, e);\n  }\n  once(t, e) {\n    this.events.once(t, e);\n  }\n  removeListener(t, e) {\n    this.events.removeListener(t, e);\n  }\n  off(t, e) {\n    this.events.off(t, e);\n  }\n  get isWalletConnect() {\n    return !0;\n  }\n  async pair(t) {\n    this.shouldAbortPairingAttempt = !1;\n    let e = 0;\n    do {\n      if (this.shouldAbortPairingAttempt) throw new Error(\"Pairing aborted\");\n      if (e >= this.maxPairingAttempts) throw new Error(\"Max auto pairing attempts reached\");\n      const {\n        uri: s,\n        approval: i\n      } = await this.client.connect({\n        pairingTopic: t,\n        requiredNamespaces: this.namespaces,\n        optionalNamespaces: this.optionalNamespaces,\n        sessionProperties: this.sessionProperties\n      });\n      s && (this.uri = s, this.events.emit(\"display_uri\", s)), await i().then(n => {\n        this.session = n;\n        const a = k(n.namespaces);\n        this.namespaces = $(this.namespaces, a), this.persist(\"namespaces\", this.namespaces);\n      }).catch(n => {\n        if (n.message !== X) throw n;\n        e++;\n      });\n    } while (!this.session);\n    return this.onConnect(), this.session;\n  }\n  setDefaultChain(t, e) {\n    try {\n      if (!this.session) return;\n      const [s, i] = this.validateChain(t),\n        n = this.getProvider(s);\n      n.name === f ? n.setDefaultChain(`${s}:${i}`, e) : n.setDefaultChain(i, e);\n    } catch (s) {\n      if (!/Please call connect/.test(s.message)) throw s;\n    }\n  }\n  async cleanupPendingPairings(t = {}) {\n    this.logger.info(\"Cleaning up inactive pairings...\");\n    const e = this.client.pairing.getAll();\n    if (q(e)) {\n      for (const s of e) t.deletePairings ? this.client.core.expirer.set(s.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(s.topic);\n      this.logger.info(`Inactive pairings cleared: ${e.length}`);\n    }\n  }\n  abortPairingAttempt() {\n    this.shouldAbortPairingAttempt = !0;\n  }\n  async checkStorage() {\n    if (this.namespaces = await this.getFromStore(\"namespaces\"), this.optionalNamespaces = (await this.getFromStore(\"optionalNamespaces\")) || {}, this.client.session.length) {\n      const t = this.client.session.keys.length - 1;\n      this.session = this.client.session.get(this.client.session.keys[t]), this.createProviders();\n    }\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();\n  }\n  async createClient() {\n    this.client = this.providerOpts.client || (await W.init({\n      core: this.providerOpts.core,\n      logger: this.providerOpts.logger || D,\n      relayUrl: this.providerOpts.relayUrl || rt,\n      projectId: this.providerOpts.projectId,\n      metadata: this.providerOpts.metadata,\n      storageOptions: this.providerOpts.storageOptions,\n      storage: this.providerOpts.storage,\n      name: this.providerOpts.name,\n      customStoragePrefix: this.providerOpts.customStoragePrefix,\n      telemetryEnabled: this.providerOpts.telemetryEnabled\n    })), this.logger.trace(\"SignClient Initialized\");\n  }\n  createProviders() {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    if (!this.session) throw new Error(\"Session not initialized. Please call connect() before enable()\");\n    const t = [...new Set(Object.keys(this.session.namespaces).map(e => P(e)))];\n    b(\"client\", this.client), b(\"events\", this.events), b(\"disableProviderPing\", this.disableProviderPing), t.forEach(e => {\n      if (!this.session) return;\n      const s = mt(e, this.session),\n        i = U(s),\n        n = $(this.namespaces, this.optionalNamespaces),\n        a = A(w({}, n[e]), {\n          accounts: s,\n          chains: i\n        });\n      switch (e) {\n        case \"eip155\":\n          this.rpcProviders[e] = new Ht({\n            namespace: a\n          });\n          break;\n        case \"algorand\":\n          this.rpcProviders[e] = new bt({\n            namespace: a\n          });\n          break;\n        case \"solana\":\n          this.rpcProviders[e] = new $t({\n            namespace: a\n          });\n          break;\n        case \"cosmos\":\n          this.rpcProviders[e] = new Et({\n            namespace: a\n          });\n          break;\n        case \"polkadot\":\n          this.rpcProviders[e] = new ft({\n            namespace: a\n          });\n          break;\n        case \"cip34\":\n          this.rpcProviders[e] = new At({\n            namespace: a\n          });\n          break;\n        case \"elrond\":\n          this.rpcProviders[e] = new Nt({\n            namespace: a\n          });\n          break;\n        case \"multiversx\":\n          this.rpcProviders[e] = new yt({\n            namespace: a\n          });\n          break;\n        case \"near\":\n          this.rpcProviders[e] = new Ot({\n            namespace: a\n          });\n          break;\n        case \"tezos\":\n          this.rpcProviders[e] = new qt({\n            namespace: a\n          });\n          break;\n        default:\n          this.rpcProviders[f] ? this.rpcProviders[f].updateNamespace(a) : this.rpcProviders[f] = new Dt({\n            namespace: a\n          });\n      }\n    });\n  }\n  registerEventListeners() {\n    if (typeof this.client > \"u\") throw new Error(\"Sign Client is not initialized\");\n    this.client.on(\"session_ping\", t => {\n      this.events.emit(\"session_ping\", t);\n    }), this.client.on(\"session_event\", t => {\n      const {\n          params: e\n        } = t,\n        {\n          event: s\n        } = e;\n      if (s.name === \"accountsChanged\") {\n        const i = s.data;\n        i && q(i) && this.events.emit(\"accountsChanged\", i.map(vt));\n      } else if (s.name === \"chainChanged\") {\n        const i = e.chainId,\n          n = e.event.data,\n          a = P(i),\n          c = E(i) !== E(n) ? `${a}:${E(n)}` : i;\n        this.onChainChanged(c);\n      } else this.events.emit(s.name, s.data);\n      this.events.emit(\"session_event\", t);\n    }), this.client.on(\"session_update\", ({\n      topic: t,\n      params: e\n    }) => {\n      var s;\n      const {\n          namespaces: i\n        } = e,\n        n = (s = this.client) == null ? void 0 : s.session.get(t);\n      this.session = A(w({}, n), {\n        namespaces: i\n      }), this.onSessionUpdate(), this.events.emit(\"session_update\", {\n        topic: t,\n        params: e\n      });\n    }), this.client.on(\"session_delete\", async t => {\n      await this.cleanup(), this.events.emit(\"session_delete\", t), this.events.emit(\"disconnect\", A(w({}, O(\"USER_DISCONNECTED\")), {\n        data: t.topic\n      }));\n    }), this.on(p.DEFAULT_CHAIN_CHANGED, t => {\n      this.onChainChanged(t, !0);\n    });\n  }\n  getProvider(t) {\n    return this.rpcProviders[t] || this.rpcProviders[f];\n  }\n  onSessionUpdate() {\n    Object.keys(this.rpcProviders).forEach(t => {\n      var e;\n      this.getProvider(t).updateNamespace((e = this.session) == null ? void 0 : e.namespaces[t]);\n    });\n  }\n  setNamespaces(t) {\n    const {\n      namespaces: e,\n      optionalNamespaces: s,\n      sessionProperties: i\n    } = t;\n    e && Object.keys(e).length && (this.namespaces = e), s && Object.keys(s).length && (this.optionalNamespaces = s), this.sessionProperties = i, this.persist(\"namespaces\", e), this.persist(\"optionalNamespaces\", s);\n  }\n  validateChain(t) {\n    const [e, s] = t?.split(\":\") || [\"\", \"\"];\n    if (!this.namespaces || !Object.keys(this.namespaces).length) return [e, s];\n    if (e && !Object.keys(this.namespaces || {}).map(a => P(a)).includes(e)) throw new Error(`Namespace '${e}' is not configured. Please call connect() first with namespace config.`);\n    if (e && s) return [e, s];\n    const i = P(Object.keys(this.namespaces)[0]),\n      n = this.rpcProviders[i].getDefaultChain();\n    return [i, n];\n  }\n  async requestAccounts() {\n    const [t] = this.validateChain();\n    return await this.getProvider(t).requestAccounts();\n  }\n  onChainChanged(t, e = !1) {\n    if (!this.namespaces) return;\n    const [s, i] = this.validateChain(t);\n    i && (e || this.getProvider(s).setDefaultChain(i), this.namespaces[s] ? this.namespaces[s].defaultChain = i : this.namespaces[`${s}:${i}`] ? this.namespaces[`${s}:${i}`].defaultChain = i : this.namespaces[`${s}:${i}`] = {\n      defaultChain: i\n    }, this.persist(\"namespaces\", this.namespaces), this.events.emit(\"chainChanged\", i));\n  }\n  onConnect() {\n    this.createProviders(), this.events.emit(\"connect\", {\n      session: this.session\n    });\n  }\n  async cleanup() {\n    this.session = void 0, this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, this.persist(\"namespaces\", void 0), this.persist(\"optionalNamespaces\", void 0), this.persist(\"sessionProperties\", void 0), await this.cleanupPendingPairings({\n      deletePairings: !0\n    });\n  }\n  persist(t, e) {\n    this.client.core.storage.setItem(`${S}/${t}`, e);\n  }\n  async getFromStore(t) {\n    return await this.client.core.storage.getItem(`${S}/${t}`);\n  }\n}\nconst Tt = C;\nexport { Tt as UniversalProvider, C as default };\n//# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}