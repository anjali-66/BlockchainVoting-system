{"ast":null,"code":"import { trackTransaction } from \"../../../../analytics/track/transaction.js\";\nimport { getCachedChain } from \"../../../../chains/utils.js\";\nimport { eth_sendRawTransaction } from \"../../../../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../../../../rpc/rpc.js\";\nimport { getAddress } from \"../../../../utils/address.js\";\nimport { getThirdwebDomains } from \"../../../../utils/domains.js\";\nimport { hexToString } from \"../../../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../../../utils/signatures/helpers/parse-typed-data.js\";\n/**\n *\n */\nexport class IFrameWallet {\n  /**\n   * Not meant to be initialized directly. Call {@link initializeUser} to get an instance\n   * @internal\n   */\n  constructor({\n    client,\n    ecosystem,\n    querier,\n    localStorage\n  }) {\n    Object.defineProperty(this, \"client\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"ecosystem\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"walletManagerQuerier\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"localStorage\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.client = client;\n    this.ecosystem = ecosystem;\n    this.walletManagerQuerier = querier;\n    this.localStorage = localStorage;\n  }\n  /**\n   * Used to set-up the user device in the case that they are using incognito\n   * @returns `{walletAddress : string }` The user's wallet details\n   * @internal\n   */\n  async postWalletSetUp(authResult) {\n    if (authResult.deviceShareStored) {\n      await this.localStorage.saveDeviceShare(authResult.deviceShareStored, authResult.storedToken.authDetails.userWalletId);\n    }\n  }\n  /**\n   * Gets the various status states of the user\n   * @example\n   * ```typescript\n   *  const userStatus = await Paper.getUserWalletStatus();\n   *  switch (userStatus.status) {\n   *  case UserWalletStatus.LOGGED_OUT: {\n   *    // User is logged out, call one of the auth methods on Paper.auth to authenticate the user\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED: {\n   *    // User is logged in, but does not have a wallet associated with it\n   *    // you also have access to the user's details\n   *    userStatus.user.authDetails;\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_NEW_DEVICE: {\n   *    // User is logged in and created a wallet already, but is missing the device shard\n   *    // You have access to:\n   *    userStatus.user.authDetails;\n   *    userStatus.user.walletAddress;\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED: {\n   *    // user is logged in and wallet is all set up.\n   *    // You have access to:\n   *    userStatus.user.authDetails;\n   *    userStatus.user.walletAddress;\n   *    userStatus.user.wallet;\n   *    break;\n   *  }\n   *}\n   *```\n   * @returns `{GetUserWalletStatusFnReturnType}` an object to containing various information on the user statuses\n   * @internal\n   */\n  async getUserWalletStatus() {\n    const userStatus = await this.walletManagerQuerier.call({\n      procedureName: \"getUserStatus\",\n      params: undefined\n    });\n    if (userStatus.status === \"Logged In, Wallet Initialized\") {\n      return {\n        status: \"Logged In, Wallet Initialized\",\n        ...userStatus.user,\n        account: await this.getAccount()\n      };\n    }\n    if (userStatus.status === \"Logged In, New Device\") {\n      return {\n        status: \"Logged In, New Device\",\n        ...userStatus.user\n      };\n    }\n    if (userStatus.status === \"Logged In, Wallet Uninitialized\") {\n      return {\n        status: \"Logged In, Wallet Uninitialized\",\n        ...userStatus.user\n      };\n    }\n    // Logged out\n    return {\n      status: userStatus.status\n    };\n  }\n  /**\n   * Returns an account that communicates with the iFrame for signing operations\n   * @internal\n   */\n  async getAccount() {\n    const querier = this.walletManagerQuerier;\n    const client = this.client;\n    const partnerId = this.ecosystem?.partnerId;\n    const {\n      address\n    } = await querier.call({\n      procedureName: \"getAddress\",\n      params: undefined\n    });\n    const _signTransaction = async tx => {\n      // biome-ignore lint/suspicious/noExplicitAny: ethers tx transformation\n      const transaction = {\n        to: tx.to ?? undefined,\n        data: tx.data,\n        value: tx.value,\n        gasLimit: tx.gas,\n        nonce: tx.nonce,\n        chainId: tx.chainId\n      };\n      if (tx.maxFeePerGas) {\n        // ethers (in the iframe) rejects any type 0 trasaction with unknown keys\n        // TODO remove this once iframe is upgraded to v5\n        transaction.accessList = tx.accessList;\n        transaction.maxFeePerGas = tx.maxFeePerGas;\n        transaction.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n        transaction.type = 2;\n      } else {\n        transaction.gasPrice = tx.gasPrice;\n        transaction.type = 0;\n      }\n      const RPC_URL = getThirdwebDomains().rpc;\n      const {\n        signedTransaction\n      } = await querier.call({\n        procedureName: \"signTransaction\",\n        params: {\n          transaction,\n          chainId: tx.chainId,\n          partnerId,\n          rpcEndpoint: `https://${tx.chainId}.${RPC_URL}` // TODO (ew) shouldnt be needed\n        }\n      });\n      return signedTransaction;\n    };\n    return {\n      address: getAddress(address),\n      async signTransaction(tx) {\n        if (!tx.chainId) {\n          throw new Error(\"chainId required in tx to sign\");\n        }\n        return _signTransaction({\n          ...tx,\n          chainId: tx.chainId\n        });\n      },\n      async sendTransaction(tx) {\n        const rpcRequest = getRpcClient({\n          client,\n          chain: getCachedChain(tx.chainId)\n        });\n        const signedTx = await _signTransaction(tx);\n        const transactionHash = await eth_sendRawTransaction(rpcRequest, signedTx);\n        trackTransaction({\n          client,\n          chainId: tx.chainId,\n          walletAddress: address,\n          walletType: \"inApp\",\n          transactionHash,\n          contractAddress: tx.to ?? undefined,\n          gasPrice: tx.gasPrice\n        });\n        return {\n          transactionHash\n        };\n      },\n      async signMessage({\n        message\n      }) {\n        // in-app wallets use ethers to sign messages, which always expects a string (or bytes maybe but string is safest)\n        const messageDecoded = (() => {\n          if (typeof message === \"string\") {\n            return message;\n          }\n          if (message.raw instanceof Uint8Array) {\n            return message.raw;\n          }\n          return hexToString(message.raw);\n        })();\n        const {\n          signedMessage\n        } = await querier.call({\n          procedureName: \"signMessage\",\n          params: {\n            // biome-ignore lint/suspicious/noExplicitAny: ethers tx transformation\n            message: messageDecoded,\n            // needs bytes or string\n            partnerId,\n            chainId: 1 // TODO check if we need this\n          }\n        });\n        return signedMessage;\n      },\n      async signTypedData(_typedData) {\n        const parsedTypedData = parseTypedData(_typedData);\n        // deleting EIP712 Domain as it results in ambiguous primary type on some cases\n        // this happens when going from viem to ethers via the iframe\n        if (parsedTypedData.types?.EIP712Domain) {\n          parsedTypedData.types.EIP712Domain = undefined;\n        }\n        const domain = parsedTypedData.domain;\n        const chainId = domain?.chainId;\n        const verifyingContract = domain?.verifyingContract ? {\n          verifyingContract: domain?.verifyingContract\n        } : {};\n        const domainData = {\n          ...verifyingContract,\n          name: domain?.name,\n          version: domain?.version\n        };\n        // chain id can't be included if it wasn't explicitly specified\n        if (chainId) {\n          domainData.chainId = chainId;\n        }\n        const RPC_URL = getThirdwebDomains().rpc;\n        const {\n          signedTypedData\n        } = await querier.call({\n          procedureName: \"signTypedDataV4\",\n          params: {\n            domain: domainData,\n            types: parsedTypedData.types,\n            message: parsedTypedData.message,\n            chainId: Number.parseInt(BigInt(chainId || 1).toString()),\n            partnerId,\n            rpcEndpoint: `https://${chainId}.${RPC_URL}` // TODO (ew) shouldnt be needed\n          }\n        });\n        return signedTypedData;\n      }\n    };\n  }\n}\n//# sourceMappingURL=iframe-wallet.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}