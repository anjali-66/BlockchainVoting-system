{"ast":null,"code":"import { eth_getTransactionReceipt } from \"../../rpc/actions/eth_getTransactionReceipt.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport { watchBlockNumber } from \"../../rpc/watchBlockNumber.js\";\nconst DEFAULT_MAX_BLOCKS_WAIT_TIME = 100;\nconst map = new Map();\n/**\n * Waits for the transaction receipt of a given transaction hash on a specific contract.\n * @param options - The options for waiting for the receipt.\n * By default, it's 100 blocks.\n * @returns A promise that resolves with the transaction receipt.\n * @transaction\n * @example\n * ```ts\n * import { waitForReceipt } from \"thirdweb\";\n * const receipt = await waitForReceipt({\n *   client,\n *   chain,\n *   transactionHash: \"0x123...\",\n * });\n * ```\n */\nexport function waitForReceipt(options) {\n  const {\n    transactionHash,\n    chain,\n    client\n  } = options;\n  const chainId = chain.id;\n  const key = `${chainId}:tx_${transactionHash}`;\n  const maxBlocksWaitTime = options.maxBlocksWaitTime ?? DEFAULT_MAX_BLOCKS_WAIT_TIME;\n  if (map.has(key)) {\n    // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set\n    return map.get(key);\n  }\n  const promise = new Promise((resolve, reject) => {\n    if (!transactionHash) {\n      reject(new Error(\"Transaction has no transactionHash to wait for, did you execute it?\"));\n    }\n    const request = getRpcClient({\n      client,\n      chain\n    });\n    // start at -1 because the first block doesn't count\n    let blocksWaited = -1;\n    const unwatch = watchBlockNumber({\n      client: client,\n      chain: chain,\n      onNewBlockNumber: async () => {\n        blocksWaited++;\n        if (blocksWaited >= maxBlocksWaitTime) {\n          unwatch();\n          reject(new Error(`Transaction not found after ${maxBlocksWaitTime} blocks`));\n          return;\n        }\n        try {\n          const receipt = await eth_getTransactionReceipt(request, {\n            hash: transactionHash\n          });\n          // stop the polling\n          unwatch();\n          // resolve the top level promise with the receipt\n          resolve(receipt);\n        } catch {\n          // noop, we'll try again on the next blocks\n        }\n      }\n    });\n    // remove the promise from the map when it's done (one way or the other)\n  }).finally(() => {\n    map.delete(key);\n  });\n  map.set(key, promise);\n  return promise;\n}\n//# sourceMappingURL=wait-for-tx-receipt.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}