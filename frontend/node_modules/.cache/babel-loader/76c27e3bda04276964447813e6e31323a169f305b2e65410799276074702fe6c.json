{"ast":null,"code":"// source code of yocto-queue + modified to add types\n// https://github.com/sindresorhus/yocto-queue\nclass Node {\n  constructor(value) {\n    Object.defineProperty(this, \"value\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"next\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.value = value;\n  }\n}\nclass Queue {\n  constructor() {\n    Object.defineProperty(this, \"head\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"tail\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"size\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.clear();\n    this.size = 0;\n  }\n  enqueue(value) {\n    const node = new Node(value);\n    if (this.head) {\n      if (this.tail) {\n        this.tail.next = node;\n      }\n      this.tail = node;\n    } else {\n      this.head = node;\n      this.tail = node;\n    }\n    this.size++;\n  }\n  dequeue() {\n    const current = this.head;\n    if (!current) {\n      return;\n    }\n    this.head = this.head?.next;\n    this.size--;\n    return current.value;\n  }\n  clear() {\n    this.head = undefined;\n    this.tail = undefined;\n    this.size = 0;\n  }\n  *[Symbol.iterator]() {\n    let current = this.head;\n    while (current) {\n      yield current.value;\n      current = current.next;\n    }\n  }\n}\n// source code of p-limit - https://github.com/sindresorhus/p-limit/ + modified to add types\nconst AsyncResource = {\n  bind(fn, _type, thisArg) {\n    return fn.bind(thisArg);\n  }\n};\n/**\n * Run multiple promise-returning & async functions with limited concurrency.\n * @param concurrency\n * @internal\n */\nexport function pLimit(concurrency) {\n  if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {\n    throw new TypeError(\"Expected `concurrency` to be a number from 1 and up\");\n  }\n  const queue = new Queue();\n  let activeCount = 0;\n  const next = () => {\n    activeCount--;\n    if (queue.size > 0) {\n      const fn = queue.dequeue();\n      if (fn) {\n        fn();\n      }\n    }\n  };\n  const run = async (function_, resolve, arguments_) => {\n    activeCount++;\n    // @ts-ignore\n    const result = (async () => function_(...arguments_))();\n    resolve(result);\n    try {\n      await result;\n    } catch {}\n    next();\n  };\n  const enqueue = (function_, resolve, arguments_) => {\n    queue.enqueue(AsyncResource.bind(run.bind(undefined, function_, resolve, arguments_)));\n    (async () => {\n      // This function needs to wait until the next microtask before comparing\n      // `activeCount` to `concurrency`, because `activeCount` is updated asynchronously\n      // when the run function is dequeued and called. The comparison in the if-statement\n      // needs to happen asynchronously as well to get an up-to-date value for `activeCount`.\n      await Promise.resolve();\n      if (activeCount < concurrency && queue.size > 0) {\n        const fn = queue.dequeue();\n        if (fn) {\n          fn();\n        }\n      }\n    })();\n  };\n  const generator = (function_, ...arguments_) => new Promise(resolve => {\n    enqueue(function_, resolve, arguments_);\n  });\n  Object.defineProperties(generator, {\n    activeCount: {\n      get: () => activeCount\n    },\n    pendingCount: {\n      get: () => queue.size\n    },\n    clearQueue: {\n      value() {\n        queue.clear();\n      }\n    }\n  });\n  return generator;\n}\n//# sourceMappingURL=p-limit.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}