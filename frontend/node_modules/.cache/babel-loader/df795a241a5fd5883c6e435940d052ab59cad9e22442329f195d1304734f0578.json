{"ast":null,"code":"import { serializeErc6492Signature } from \"../../../auth/serialize-erc6492-signature.js\";\nimport { verifyHash } from \"../../../auth/verify-hash.js\";\nimport { getContract } from \"../../../contract/contract.js\";\nimport { encode } from \"../../../transaction/actions/encode.js\";\nimport { readContract } from \"../../../transaction/read-contract.js\";\nimport { encodeAbiParameters } from \"../../../utils/abi/encodeAbiParameters.js\";\nimport { hashMessage } from \"../../../utils/hashing/hashMessage.js\";\nimport { hashTypedData } from \"../../../utils/hashing/hashTypedData.js\";\nimport { prepareCreateAccount } from \"./calls.js\";\nexport async function deployAndSignMessage({\n  accountContract,\n  factoryContract,\n  options,\n  message\n}) {\n  const originalMsgHash = hashMessage(message);\n  const is712Factory = await checkFor712Factory({\n    factoryContract,\n    accountContract,\n    originalMsgHash\n  });\n  let sig;\n  if (is712Factory) {\n    const wrappedMessageHash = encodeAbiParameters([{\n      type: \"bytes32\"\n    }], [originalMsgHash]);\n    sig = await options.personalAccount.signTypedData({\n      domain: {\n        name: \"Account\",\n        version: \"1\",\n        chainId: options.chain.id,\n        verifyingContract: accountContract.address\n      },\n      primaryType: \"AccountMessage\",\n      types: {\n        AccountMessage: [{\n          name: \"message\",\n          type: \"bytes\"\n        }]\n      },\n      message: {\n        message: wrappedMessageHash\n      }\n    });\n  } else {\n    sig = await options.personalAccount.signMessage({\n      message\n    });\n  }\n  const deployTx = prepareCreateAccount({\n    factoryContract,\n    adminAddress: options.personalAccount.address,\n    accountSalt: options.overrides?.accountSalt,\n    createAccountOverride: options.overrides?.createAccount\n  });\n  if (!deployTx) {\n    throw new Error(\"Create account override not provided\");\n  }\n  const initCode = await encode(deployTx);\n  const erc6492Sig = serializeErc6492Signature({\n    address: factoryContract.address,\n    data: initCode,\n    signature: sig\n  });\n  // check if the signature is valid\n  const isValid = await verifyHash({\n    hash: originalMsgHash,\n    signature: erc6492Sig,\n    address: accountContract.address,\n    chain: accountContract.chain,\n    client: accountContract.client\n  });\n  if (isValid) {\n    return erc6492Sig;\n  }\n  throw new Error(\"Unable to verify signature on smart account, please make sure the admin wallet has permissions and the signature is valid.\");\n}\nexport async function deployAndSignTypedData({\n  accountContract,\n  factoryContract,\n  options,\n  typedData\n}) {\n  const isSelfVerifyingContract = typedData.domain?.verifyingContract?.toLowerCase() === accountContract.address?.toLowerCase();\n  if (isSelfVerifyingContract) {\n    // if the contract is self-verifying, we can just sign the message with the EOA (ie. adding a session key)\n    return options.personalAccount.signTypedData(typedData);\n  }\n  const originalMsgHash = hashTypedData(typedData);\n  // check if the account contract supports EIP721 domain separator based signing\n  const is712Factory = await checkFor712Factory({\n    factoryContract,\n    accountContract,\n    originalMsgHash\n  });\n  let sig;\n  if (is712Factory) {\n    const wrappedMessageHash = encodeAbiParameters([{\n      type: \"bytes32\"\n    }], [originalMsgHash]);\n    sig = await options.personalAccount.signTypedData({\n      domain: {\n        name: \"Account\",\n        version: \"1\",\n        chainId: options.chain.id,\n        verifyingContract: accountContract.address\n      },\n      primaryType: \"AccountMessage\",\n      types: {\n        AccountMessage: [{\n          name: \"message\",\n          type: \"bytes\"\n        }]\n      },\n      message: {\n        message: wrappedMessageHash\n      }\n    });\n  } else {\n    sig = await options.personalAccount.signTypedData(typedData);\n  }\n  const deployTx = prepareCreateAccount({\n    factoryContract,\n    adminAddress: options.personalAccount.address,\n    accountSalt: options.overrides?.accountSalt,\n    createAccountOverride: options.overrides?.createAccount\n  });\n  if (!deployTx) {\n    throw new Error(\"Create account override not provided\");\n  }\n  const initCode = await encode(deployTx);\n  const erc6492Sig = serializeErc6492Signature({\n    address: factoryContract.address,\n    data: initCode,\n    signature: sig\n  });\n  // check if the signature is valid\n  const isValid = await verifyHash({\n    hash: originalMsgHash,\n    signature: erc6492Sig,\n    address: accountContract.address,\n    chain: accountContract.chain,\n    client: accountContract.client\n  });\n  if (isValid) {\n    return erc6492Sig;\n  }\n  throw new Error(\"Unable to verify signature on smart account, please make sure the admin wallet has permissions and the signature is valid.\");\n}\nexport async function confirmContractDeployment(args) {\n  const {\n    accountContract\n  } = args;\n  const startTime = Date.now();\n  const timeout = 60000; // wait 1 minute max\n  const {\n    isContractDeployed\n  } = await import(\"../../../utils/bytecode/is-contract-deployed.js\");\n  let isDeployed = await isContractDeployed(accountContract);\n  while (!isDeployed) {\n    if (Date.now() - startTime > timeout) {\n      throw new Error(\"Timeout: Smart account deployment not confirmed after 1 minute\");\n    }\n    await new Promise(resolve => setTimeout(resolve, 500));\n    isDeployed = await isContractDeployed(accountContract);\n  }\n}\nasync function checkFor712Factory({\n  factoryContract,\n  accountContract,\n  originalMsgHash\n}) {\n  try {\n    const implementationAccount = await readContract({\n      contract: factoryContract,\n      method: \"function accountImplementation() public view returns (address)\"\n    });\n    // check if the account contract supports EIP721 domain separator or modular based signing\n    const is712Factory = await readContract({\n      contract: getContract({\n        address: implementationAccount,\n        chain: accountContract.chain,\n        client: accountContract.client\n      }),\n      method: \"function getMessageHash(bytes32 _hash) public view returns (bytes32)\",\n      params: [originalMsgHash]\n    }).then(res => res !== \"0x\").catch(() => false);\n    return is712Factory;\n  } catch {\n    return false;\n  }\n}\n//# sourceMappingURL=signing.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}