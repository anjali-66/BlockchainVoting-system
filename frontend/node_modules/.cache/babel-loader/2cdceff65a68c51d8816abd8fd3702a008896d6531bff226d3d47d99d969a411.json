{"ast":null,"code":"import { getContract } from \"../../../../contract/contract.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nimport { readContract } from \"../../../read-contract.js\";\nimport { waitForReceipt } from \"../../wait-for-tx-receipt.js\";\n/**\n * @internal - only exported for testing\n */\nexport async function prepareEngineTransaction({\n  account,\n  serializableTransaction,\n  transaction,\n  gasless\n}) {\n  const forrwaderContract = getContract({\n    address: gasless.relayerForwarderAddress,\n    chain: transaction.chain,\n    client: transaction.client\n  });\n  const nonce = await readContract({\n    contract: forrwaderContract,\n    method: \"function getNonce(address) view returns (uint256)\",\n    params: [account.address]\n  });\n  const [signature, message] = await (async () => {\n    // TODO: handle special case for `approve` -> `permit` transactions\n    if (!serializableTransaction.to) {\n      throw new Error(\"engine transactions must have a 'to' address\");\n    }\n    if (!serializableTransaction.gas) {\n      throw new Error(\"engine transactions must have a 'gas' value\");\n    }\n    if (!serializableTransaction.data) {\n      throw new Error(\"engine transactions must have a 'data' value\");\n    }\n    // chainless support!\n    if (gasless.experimentalChainlessSupport) {\n      const message = {\n        from: account.address,\n        to: serializableTransaction.to,\n        value: 0n,\n        gas: serializableTransaction.gas,\n        nonce: nonce,\n        data: serializableTransaction.data,\n        chainid: BigInt(transaction.chain.id)\n      };\n      return [await account.signTypedData({\n        domain: {\n          name: \"GSNv2 Forwarder\",\n          version: \"0.0.1\",\n          verifyingContract: forrwaderContract.address\n        },\n        message,\n        primaryType: \"ForwardRequest\",\n        types: {\n          ForwardRequest: ChainAwareForwardRequest\n        }\n      }), message];\n    }\n    // else non-chainless support\n    const message = {\n      from: account.address,\n      to: serializableTransaction.to,\n      value: 0n,\n      gas: serializableTransaction.gas,\n      nonce: nonce,\n      data: serializableTransaction.data\n    };\n    return [await account.signTypedData({\n      domain: {\n        name: gasless.domainName ?? \"GSNv2 Forwarder\",\n        version: gasless.domainVersion ?? \"0.0.1\",\n        chainId: transaction.chain.id,\n        verifyingContract: forrwaderContract.address\n      },\n      message,\n      primaryType: \"ForwardRequest\",\n      types: {\n        ForwardRequest\n      }\n    }), message];\n  })();\n  // TODO: handle special case for `approve` -> `permit`\n  const messageType = \"forward\";\n  return {\n    message,\n    signature,\n    messageType\n  };\n}\nconst ForwardRequest = [{\n  name: \"from\",\n  type: \"address\"\n}, {\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"value\",\n  type: \"uint256\"\n}, {\n  name: \"gas\",\n  type: \"uint256\"\n}, {\n  name: \"nonce\",\n  type: \"uint256\"\n}, {\n  name: \"data\",\n  type: \"bytes\"\n}];\nconst ChainAwareForwardRequest = [{\n  name: \"from\",\n  type: \"address\"\n}, {\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"value\",\n  type: \"uint256\"\n}, {\n  name: \"gas\",\n  type: \"uint256\"\n}, {\n  name: \"nonce\",\n  type: \"uint256\"\n}, {\n  name: \"data\",\n  type: \"bytes\"\n}, {\n  name: \"chainid\",\n  type: \"uint256\"\n}];\n/**\n * @internal\n */\nexport async function relayEngineTransaction(options) {\n  const {\n    message,\n    messageType,\n    signature\n  } = await prepareEngineTransaction(options);\n  const response = await fetch(options.gasless.relayerUrl, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: stringify({\n      request: message,\n      type: messageType,\n      signature,\n      forwarderAddress: options.gasless.relayerForwarderAddress\n    })\n  });\n  if (!response.ok) {\n    throw new Error(`Failed to send transaction: ${await response.text()}`);\n  }\n  const json = await response.json();\n  if (!json.result) {\n    throw new Error(`Relay transaction failed: ${json.message}`);\n  }\n  const queueId = json.result.queueId;\n  // poll for transactionHash\n  const timeout = 60000;\n  const interval = 1000;\n  const endtime = Date.now() + timeout;\n  while (Date.now() < endtime) {\n    const receipt = await fetchReceipt({\n      options,\n      queueId\n    });\n    if (receipt) {\n      return {\n        transactionHash: receipt.transactionHash,\n        chain: options.transaction.chain,\n        client: options.transaction.client\n      };\n    }\n    await new Promise(resolve => setTimeout(resolve, interval));\n  }\n  throw new Error(`Failed to find relayed transaction after ${timeout}ms`);\n}\nasync function fetchReceipt(args) {\n  const {\n    options,\n    queueId\n  } = args;\n  const url = options.gasless.relayerUrl.split(\"/relayer/\")[0];\n  const res = await fetch(`${url}/transaction/status/${queueId}`, {\n    method: \"GET\"\n  });\n  const resJson = await res.json();\n  if (!res.ok) {\n    return null;\n  }\n  const result = resJson.result;\n  if (!result) {\n    return null;\n  }\n  switch (result.status) {\n    case \"errored\":\n      throw new Error(`Transaction errored with reason: ${result.errorMessage}`);\n    case \"cancelled\":\n      throw new Error(\"Transaction execution cancelled.\");\n    case \"mined\":\n      {\n        const receipt = await waitForReceipt({\n          client: options.transaction.client,\n          chain: options.transaction.chain,\n          transactionHash: result.transactionHash\n        });\n        return receipt;\n      }\n    default:\n      {\n        return null;\n      }\n  }\n}\n//# sourceMappingURL=engine.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}