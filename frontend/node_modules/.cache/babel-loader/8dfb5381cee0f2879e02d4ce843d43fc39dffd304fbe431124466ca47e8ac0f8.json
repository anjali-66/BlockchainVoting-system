{"ast":null,"code":"/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// BLS (Barreto-Lynn-Scott) family of pairing-friendly curves.\n// TODO: import { AffinePoint } from './curve.js';\nimport { getMinHashLength, mapHashToField } from './modular.js';\nimport { ensureBytes, memoized } from './utils.js';\n// prettier-ignore\nimport { createHasher } from './hash-to-curve.js';\nimport { weierstrassPoints } from './weierstrass.js';\n// prettier-ignore\nconst _0n = BigInt(0),\n  _1n = BigInt(1),\n  _2n = BigInt(2),\n  _3n = BigInt(3);\n// Not used with BLS12-381 (no sequential `11` in X). Useful for other curves.\nfunction NAfDecomposition(a) {\n  const res = [];\n  // a>1 because of marker bit\n  for (; a > _1n; a >>= _1n) {\n    if ((a & _1n) === _0n) res.unshift(0);else if ((a & _3n) === _3n) {\n      res.unshift(-1);\n      a += _1n;\n    } else res.unshift(1);\n  }\n  return res;\n}\nexport function bls(CURVE) {\n  // Fields are specific for curve, so for now we'll need to pass them with opts\n  const {\n    Fp,\n    Fr,\n    Fp2,\n    Fp6,\n    Fp12\n  } = CURVE.fields;\n  const BLS_X_IS_NEGATIVE = CURVE.params.xNegative;\n  const TWIST = CURVE.params.twistType;\n  // Point on G1 curve: (x, y)\n  const G1_ = weierstrassPoints({\n    n: Fr.ORDER,\n    ...CURVE.G1\n  });\n  const G1 = Object.assign(G1_, createHasher(G1_.ProjectivePoint, CURVE.G1.mapToCurve, {\n    ...CURVE.htfDefaults,\n    ...CURVE.G1.htfDefaults\n  }));\n  // Point on G2 curve (complex numbers): (x₁, x₂+i), (y₁, y₂+i)\n  const G2_ = weierstrassPoints({\n    n: Fr.ORDER,\n    ...CURVE.G2\n  });\n  const G2 = Object.assign(G2_, createHasher(G2_.ProjectivePoint, CURVE.G2.mapToCurve, {\n    ...CURVE.htfDefaults,\n    ...CURVE.G2.htfDefaults\n  }));\n  // Applies sparse multiplication as line function\n  let lineFunction;\n  if (TWIST === 'multiplicative') {\n    lineFunction = (c0, c1, c2, f, Px, Py) => Fp12.mul014(f, c0, Fp2.mul(c1, Px), Fp2.mul(c2, Py));\n  } else if (TWIST === 'divisive') {\n    // NOTE: it should be [c0, c1, c2], but we use different order here to reduce complexity of\n    // precompute calculations.\n    lineFunction = (c0, c1, c2, f, Px, Py) => Fp12.mul034(f, Fp2.mul(c2, Py), Fp2.mul(c1, Px), c0);\n  } else throw new Error('bls: unknown twist type');\n  const Fp2div2 = Fp2.div(Fp2.ONE, Fp2.mul(Fp2.ONE, _2n));\n  function pointDouble(ell, Rx, Ry, Rz) {\n    const t0 = Fp2.sqr(Ry); // Ry²\n    const t1 = Fp2.sqr(Rz); // Rz²\n    const t2 = Fp2.mulByB(Fp2.mul(t1, _3n)); // 3 * T1 * B\n    const t3 = Fp2.mul(t2, _3n); // 3 * T2\n    const t4 = Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(Ry, Rz)), t1), t0); // (Ry + Rz)² - T1 - T0\n    const c0 = Fp2.sub(t2, t0); // T2 - T0 (i)\n    const c1 = Fp2.mul(Fp2.sqr(Rx), _3n); // 3 * Rx²\n    const c2 = Fp2.neg(t4); // -T4 (-h)\n    ell.push([c0, c1, c2]);\n    Rx = Fp2.mul(Fp2.mul(Fp2.mul(Fp2.sub(t0, t3), Rx), Ry), Fp2div2); // ((T0 - T3) * Rx * Ry) / 2\n    Ry = Fp2.sub(Fp2.sqr(Fp2.mul(Fp2.add(t0, t3), Fp2div2)), Fp2.mul(Fp2.sqr(t2), _3n)); // ((T0 + T3) / 2)² - 3 * T2²\n    Rz = Fp2.mul(t0, t4); // T0 * T4\n    return {\n      Rx,\n      Ry,\n      Rz\n    };\n  }\n  function pointAdd(ell, Rx, Ry, Rz, Qx, Qy) {\n    // Addition\n    const t0 = Fp2.sub(Ry, Fp2.mul(Qy, Rz)); // Ry - Qy * Rz\n    const t1 = Fp2.sub(Rx, Fp2.mul(Qx, Rz)); // Rx - Qx * Rz\n    const c0 = Fp2.sub(Fp2.mul(t0, Qx), Fp2.mul(t1, Qy)); // T0 * Qx - T1 * Qy == Ry * Qx  - Rx * Qy\n    const c1 = Fp2.neg(t0); // -T0 == Qy * Rz - Ry\n    const c2 = t1; // == Rx - Qx * Rz\n    ell.push([c0, c1, c2]);\n    const t2 = Fp2.sqr(t1); // T1²\n    const t3 = Fp2.mul(t2, t1); // T2 * T1\n    const t4 = Fp2.mul(t2, Rx); // T2 * Rx\n    const t5 = Fp2.add(Fp2.sub(t3, Fp2.mul(t4, _2n)), Fp2.mul(Fp2.sqr(t0), Rz)); // T3 - 2 * T4 + T0² * Rz\n    Rx = Fp2.mul(t1, t5); // T1 * T5\n    Ry = Fp2.sub(Fp2.mul(Fp2.sub(t4, t5), t0), Fp2.mul(t3, Ry)); // (T4 - T5) * T0 - T3 * Ry\n    Rz = Fp2.mul(Rz, t3); // Rz * T3\n    return {\n      Rx,\n      Ry,\n      Rz\n    };\n  }\n  // Pre-compute coefficients for sparse multiplication\n  // Point addition and point double calculations is reused for coefficients\n  // pointAdd happens only if bit set, so wNAF is reasonable. Unfortunately we cannot combine\n  // add + double in windowed precomputes here, otherwise it would be single op (since X is static)\n  const ATE_NAF = NAfDecomposition(CURVE.params.ateLoopSize);\n  const calcPairingPrecomputes = memoized(point => {\n    const p = point;\n    const {\n      x,\n      y\n    } = p.toAffine();\n    // prettier-ignore\n    const Qx = x,\n      Qy = y,\n      negQy = Fp2.neg(y);\n    // prettier-ignore\n    let Rx = Qx,\n      Ry = Qy,\n      Rz = Fp2.ONE;\n    const ell = [];\n    for (const bit of ATE_NAF) {\n      const cur = [];\n      ({\n        Rx,\n        Ry,\n        Rz\n      } = pointDouble(cur, Rx, Ry, Rz));\n      if (bit) ({\n        Rx,\n        Ry,\n        Rz\n      } = pointAdd(cur, Rx, Ry, Rz, Qx, bit === -1 ? negQy : Qy));\n      ell.push(cur);\n    }\n    if (CURVE.postPrecompute) {\n      const last = ell[ell.length - 1];\n      CURVE.postPrecompute(Rx, Ry, Rz, Qx, Qy, pointAdd.bind(null, last));\n    }\n    return ell;\n  });\n  function millerLoopBatch(pairs, withFinalExponent = false) {\n    let f12 = Fp12.ONE;\n    if (pairs.length) {\n      const ellLen = pairs[0][0].length;\n      for (let i = 0; i < ellLen; i++) {\n        f12 = Fp12.sqr(f12); // This allows us to do sqr only one time for all pairings\n        // NOTE: we apply multiple pairings in parallel here\n        for (const [ell, Px, Py] of pairs) {\n          for (const [c0, c1, c2] of ell[i]) f12 = lineFunction(c0, c1, c2, f12, Px, Py);\n        }\n      }\n    }\n    if (BLS_X_IS_NEGATIVE) f12 = Fp12.conjugate(f12);\n    return withFinalExponent ? Fp12.finalExponentiate(f12) : f12;\n  }\n  // Calculates product of multiple pairings\n  // This up to x2 faster than just `map(({g1, g2})=>pairing({g1,g2}))`\n  function pairingBatch(pairs, withFinalExponent = true) {\n    const res = [];\n    // This cache precomputed toAffine for all points\n    G1.ProjectivePoint.normalizeZ(pairs.map(({\n      g1\n    }) => g1));\n    G2.ProjectivePoint.normalizeZ(pairs.map(({\n      g2\n    }) => g2));\n    for (const {\n      g1,\n      g2\n    } of pairs) {\n      if (g1.equals(G1.ProjectivePoint.ZERO) || g2.equals(G2.ProjectivePoint.ZERO)) throw new Error('pairing is not available for ZERO point');\n      // This uses toAffine inside\n      g1.assertValidity();\n      g2.assertValidity();\n      const Qa = g1.toAffine();\n      res.push([calcPairingPrecomputes(g2), Qa.x, Qa.y]);\n    }\n    return millerLoopBatch(res, withFinalExponent);\n  }\n  // Calculates bilinear pairing\n  function pairing(Q, P, withFinalExponent = true) {\n    return pairingBatch([{\n      g1: Q,\n      g2: P\n    }], withFinalExponent);\n  }\n  const utils = {\n    randomPrivateKey: () => {\n      const length = getMinHashLength(Fr.ORDER);\n      return mapHashToField(CURVE.randomBytes(length), Fr.ORDER);\n    },\n    calcPairingPrecomputes\n  };\n  const {\n    ShortSignature\n  } = CURVE.G1;\n  const {\n    Signature\n  } = CURVE.G2;\n  function normP1(point) {\n    return point instanceof G1.ProjectivePoint ? point : G1.ProjectivePoint.fromHex(point);\n  }\n  function normP1Hash(point, htfOpts) {\n    return point instanceof G1.ProjectivePoint ? point : G1.hashToCurve(ensureBytes('point', point), htfOpts);\n  }\n  function normP2(point) {\n    return point instanceof G2.ProjectivePoint ? point : Signature.fromHex(point);\n  }\n  function normP2Hash(point, htfOpts) {\n    return point instanceof G2.ProjectivePoint ? point : G2.hashToCurve(ensureBytes('point', point), htfOpts);\n  }\n  // Multiplies generator (G1) by private key.\n  // P = pk x G\n  function getPublicKey(privateKey) {\n    return G1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);\n  }\n  // Multiplies generator (G2) by private key.\n  // P = pk x G\n  function getPublicKeyForShortSignatures(privateKey) {\n    return G2.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);\n  }\n  function sign(message, privateKey, htfOpts) {\n    const msgPoint = normP2Hash(message, htfOpts);\n    msgPoint.assertValidity();\n    const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));\n    if (message instanceof G2.ProjectivePoint) return sigPoint;\n    return Signature.toRawBytes(sigPoint);\n  }\n  function signShortSignature(message, privateKey, htfOpts) {\n    const msgPoint = normP1Hash(message, htfOpts);\n    msgPoint.assertValidity();\n    const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));\n    if (message instanceof G1.ProjectivePoint) return sigPoint;\n    return ShortSignature.toRawBytes(sigPoint);\n  }\n  // Checks if pairing of public key & hash is equal to pairing of generator & signature.\n  // e(P, H(m)) == e(G, S)\n  function verify(signature, message, publicKey, htfOpts) {\n    const P = normP1(publicKey);\n    const Hm = normP2Hash(message, htfOpts);\n    const G = G1.ProjectivePoint.BASE;\n    const S = normP2(signature);\n    const exp = pairingBatch([{\n      g1: P.negate(),\n      g2: Hm\n    },\n    // ePHM = pairing(P.negate(), Hm, false);\n    {\n      g1: G,\n      g2: S\n    } // eGS = pairing(G, S, false);\n    ]);\n    return Fp12.eql(exp, Fp12.ONE);\n  }\n  // Checks if pairing of public key & hash is equal to pairing of generator & signature.\n  // e(S, G) == e(H(m), P)\n  function verifyShortSignature(signature, message, publicKey, htfOpts) {\n    const P = normP2(publicKey);\n    const Hm = normP1Hash(message, htfOpts);\n    const G = G2.ProjectivePoint.BASE;\n    const S = normP1(signature);\n    const exp = pairingBatch([{\n      g1: Hm,\n      g2: P\n    },\n    // eHmP = pairing(Hm, P, false);\n    {\n      g1: S,\n      g2: G.negate()\n    } // eSG = pairing(S, G.negate(), false);\n    ]);\n    return Fp12.eql(exp, Fp12.ONE);\n  }\n  function aNonEmpty(arr) {\n    if (!Array.isArray(arr) || arr.length === 0) throw new Error('expected non-empty array');\n  }\n  function aggregatePublicKeys(publicKeys) {\n    aNonEmpty(publicKeys);\n    const agg = publicKeys.map(normP1).reduce((sum, p) => sum.add(p), G1.ProjectivePoint.ZERO);\n    const aggAffine = agg; //.toAffine();\n    if (publicKeys[0] instanceof G1.ProjectivePoint) {\n      aggAffine.assertValidity();\n      return aggAffine;\n    }\n    // toRawBytes ensures point validity\n    return aggAffine.toRawBytes(true);\n  }\n  function aggregateSignatures(signatures) {\n    aNonEmpty(signatures);\n    const agg = signatures.map(normP2).reduce((sum, s) => sum.add(s), G2.ProjectivePoint.ZERO);\n    const aggAffine = agg; //.toAffine();\n    if (signatures[0] instanceof G2.ProjectivePoint) {\n      aggAffine.assertValidity();\n      return aggAffine;\n    }\n    return Signature.toRawBytes(aggAffine);\n  }\n  function aggregateShortSignatures(signatures) {\n    aNonEmpty(signatures);\n    const agg = signatures.map(normP1).reduce((sum, s) => sum.add(s), G1.ProjectivePoint.ZERO);\n    const aggAffine = agg; //.toAffine();\n    if (signatures[0] instanceof G1.ProjectivePoint) {\n      aggAffine.assertValidity();\n      return aggAffine;\n    }\n    return ShortSignature.toRawBytes(aggAffine);\n  }\n  // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407\n  // e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))\n  function verifyBatch(signature,\n  // TODO: maybe `{message: G2Hex, publicKey: G1Hex}[]` instead?\n  messages, publicKeys, htfOpts) {\n    aNonEmpty(messages);\n    if (publicKeys.length !== messages.length) throw new Error('amount of public keys and messages should be equal');\n    const sig = normP2(signature);\n    const nMessages = messages.map(i => normP2Hash(i, htfOpts));\n    const nPublicKeys = publicKeys.map(normP1);\n    // NOTE: this works only for exact same object\n    const messagePubKeyMap = new Map();\n    for (let i = 0; i < nPublicKeys.length; i++) {\n      const pub = nPublicKeys[i];\n      const msg = nMessages[i];\n      let keys = messagePubKeyMap.get(msg);\n      if (keys === undefined) {\n        keys = [];\n        messagePubKeyMap.set(msg, keys);\n      }\n      keys.push(pub);\n    }\n    const paired = [];\n    try {\n      for (const [msg, keys] of messagePubKeyMap) {\n        const groupPublicKey = keys.reduce((acc, msg) => acc.add(msg));\n        paired.push({\n          g1: groupPublicKey,\n          g2: msg\n        });\n      }\n      paired.push({\n        g1: G1.ProjectivePoint.BASE.negate(),\n        g2: sig\n      });\n      return Fp12.eql(pairingBatch(paired), Fp12.ONE);\n    } catch {\n      return false;\n    }\n  }\n  G1.ProjectivePoint.BASE._setWindowSize(4);\n  return {\n    getPublicKey,\n    getPublicKeyForShortSignatures,\n    sign,\n    signShortSignature,\n    verify,\n    verifyBatch,\n    verifyShortSignature,\n    aggregatePublicKeys,\n    aggregateSignatures,\n    aggregateShortSignatures,\n    millerLoopBatch,\n    pairing,\n    pairingBatch,\n    G1,\n    G2,\n    Signature,\n    ShortSignature,\n    fields: {\n      Fr,\n      Fp,\n      Fp2,\n      Fp6,\n      Fp12\n    },\n    params: {\n      ateLoopSize: CURVE.params.ateLoopSize,\n      r: CURVE.params.r,\n      G1b: CURVE.G1.b,\n      G2b: CURVE.G2.b\n    },\n    utils\n  };\n}\n//# sourceMappingURL=bls.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}