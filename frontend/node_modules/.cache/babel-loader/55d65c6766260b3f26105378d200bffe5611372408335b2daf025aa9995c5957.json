{"ast":null,"code":"import { watchBlockNumber } from \"../../rpc/watchBlockNumber.js\";\nimport { getCallsStatus } from \"./get-calls-status.js\";\nconst DEFAULT_MAX_BLOCKS_WAIT_TIME = 100;\nconst map = new Map();\n/**\n * Waits for the [EIP-5792](https://eips.ethereum.org/EIPS/eip-5792) bundle to be confirmed.\n *\n *  This function is dependent on the wallet's support for EIP-5792 and could fail.\n *\n * @param options - The options for waiting for the bundle.\n * By default, the max wait time is 100 blocks.\n * @returns A promise that resolves with the final {@link getCallsStatus} result.\n * @throws an error if the wallet does not support EIP-5792.\n * @beta\n * @example\n * ```ts\n * import { waitForBundle } from \"thirdweb/wallets/eip5792\";\n * const result = await waitForBundle({\n *   client,\n *   chain,\n *   wallet,\n *   bundleId: \"0x123...\",\n * });\n * ```\n * @extension EIP5792\n */\nexport function waitForBundle(options) {\n  const {\n    bundleId,\n    chain,\n    wallet,\n    client\n  } = options;\n  const chainId = chain.id;\n  const key = `${chainId}:calls_${bundleId}`;\n  const maxBlocksWaitTime = options.maxBlocksWaitTime ?? DEFAULT_MAX_BLOCKS_WAIT_TIME;\n  if (map.has(key)) {\n    // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set\n    return map.get(key);\n  }\n  const promise = new Promise((resolve, reject) => {\n    // start at -1 because the first block doesn't count\n    let blocksWaited = -1;\n    const unwatch = watchBlockNumber({\n      client: client,\n      chain: chain,\n      onNewBlockNumber: async () => {\n        blocksWaited++;\n        if (blocksWaited >= maxBlocksWaitTime) {\n          unwatch();\n          reject(new Error(`Bundle not confirmed after ${maxBlocksWaitTime} blocks`));\n          return;\n        }\n        try {\n          const result = await getCallsStatus({\n            wallet,\n            client,\n            bundleId\n          });\n          if (result.status === \"CONFIRMED\") {\n            // stop the polling\n            unwatch();\n            // resolve the top level promise with the result\n            resolve(result);\n          }\n        } catch {\n          // noop, we'll try again on the next blocks\n        }\n      }\n    });\n    // remove the promise from the map when it's done (one way or the other)\n  }).finally(() => {\n    map.delete(key);\n  });\n  map.set(key, promise);\n  return promise;\n}\n//# sourceMappingURL=wait-for-bundle.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}