{"ast":null,"code":"import { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport { webLocalStorage } from \"../../../../utils/storage/webStorage.js\";\nimport { getUserStatus } from \"../../core/actions/get-enclave-user-status.js\";\nimport { authEndpoint } from \"../../core/authentication/authEndpoint.js\";\nimport { ClientScopedStorage } from \"../../core/authentication/client-scoped-storage.js\";\nimport { guestAuthenticate } from \"../../core/authentication/guest.js\";\nimport { customJwt } from \"../../core/authentication/jwt.js\";\nimport { getLinkedProfilesInternal, linkAccount, unlinkAccount } from \"../../core/authentication/linkAccount.js\";\nimport { loginWithPasskey, registerPasskey } from \"../../core/authentication/passkeys.js\";\nimport { siweAuthenticate } from \"../../core/authentication/siwe.js\";\nimport { EnclaveWallet } from \"../../core/wallet/enclave-wallet.js\";\nimport { InAppWalletIframeCommunicator } from \"../utils/iFrameCommunication/InAppWalletIframeCommunicator.js\";\nimport { Auth } from \"./auth/iframe-auth.js\";\nimport { loginWithOauth, loginWithOauthRedirect } from \"./auth/oauth.js\";\nimport { sendOtp, verifyOtp } from \"./auth/otp.js\";\nimport { IFrameWallet } from \"./iframe-wallet.js\";\n/**\n * @internal\n */\nexport class InAppWebConnector {\n  isClientIdLegacyPaper(clientId) {\n    if (clientId.indexOf(\"-\") > 0 && clientId.length === 36) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * @example\n   * `const thirdwebInAppWallet = new InAppWalletSdk({ clientId: \"\", chain: \"Goerli\" });`\n   * @internal\n   */\n  constructor({\n    client,\n    onAuthSuccess,\n    ecosystem,\n    passkeyDomain\n  }) {\n    Object.defineProperty(this, \"client\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"ecosystem\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"querier\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"storage\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"wallet\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\n     * Used to manage the Auth state of the user.\n     */\n    Object.defineProperty(this, \"auth\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"passkeyDomain\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    if (this.isClientIdLegacyPaper(client.clientId)) {\n      throw new Error(\"You are using a legacy clientId. Please use the clientId found on the thirdweb dashboard settings page\");\n    }\n    const baseUrl = getThirdwebBaseUrl(\"inAppWallet\");\n    this.client = client;\n    this.ecosystem = ecosystem;\n    this.passkeyDomain = passkeyDomain;\n    this.storage = new ClientScopedStorage({\n      storage: webLocalStorage,\n      clientId: client.clientId,\n      ecosystem: ecosystem\n    });\n    this.querier = new InAppWalletIframeCommunicator({\n      clientId: client.clientId,\n      ecosystem,\n      baseUrl\n    });\n    this.auth = new Auth({\n      client,\n      querier: this.querier,\n      baseUrl,\n      localStorage: this.storage,\n      ecosystem,\n      onAuthSuccess: async authResult => {\n        onAuthSuccess?.(authResult);\n        if (authResult.storedToken.authDetails.walletType === \"sharded\") {\n          // If this is an existing sharded ecosystem wallet, we'll need to migrate\n          const result = await this.querier.call({\n            procedureName: \"migrateFromShardToEnclave\",\n            params: {\n              storedToken: authResult.storedToken\n            }\n          });\n          if (!result) {\n            console.warn(\"Failed to migrate from sharded to enclave wallet, continuing with sharded wallet\");\n          }\n        }\n        this.wallet = await this.initializeWallet(authResult.storedToken.cookieString);\n        if (!this.wallet) {\n          throw new Error(\"Failed to initialize wallet\");\n        }\n        const deviceShareStored = \"deviceShareStored\" in authResult.walletDetails ? authResult.walletDetails.deviceShareStored : undefined;\n        await this.wallet.postWalletSetUp({\n          storedToken: authResult.storedToken,\n          deviceShareStored\n        });\n        if (this.wallet instanceof IFrameWallet) {\n          await this.querier.call({\n            procedureName: \"initIframe\",\n            params: {\n              partnerId: ecosystem?.partnerId,\n              ecosystemId: ecosystem?.id,\n              clientId: this.client.clientId,\n              // For enclave wallets we won't have a device share\n              deviceShareStored: \"deviceShareStored\" in authResult.walletDetails ? authResult.walletDetails.deviceShareStored : null,\n              walletUserId: authResult.storedToken.authDetails.userWalletId,\n              authCookie: authResult.storedToken.cookieString\n            }\n          });\n        }\n        return {\n          user: {\n            status: \"Logged In, Wallet Initialized\",\n            authDetails: authResult.storedToken.authDetails,\n            account: await this.wallet.getAccount(),\n            walletAddress: authResult.walletDetails.walletAddress\n          }\n        };\n      }\n    });\n  }\n  async initializeWallet(authToken) {\n    const storedAuthToken = await this.storage.getAuthCookie();\n    if (!authToken && storedAuthToken === null) {\n      throw new Error(\"No auth token provided and no stored auth token found to initialize the wallet\");\n    }\n    const user = await getUserStatus({\n      authToken: authToken || storedAuthToken,\n      client: this.client,\n      ecosystem: this.ecosystem\n    });\n    if (!user) {\n      throw new Error(\"Cannot initialize wallet, no user logged in\");\n    }\n    if (user.wallets.length === 0) {\n      throw new Error(\"Cannot initialize wallet, this user does not have a wallet generated yet\");\n    }\n    if (user.wallets[0]?.type === \"enclave\") {\n      return new EnclaveWallet({\n        client: this.client,\n        ecosystem: this.ecosystem,\n        address: user.wallets[0].address,\n        storage: this.storage\n      });\n    }\n    return new IFrameWallet({\n      client: this.client,\n      ecosystem: this.ecosystem,\n      querier: this.querier,\n      localStorage: this.storage\n    });\n  }\n  /**\n   * Gets the user if they're logged in\n   * @example\n   * ```js\n   *  const user = await thirdwebInAppWallet.getUser();\n   *  switch (user.status) {\n   *     case UserWalletStatus.LOGGED_OUT: {\n   *       // User is logged out, call one of the auth methods on thirdwebInAppWallet.auth to authenticate the user\n   *       break;\n   *     }\n   *     case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED: {\n   *       // user is logged in and wallet is all set up.\n   *       // You have access to:\n   *       user.status;\n   *       user.authDetails;\n   *       user.walletAddress;\n   *       user.wallet;\n   *       break;\n   *     }\n   * }\n   * ```\n   * @returns GetUser - an object to containing various information on the user statuses\n   */\n  async getUser() {\n    // If we don't have a wallet yet we'll create one\n    if (!this.wallet) {\n      const localAuthToken = await this.storage.getAuthCookie();\n      if (!localAuthToken) {\n        return {\n          status: \"Logged Out\"\n        };\n      }\n      this.wallet = await this.initializeWallet(localAuthToken);\n    }\n    if (!this.wallet) {\n      throw new Error(\"Wallet not initialized\");\n    }\n    return await this.wallet.getUserWalletStatus();\n  }\n  getAccount() {\n    if (!this.wallet) {\n      throw new Error(\"Wallet not initialized\");\n    }\n    return this.wallet.getAccount();\n  }\n  async preAuthenticate(args) {\n    return sendOtp({\n      ...args,\n      client: this.client,\n      ecosystem: this.ecosystem\n    });\n  }\n  authenticateWithRedirect(strategy, mode, redirectUrl) {\n    loginWithOauthRedirect({\n      authOption: strategy,\n      client: this.client,\n      ecosystem: this.ecosystem,\n      redirectUrl,\n      mode\n    });\n  }\n  async loginWithAuthToken(authResult, recoveryCode) {\n    return this.auth.loginWithAuthToken(authResult, recoveryCode);\n  }\n  /**\n   * Authenticates the user and returns the auth token, but does not instantiate their wallet\n   */\n  async authenticate(args) {\n    const strategy = args.strategy;\n    switch (strategy) {\n      case \"email\":\n        return verifyOtp({\n          ...args,\n          client: this.client,\n          ecosystem: this.ecosystem\n        });\n      case \"phone\":\n        return verifyOtp({\n          ...args,\n          client: this.client,\n          ecosystem: this.ecosystem\n        });\n      case \"auth_endpoint\":\n        {\n          return authEndpoint({\n            payload: args.payload,\n            client: this.client,\n            ecosystem: this.ecosystem\n          });\n        }\n      case \"jwt\":\n        return customJwt({\n          jwt: args.jwt,\n          client: this.client,\n          ecosystem: this.ecosystem\n        });\n      case \"passkey\":\n        {\n          return this.passkeyAuth(args);\n        }\n      case \"iframe_email_verification\":\n        {\n          return this.auth.authenticateWithIframe({\n            email: args.email\n          });\n        }\n      case \"iframe\":\n        {\n          return this.auth.authenticateWithModal();\n        }\n      case \"apple\":\n      case \"facebook\":\n      case \"google\":\n      case \"telegram\":\n      case \"github\":\n      case \"twitch\":\n      case \"farcaster\":\n      case \"line\":\n      case \"x\":\n      case \"steam\":\n      case \"coinbase\":\n      case \"discord\":\n        {\n          return loginWithOauth({\n            authOption: strategy,\n            client: this.client,\n            ecosystem: this.ecosystem,\n            closeOpenedWindow: args.closeOpenedWindow,\n            openedWindow: args.openedWindow\n          });\n        }\n      case \"guest\":\n        {\n          return guestAuthenticate({\n            client: this.client,\n            ecosystem: this.ecosystem,\n            storage: webLocalStorage\n          });\n        }\n      case \"wallet\":\n        {\n          return siweAuthenticate({\n            ecosystem: this.ecosystem,\n            client: this.client,\n            wallet: args.wallet,\n            chain: args.chain\n          });\n        }\n    }\n  }\n  /**\n   * Authenticates the user then instantiates their wallet using the resulting auth token\n   */\n  async connect(args) {\n    const strategy = args.strategy;\n    switch (strategy) {\n      case \"auth_endpoint\":\n      case \"jwt\":\n        {\n          const authToken = await this.authenticate(args);\n          return await this.loginWithAuthToken(authToken, args.encryptionKey);\n        }\n      case \"iframe_email_verification\":\n        {\n          return this.auth.loginWithIframe({\n            email: args.email\n          });\n        }\n      case \"iframe\":\n        {\n          return this.auth.loginWithModal();\n        }\n      case \"passkey\":\n        {\n          const authToken = await this.passkeyAuth(args);\n          return this.loginWithAuthToken(authToken);\n        }\n      case \"phone\":\n      case \"email\":\n      case \"wallet\":\n      case \"apple\":\n      case \"facebook\":\n      case \"google\":\n      case \"farcaster\":\n      case \"telegram\":\n      case \"github\":\n      case \"line\":\n      case \"x\":\n      case \"guest\":\n      case \"coinbase\":\n      case \"twitch\":\n      case \"steam\":\n      case \"discord\":\n        {\n          const authToken = await this.authenticate(args);\n          return await this.auth.loginWithAuthToken(authToken);\n        }\n      default:\n        assertUnreachable(strategy);\n    }\n  }\n  async logout() {\n    return await this.auth.logout();\n  }\n  async passkeyAuth(args) {\n    const {\n      PasskeyWebClient\n    } = await import(\"./auth/passkeys.js\");\n    const {\n      passkeyName,\n      storeLastUsedPasskey = true\n    } = args;\n    const passkeyClient = new PasskeyWebClient();\n    const storage = this.storage;\n    if (args.type === \"sign-up\") {\n      return registerPasskey({\n        client: this.client,\n        ecosystem: this.ecosystem,\n        username: passkeyName,\n        passkeyClient,\n        storage: storeLastUsedPasskey ? storage : undefined,\n        rp: {\n          id: this.passkeyDomain ?? window.location.hostname,\n          name: this.passkeyDomain ?? window.document.title\n        }\n      });\n    }\n    return loginWithPasskey({\n      client: this.client,\n      ecosystem: this.ecosystem,\n      passkeyClient,\n      storage: storeLastUsedPasskey ? storage : undefined,\n      rp: {\n        id: this.passkeyDomain ?? window.location.hostname,\n        name: this.passkeyDomain ?? window.document.title\n      }\n    });\n  }\n  async linkProfile(args) {\n    const {\n      storedToken\n    } = await this.authenticate(args);\n    return await linkAccount({\n      client: args.client,\n      tokenToLink: storedToken.cookieString,\n      storage: this.storage,\n      ecosystem: args.ecosystem || this.ecosystem\n    });\n  }\n  async unlinkProfile(profile) {\n    return await unlinkAccount({\n      client: this.client,\n      storage: this.storage,\n      ecosystem: this.ecosystem,\n      profileToUnlink: profile\n    });\n  }\n  async getProfiles() {\n    return getLinkedProfilesInternal({\n      client: this.client,\n      ecosystem: this.ecosystem,\n      storage: this.storage\n    });\n  }\n}\nfunction assertUnreachable(x, message) {\n  throw new Error(message ?? `Invalid param: ${x}`);\n}\n//# sourceMappingURL=web-connector.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}