{"ast":null,"code":"import { maxUint256, padHex } from \"viem\";\nimport { ZERO_ADDRESS, isNativeTokenAddress } from \"../../../constants/addresses.js\";\nimport { getContractMetadata } from \"../../../extensions/common/read/getContractMetadata.js\";\n/**\n * Get the claim parameters for a given drop\n * @param options - The options for getting the claim parameters\n * @returns The claim parameters\n * @extension ERC1155\n * @example\n * ```ts\n * import { getClaimParams } from \"thirdweb/utils\";\n *\n * const claimParams = await getClaimParams({\n *  contract,\n *  to: \"0x...\",\n *  quantity: 1n,\n *  type: \"erc1155\",\n *  tokenId: 0n,\n * });\n * ```\n * @extension COMMON\n */\nexport async function getClaimParams(options) {\n  const cc = await (async () => {\n    if (options.type === \"erc1155\") {\n      // lazy-load the getActiveClaimCondition function\n      if (options.singlePhaseDrop) {\n        const {\n          claimCondition\n        } = await import(\"../../../extensions/erc1155/__generated__/IDropSinglePhase1155/read/claimCondition.js\");\n        return await claimCondition({\n          contract: options.contract,\n          tokenId: options.tokenId\n        });\n      }\n      const {\n        getActiveClaimCondition\n      } = await import(\"../../../extensions/erc1155/drops/read/getActiveClaimCondition.js\");\n      return await getActiveClaimCondition({\n        contract: options.contract,\n        tokenId: options.tokenId\n      });\n    }\n    if (options.type === \"erc721\") {\n      // lazy-load the getActiveClaimCondition function\n      if (options.singlePhaseDrop) {\n        const {\n          claimCondition\n        } = await import(\"../../../extensions/erc721/__generated__/IDropSinglePhase/read/claimCondition.js\");\n        return await claimCondition({\n          contract: options.contract\n        });\n      }\n      const {\n        getActiveClaimCondition\n      } = await import(\"../../../extensions/erc721/drops/read/getActiveClaimCondition.js\");\n      return await getActiveClaimCondition({\n        contract: options.contract\n      });\n    }\n    // otherwise erc20 case!\n    // lazy-load the getActiveClaimCondition function\n    if (options.singlePhaseDrop) {\n      // same ABI as erc721\n      const {\n        claimCondition\n      } = await import(\"../../../extensions/erc721/__generated__/IDropSinglePhase/read/claimCondition.js\");\n      return await claimCondition({\n        contract: options.contract\n      });\n    }\n    const {\n      getActiveClaimCondition\n    } = await import(\"../../../extensions/erc20/drops/read/getActiveClaimCondition.js\");\n    return await getActiveClaimCondition({\n      contract: options.contract\n    });\n  })();\n  const tokenDecimals = options.type === \"erc20\" ? options.tokenDecimals : 0; // nfts have no decimals\n  // compute the allowListProof in an iife\n  const allowlistProof = await (async () => {\n    // early exit if no merkle root is set\n    if (!cc.merkleRoot || cc.merkleRoot === padHex(\"0x\", {\n      size: 32\n    })) {\n      return {\n        currency: ZERO_ADDRESS,\n        proof: [],\n        quantityLimitPerWallet: 0n,\n        pricePerToken: maxUint256\n      };\n    }\n    // lazy-load the fetchProofsForClaimer function if we need it\n    const {\n      fetchProofsForClaimer\n    } = await import(\"./fetch-proofs-for-claimers.js\");\n    // 1. fetch merkle data from contract URI\n    const metadata = await getContractMetadata({\n      contract: options.contract\n    });\n    const merkleData = metadata.merkle || {};\n    const snapshotUri = merkleData[cc.merkleRoot];\n    if (!snapshotUri) {\n      return {\n        currency: ZERO_ADDRESS,\n        proof: [],\n        quantityLimitPerWallet: 0n,\n        pricePerToken: maxUint256\n      };\n    }\n    const allowListProof = await fetchProofsForClaimer({\n      contract: options.contract,\n      claimer: options.from || options.to,\n      // receiver and claimer can be different, always prioritize the claimer for allowlists\n      merkleTreeUri: snapshotUri,\n      tokenDecimals\n    });\n    // if no proof is found, we'll try the empty proof\n    if (!allowListProof) {\n      return {\n        currency: ZERO_ADDRESS,\n        proof: [],\n        quantityLimitPerWallet: 0n,\n        pricePerToken: maxUint256\n      };\n    }\n    // otherwise return the proof\n    return allowListProof;\n  })();\n  // currency and price need to match the allowlist proof if set\n  // if default values in the allowlist proof, fallback to the claim condition\n  const currency = allowlistProof.currency && allowlistProof.currency !== ZERO_ADDRESS ? allowlistProof.currency : cc.currency;\n  const pricePerToken = allowlistProof.pricePerToken !== undefined && allowlistProof.pricePerToken !== maxUint256 ? allowlistProof.pricePerToken : cc.pricePerToken;\n  const totalPrice = pricePerToken * options.quantity / BigInt(10 ** tokenDecimals);\n  const value = isNativeTokenAddress(currency) ? totalPrice : 0n;\n  const erc20Value = !isNativeTokenAddress(currency) && pricePerToken > 0n ? {\n    amountWei: totalPrice,\n    tokenAddress: currency\n  } : undefined;\n  return {\n    receiver: options.to,\n    tokenId: options.type === \"erc1155\" ? options.tokenId : undefined,\n    quantity: options.quantity,\n    currency,\n    pricePerToken,\n    allowlistProof,\n    data: \"0x\",\n    overrides: {\n      value,\n      erc20Value\n    }\n  };\n}\n//# sourceMappingURL=get-claim-params.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}