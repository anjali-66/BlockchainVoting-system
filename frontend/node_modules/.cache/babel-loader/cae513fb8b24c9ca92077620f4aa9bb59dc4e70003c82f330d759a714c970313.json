{"ast":null,"code":"import { getContract } from \"../../../contract/contract.js\";\nimport { toTokens } from \"../../../utils/units.js\";\nimport { getCurrencyMetadata } from \"../../erc20/read/getCurrencyMetadata.js\";\nimport { isERC721 } from \"../../erc721/read/isERC721.js\";\nimport { isERC1155 } from \"../../erc1155/read/isERC1155.js\";\nimport { computeStatus, getNFTAsset } from \"../utils.js\";\n/**\n * @internal\n */\nexport async function mapDirectListing(options) {\n  const {\n    latestBlock,\n    rawListing\n  } = options;\n  // process the listing\n  const status = computeStatus({\n    listingStatus: rawListing.status,\n    blockTimeStamp: latestBlock.timestamp,\n    startTimestamp: rawListing.startTimestamp,\n    endTimestamp: rawListing.endTimestamp\n  });\n  const [currencyValuePerToken, nftAsset] = await Promise.all([getCurrencyMetadata({\n    contract: getContract({\n      ...options.contract,\n      address: rawListing.currency\n    })\n  }), getNFTAsset({\n    ...options,\n    contract: getContract({\n      ...options.contract,\n      address: rawListing.assetContract\n    }),\n    tokenId: rawListing.tokenId\n  })]);\n  return {\n    id: rawListing.listingId,\n    creatorAddress: rawListing.listingCreator,\n    assetContractAddress: rawListing.assetContract,\n    tokenId: rawListing.tokenId,\n    quantity: rawListing.quantity,\n    currencyContractAddress: rawListing.currency,\n    currencyValuePerToken: {\n      ...currencyValuePerToken,\n      value: rawListing.pricePerToken,\n      displayValue: toTokens(rawListing.pricePerToken, currencyValuePerToken.decimals)\n    },\n    pricePerToken: rawListing.pricePerToken,\n    asset: nftAsset,\n    startTimeInSeconds: rawListing.startTimestamp,\n    endTimeInSeconds: rawListing.endTimestamp,\n    isReservedListing: rawListing.reserved,\n    status,\n    type: \"direct-listing\"\n  };\n}\nexport async function isListingValid(options) {\n  const assetContract = getContract({\n    ...options.contract,\n    address: options.listing.assetContractAddress\n  });\n  const [erc721, erc1155] = await Promise.all([isERC721({\n    contract: assetContract\n  }), isERC1155({\n    contract: assetContract\n  })]);\n  // if the asset is an erc721 token\n  if (erc721) {\n    const [{\n      isApprovedForAll\n    }, {\n      getApproved\n    }, {\n      ownerOf\n    }] = await Promise.all([import(\"../../erc721/__generated__/IERC721A/read/isApprovedForAll.js\"), import(\"../../erc721/__generated__/IERC721A/read/getApproved.js\"), import(\"../../erc721/__generated__/IERC721A/read/ownerOf.js\")]);\n    // check for token approval\n    const [approvedForAll, approvedOperator, tokenOwner] = await Promise.all([isApprovedForAll({\n      contract: assetContract,\n      owner: options.listing.creatorAddress,\n      // the marketplace contract address has to be approved to transfer the token\n      operator: options.contract.address\n    }), getApproved({\n      contract: assetContract,\n      tokenId: options.listing.tokenId\n    }).catch(() => \"\"), ownerOf({\n      contract: assetContract,\n      tokenId: options.listing.tokenId\n    })]);\n    // if the marketplace is not approved for all and the marketplace contract is not the approved operator for the token\n    // -> the listing is not valid\n    if (!approvedForAll && approvedOperator !== options.contract.address) {\n      return {\n        valid: false,\n        reason: \"Asset not approved for marketplace.\"\n      };\n    }\n    // if the token owner is not the creator of the listing\n    // -> the listing is not valid\n    if (tokenOwner !== options.listing.creatorAddress) {\n      return {\n        valid: false,\n        reason: \"Listing creator no longer owns this token.\"\n      };\n    }\n    // otherwise the listing is valid\n    return {\n      valid: true\n    };\n  }\n  // if the asset is an erc1155 token\n  if (erc1155) {\n    const [{\n      isApprovedForAll\n    }, {\n      balanceOf\n    }] = await Promise.all([import(\"../../erc1155/__generated__/IERC1155/read/isApprovedForAll.js\"), import(\"../../erc1155/__generated__/IERC1155/read/balanceOf.js\")]);\n    const [approvedForAll, balance] = await Promise.all([isApprovedForAll({\n      contract: assetContract,\n      owner: options.listing.creatorAddress,\n      // the marketplace contract address has to be approved to transfer the token\n      operator: options.contract.address\n    }), balanceOf({\n      contract: assetContract,\n      owner: options.listing.creatorAddress,\n      tokenId: options.listing.tokenId\n    })]);\n    // if the marketplace is not approved for all\n    // -> the listing is not valid\n    if (!approvedForAll) {\n      return {\n        valid: false,\n        reason: \"Asset not approved for marketplace.\"\n      };\n    }\n    // if the balance is less than the quantity the user is trying to purchase or the listing quantity\n    // -> the listing is not valid\n    const quantityWanted = options.quantity || options.listing.quantity;\n    if (balance < quantityWanted) {\n      return {\n        valid: false,\n        reason: \"Seller does not have enough balance of token to fulfill order.\"\n      };\n    }\n    return {\n      valid: true\n    };\n  }\n  // if the asset is neither ERC721 nor ERC1155\n  return {\n    valid: false,\n    reason: \"AssetContract must implement ERC 1155 or ERC 721.\"\n  };\n}\n//# sourceMappingURL=utils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}