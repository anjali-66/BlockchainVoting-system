{"ast":null,"code":"import { encodeDeployData, encodeFunctionData, isErc6492Signature, serializeSignature, universalSignatureValidatorAbi, universalSignatureValidatorByteCode } from \"viem\";\nimport { getContract } from \"../contract/contract.js\";\nimport { isValidSignature } from \"../extensions/erc1271/__generated__/isValidSignature/read/isValidSignature.js\";\nimport { eth_call } from \"../rpc/actions/eth_call.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport { isZkSyncChain } from \"../utils/any-evm/zksync/isZkSyncChain.js\";\nimport { fromBytes } from \"../utils/encoding/from-bytes.js\";\nimport { hexToBool, isHex } from \"../utils/encoding/hex.js\";\nimport { serializeErc6492Signature } from \"./serialize-erc6492-signature.js\";\nconst ZKSYNC_VALIDATOR_ADDRESS = \"0xfB688330379976DA81eB64Fe4BF50d7401763B9C\";\n/**\n * @description Verify that an address created the provided signature for a given hash using [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492). This function is interoperable with all wallet types, including EOAs.\n * This function should rarely be used directly, instead use @see {import(\"./verify-signature.js\")} and @see {import(\"./verify-typed-data.js\")}}\n *\n * @param {Hex} options.hash The hash that was signed\n * @param {string | Uint8Array | Signature} options.signature The signature that was signed\n * @param {string} options.address The address that signed the hash\n * @param {ThirdwebClient} options.client The Thirdweb client\n * @param {Chain} options.chain The chain that the address is on. For an EOA, this can be any chain.\n * @param {string} [options.accountFactory.address] The address of the account factory that created the account if using a smart account with a custom account factory\n * @param {Hex} [options.accountFactory.verificationCalldata] The calldata that was used to create the account if using a smart account with a custom account factory\n *\n * @returns {Promise<boolean>} A promise that resolves to `true` if the signature is valid, or `false` otherwise.\n *\n * @example\n * ```ts\n * import { verifyHash } from \"thirdweb/utils\";\n * const isValid = await verifyHash({\n *   hash: \"0x1234\",\n *   signature: \"0x1234\",\n *   address: \"0x1234\",\n *   client,\n *   chain,\n * });\n * ```\n *\n * @auth\n */\nexport async function verifyHash({\n  hash,\n  signature,\n  address,\n  client,\n  chain,\n  accountFactory\n}) {\n  const signatureHex = (() => {\n    if (isHex(signature)) return signature;\n    if (typeof signature === \"object\" && \"r\" in signature && \"s\" in signature) return serializeSignature(signature);\n    if (signature instanceof Uint8Array) return fromBytes(signature, \"hex\");\n    // We should never hit this but TS doesn't know that\n    throw new Error(`Invalid signature type for signature ${signature}: ${typeof signature}`);\n  })();\n  const wrappedSignature = await (async () => {\n    // If no factory is provided, we have to assume its already deployed or is an EOA\n    // TODO: Figure out how to automatically tell if our default factory was used\n    if (!accountFactory) return signatureHex;\n    // If this sigature was already wrapped for ERC-6492, carry on\n    if (isErc6492Signature(signatureHex)) return signatureHex;\n    // Otherwise, serialize the signature for ERC-6492 validation\n    return serializeErc6492Signature({\n      address: accountFactory.address,\n      data: accountFactory.verificationCalldata,\n      signature: signatureHex\n    });\n  })();\n  let verificationData;\n  const zkSyncChain = await isZkSyncChain(chain);\n  if (zkSyncChain) {\n    // zksync chains dont support deploying code with eth_call\n    // need to call a deployed contract instead\n    verificationData = {\n      to: ZKSYNC_VALIDATOR_ADDRESS,\n      data: encodeFunctionData({\n        abi: universalSignatureValidatorAbi,\n        functionName: \"isValidSig\",\n        args: [address, hash, wrappedSignature]\n      })\n    };\n  } else {\n    verificationData = {\n      data: encodeDeployData({\n        abi: universalSignatureValidatorAbi,\n        args: [address, hash, wrappedSignature],\n        bytecode: universalSignatureValidatorByteCode\n      })\n    };\n  }\n  const rpcRequest = getRpcClient({\n    chain,\n    client\n  });\n  try {\n    const result = await eth_call(rpcRequest, verificationData);\n    return hexToBool(result);\n  } catch (err) {\n    console.error(\"Error verifying ERC-6492 signature\", err);\n    // Some chains do not support the eth_call simulation and will fail, so we fall back to regular EIP1271 validation\n    const validEip1271 = await verifyEip1271Signature({\n      hash,\n      signature: signatureHex,\n      contract: getContract({\n        chain,\n        address,\n        client\n      })\n    }).catch(err => {\n      console.error(\"Error verifying EIP-1271 signature\", err);\n      return false;\n    });\n    if (validEip1271) {\n      return true;\n    }\n    // TODO: Improve overall RPC error handling so we can tell if this was an actual verification failure or some other error\n    // Verification failed somehow\n    return false;\n  }\n}\nconst EIP_1271_MAGIC_VALUE = \"0x1626ba7e\";\nasync function verifyEip1271Signature({\n  hash,\n  signature,\n  contract\n}) {\n  const result = await isValidSignature({\n    hash,\n    signature,\n    contract\n  });\n  return result === EIP_1271_MAGIC_VALUE;\n}\n//# sourceMappingURL=verify-hash.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}