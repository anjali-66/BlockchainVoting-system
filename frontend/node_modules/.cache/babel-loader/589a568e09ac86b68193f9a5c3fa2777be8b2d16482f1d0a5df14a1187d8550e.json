{"ast":null,"code":"import * as Errors from './Errors.js';\nimport { getUrl } from './internal/errors.js';\nimport * as promise from './internal/promise.js';\nimport * as internal from './internal/rpcTransport.js';\n/**\n * Creates a HTTP JSON-RPC Transport from a URL.\n *\n * @example\n * ```ts twoslash\n * import { RpcTransport } from 'ox'\n *\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com')\n *\n * const blockNumber = await transport.request({ method: 'eth_blockNumber' })\n * // @log: '0x1a2b3c'\n * ```\n *\n * @param url - URL to perform the JSON-RPC requests to.\n * @param options - Transport options.\n * @returns HTTP JSON-RPC Transport.\n */\nexport function fromHttp(url, options = {}) {\n  return internal.create({\n    async request(body_, options_) {\n      const {\n        fetchFn = options.fetchFn ?? fetch,\n        fetchOptions: fetchOptions_ = options.fetchOptions,\n        timeout = options.timeout ?? 10_000\n      } = options_;\n      const body = JSON.stringify(body_);\n      const fetchOptions = typeof fetchOptions_ === 'function' ? await fetchOptions_(body_) : fetchOptions_;\n      const response = await promise.withTimeout(({\n        signal\n      }) => {\n        const init = {\n          ...fetchOptions,\n          body,\n          headers: {\n            'Content-Type': 'application/json',\n            ...fetchOptions?.headers\n          },\n          method: fetchOptions?.method ?? 'POST',\n          signal: fetchOptions?.signal ?? (timeout > 0 ? signal : null)\n        };\n        const request = new Request(url, init);\n        return fetchFn(request);\n      }, {\n        timeout,\n        signal: true\n      });\n      const data = await (async () => {\n        if (response.headers.get('Content-Type')?.startsWith('application/json')) return response.json();\n        return response.text().then(data => {\n          try {\n            return JSON.parse(data || '{}');\n          } catch (err) {\n            if (response.ok) throw new MalformedResponseError({\n              response: data\n            });\n            return {\n              error: data\n            };\n          }\n        });\n      })();\n      if (!response.ok) throw new HttpError({\n        body,\n        details: JSON.stringify(data.error) ?? response.statusText,\n        response,\n        url\n      });\n      return data;\n    }\n  }, {\n    raw: options.raw\n  });\n}\n/** Thrown when a HTTP request fails. */\nexport class HttpError extends Errors.BaseError {\n  constructor({\n    body,\n    details,\n    response,\n    url\n  }) {\n    super('HTTP request failed.', {\n      details,\n      metaMessages: [`Status: ${response.status}`, `URL: ${getUrl(url)}`, body ? `Body: ${JSON.stringify(body)}` : undefined]\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'RpcTransport.HttpError'\n    });\n  }\n}\n/** Thrown when a HTTP response is malformed. */\nexport class MalformedResponseError extends Errors.BaseError {\n  constructor({\n    response\n  }) {\n    super('HTTP Response could not be parsed as JSON.', {\n      metaMessages: [`Response: ${response}`]\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'RpcTransport.MalformedResponseError'\n    });\n  }\n}\n//# sourceMappingURL=RpcTransport.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}