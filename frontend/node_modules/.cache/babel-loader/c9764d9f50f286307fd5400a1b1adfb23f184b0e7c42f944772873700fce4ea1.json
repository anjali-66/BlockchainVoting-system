{"ast":null,"code":"import { getTypesForEIP712Domain, serializeTypedData, validateTypedData } from \"viem\";\nimport { trackTransaction } from \"../../analytics/track/transaction.js\";\nimport { getCachedChain, getChainMetadata } from \"../../chains/utils.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { numberToHex, stringToHex, uint8ArrayToHex } from \"../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parse-typed-data.js\";\nimport { getValidPublicRPCUrl } from \"../utils/chains.js\";\nimport { normalizeChainId } from \"../utils/normalizeChainId.js\";\nimport { injectedProvider } from \"./mipdStore.js\";\n// TODO: save the provider in data\nexport function getInjectedProvider(walletId) {\n  const provider = injectedProvider(walletId);\n  if (!provider) {\n    throw new Error(`No injected provider found for wallet: \"${walletId}\"`);\n  }\n  return provider;\n}\n/**\n * @internal\n */\nexport async function connectEip1193Wallet({\n  id,\n  provider,\n  emitter,\n  client,\n  chain\n}) {\n  let addresses;\n  const retries = 3;\n  let attempts = 0;\n  // retry 3 times, some providers take a while to return accounts on connect\n  while (!addresses?.[0] && attempts < retries) {\n    try {\n      addresses = await provider.request({\n        method: \"eth_requestAccounts\"\n      });\n    } catch (e) {\n      console.error(e);\n      await new Promise(resolve => setTimeout(resolve, 500));\n    }\n    attempts++;\n  }\n  const addr = addresses?.[0];\n  if (!addr) {\n    throw new Error(\"Failed to connect to wallet, no accounts available\");\n  }\n  // use the first account\n  const address = getAddress(addr);\n  // get the chainId the provider is on\n  const chainId = await provider.request({\n    method: \"eth_chainId\"\n  }).then(normalizeChainId);\n  let connectedChain = chain && chain.id === chainId ? chain : getCachedChain(chainId);\n  // if we want a specific chainId and it is not the same as the provider chainId, trigger switchChain\n  if (chain && chain.id !== chainId) {\n    await switchChain(provider, chain);\n    connectedChain = chain;\n  }\n  return onConnect({\n    provider,\n    address,\n    chain: connectedChain,\n    emitter,\n    client,\n    id\n  });\n}\n/**\n * @internal\n */\nexport async function autoConnectEip1193Wallet({\n  id,\n  provider,\n  emitter,\n  client,\n  chain\n}) {\n  // connected accounts\n  const addresses = await provider.request({\n    method: \"eth_accounts\"\n  });\n  const addr = addresses[0];\n  if (!addr) {\n    throw new Error(\"Failed to connect to wallet, no accounts available\");\n  }\n  // use the first account\n  const address = getAddress(addr);\n  // get the chainId the provider is on\n  const chainId = await provider.request({\n    method: \"eth_chainId\"\n  }).then(normalizeChainId);\n  const connectedChain = chain && chain.id === chainId ? chain : getCachedChain(chainId);\n  return onConnect({\n    provider,\n    address,\n    chain: connectedChain,\n    emitter,\n    client,\n    id\n  });\n}\nfunction createAccount({\n  provider,\n  address,\n  client,\n  id\n}) {\n  const account = {\n    address: getAddress(address),\n    async sendTransaction(tx) {\n      const gasFees = tx.gasPrice ? {\n        gasPrice: tx.gasPrice ? numberToHex(tx.gasPrice) : undefined\n      } : {\n        maxFeePerGas: tx.maxFeePerGas ? numberToHex(tx.maxFeePerGas) : undefined,\n        maxPriorityFeePerGas: tx.maxPriorityFeePerGas ? numberToHex(tx.maxPriorityFeePerGas) : undefined\n      };\n      const params = [{\n        ...gasFees,\n        nonce: tx.nonce ? numberToHex(tx.nonce) : undefined,\n        accessList: tx.accessList,\n        value: tx.value ? numberToHex(tx.value) : undefined,\n        gas: tx.gas ? numberToHex(tx.gas) : undefined,\n        from: this.address,\n        to: tx.to ? getAddress(tx.to) : undefined,\n        data: tx.data,\n        ...tx.eip712\n      }];\n      const transactionHash = await provider.request({\n        method: \"eth_sendTransaction\",\n        // @ts-expect-error - overriding types here\n        params\n      });\n      trackTransaction({\n        client,\n        chainId: tx.chainId,\n        walletAddress: getAddress(address),\n        walletType: id,\n        transactionHash,\n        contractAddress: tx.to ?? undefined,\n        gasPrice: tx.gasPrice\n      });\n      return {\n        transactionHash\n      };\n    },\n    async signMessage({\n      message\n    }) {\n      if (!account.address) {\n        throw new Error(\"Provider not setup\");\n      }\n      const messageToSign = (() => {\n        if (typeof message === \"string\") {\n          return stringToHex(message);\n        }\n        if (message.raw instanceof Uint8Array) {\n          return uint8ArrayToHex(message.raw);\n        }\n        return message.raw;\n      })();\n      return await provider.request({\n        method: \"personal_sign\",\n        params: [messageToSign, account.address]\n      });\n    },\n    async signTypedData(typedData) {\n      if (!provider || !account.address) {\n        throw new Error(\"Provider not setup\");\n      }\n      const parsedTypedData = parseTypedData(typedData);\n      const {\n        domain,\n        message,\n        primaryType\n      } = parsedTypedData;\n      const types = {\n        EIP712Domain: getTypesForEIP712Domain({\n          domain\n        }),\n        ...parsedTypedData.types\n      };\n      // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n      // as we can't statically check this with TypeScript.\n      validateTypedData({\n        domain,\n        message,\n        primaryType,\n        types\n      });\n      const stringifiedData = serializeTypedData({\n        domain: domain ?? {},\n        message,\n        primaryType,\n        types\n      });\n      return await provider.request({\n        method: \"eth_signTypedData_v4\",\n        params: [account.address, stringifiedData]\n      });\n    },\n    async watchAsset(asset) {\n      const result = await provider.request({\n        method: \"wallet_watchAsset\",\n        params: asset\n      }, {\n        retryCount: 0\n      });\n      return result;\n    }\n  };\n  return account;\n}\n/**\n * Call this method when the wallet provider is connected or auto connected\n * @internal\n */\nasync function onConnect({\n  provider,\n  address,\n  chain,\n  emitter,\n  client,\n  id\n}) {\n  const account = createAccount({\n    provider,\n    address,\n    client,\n    id\n  });\n  async function disconnect() {\n    provider.removeListener(\"accountsChanged\", onAccountsChanged);\n    provider.removeListener(\"chainChanged\", onChainChanged);\n    provider.removeListener(\"disconnect\", onDisconnect);\n  }\n  async function onDisconnect() {\n    disconnect();\n    emitter.emit(\"disconnect\", undefined);\n  }\n  function onAccountsChanged(accounts) {\n    if (accounts[0]) {\n      const newAccount = createAccount({\n        provider,\n        address: getAddress(accounts[0]),\n        client,\n        id\n      });\n      emitter.emit(\"accountChanged\", newAccount);\n      emitter.emit(\"accountsChanged\", accounts);\n    } else {\n      onDisconnect();\n    }\n  }\n  function onChainChanged(newChainId) {\n    const newChain = getCachedChain(normalizeChainId(newChainId));\n    emitter.emit(\"chainChanged\", newChain);\n  }\n  if (provider.on) {\n    provider.on(\"accountsChanged\", onAccountsChanged);\n    provider.on(\"chainChanged\", onChainChanged);\n    provider.on(\"disconnect\", onDisconnect);\n  }\n  return [account, chain, onDisconnect, newChain => switchChain(provider, newChain)];\n}\n/**\n * @internal\n */\nasync function switchChain(provider, chain) {\n  const hexChainId = numberToHex(chain.id);\n  try {\n    await provider.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{\n        chainId: hexChainId\n      }]\n    });\n  } catch {\n    // if chain does not exist, add the chain\n    const apiChain = await getChainMetadata(chain);\n    await provider.request({\n      method: \"wallet_addEthereumChain\",\n      params: [{\n        chainId: hexChainId,\n        chainName: apiChain.name,\n        nativeCurrency: apiChain.nativeCurrency,\n        rpcUrls: getValidPublicRPCUrl(apiChain),\n        // no client id on purpose here\n        blockExplorerUrls: apiChain.explorers?.map(x => x.url)\n      }]\n    });\n  }\n}\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}