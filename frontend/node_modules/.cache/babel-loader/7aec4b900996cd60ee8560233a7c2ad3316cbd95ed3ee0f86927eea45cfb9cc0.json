{"ast":null,"code":"import { useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport { useEffect, useMemo, useRef } from \"react\";\nimport { getContractEvents } from \"../../../../event/actions/get-events.js\";\nimport { watchContractEvents } from \"../../../../event/actions/watch-events.js\";\nimport { eth_blockNumber } from \"../../../../rpc/actions/eth_blockNumber.js\";\nimport { getRpcClient } from \"../../../../rpc/rpc.js\";\n/**\n * Watches contract events and returns the parsed logs.\n * @param options - The options for watching contract events.\n * @param options.contract - The contract to watch events for.\n * @param options.events - The events to watch. Shuould be an array of [prepared events](https://portal.thirdweb.com/references/typescript/v5/prepareEvent).\n * @param options.blockRange - The number of blocks to search for events.\n * @param options.enabled - Whether to enable the query.\n * @param options.watch - Whether to watch for new events.\n * @returns The contract events of the watched contract events.\n * @example\n *\n * ### Using event extensions\n *\n * The `thirdweb/extesions` export contains event definitions for many popular contracts.\n * You can use these event definitions to watch for specific events with a type-safe API.\n *\n * ```jsx\n * import { useContractEvents } from \"thirdweb/react\";\n * import { tokensClaimedEvent } from \"thirdweb/extensions/erc721\";\n *\n * const account = useActiveAccount();\n * const contractEvents = useContractEvents({\n *  contract,\n *  events: [tokensClaimedEvent({ claimer: account?.address })],\n * });\n * ```\n *\n * ### Using custom events\n *\n * You can also watch for custom events by passing an array of [prepared events](https://portal.thirdweb.com/references/typescript/v5/prepareEvent).\n *\n * ```jsx\n * import { useContractEvents } from \"thirdweb/react\";\n * import { prepareEvent } from \"thirdweb\";\n *\n * const myEvent = prepareEvent({\n *  signature: \"event MyEvent(uint256 myArg)\",\n * });\n *\n * const contractEvents = useContractEvents({\n *  contract,\n *  events: [myEvent],\n * });\n * ```\n *\n * @contract\n */\nexport function useContractEvents(options) {\n  const {\n    contract,\n    events,\n    blockRange = 2000,\n    enabled = true,\n    watch = true\n  } = options;\n  const latestBlockNumber = useRef(undefined); // We use this to keep track of the latest block number when new pollers are spawned\n  const queryClient = useQueryClient();\n  const eventsKey = useMemo(() => events?.reduce((acc, curr) => {\n    // we can use the event hash as a unique identifier?\n    return `${acc}${curr.hash}_`;\n  }, \"\") || \"__all__\", [events]);\n  const queryKey = useMemo(() => [contract.chain.id, contract.address, \"logs\", eventsKey], [contract.address, contract.chain, eventsKey]);\n  const query = useQuery({\n    queryKey,\n    queryFn: async () => {\n      const rpcRequest = getRpcClient(contract);\n      const currentBlockNumber = await eth_blockNumber(rpcRequest);\n      latestBlockNumber.current = currentBlockNumber;\n      const initialEvents = await getContractEvents({\n        contract,\n        events: events,\n        fromBlock: currentBlockNumber - BigInt(blockRange)\n      });\n      return initialEvents;\n    },\n    enabled\n  });\n  useEffect(() => {\n    if (!enabled || !watch) {\n      // don't watch if not enabled or if watch is false\n      return;\n    }\n    // the return is important here because it will unwatch the events\n    return watchContractEvents({\n      contract,\n      onEvents: newEvents => {\n        if (newEvents.length > 0 && newEvents[0]) {\n          latestBlockNumber.current = newEvents[0].blockNumber; // Update the latest block number to avoid duplicate events if a new poller is spawned during this block\n        }\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n        queryClient.setQueryData(queryKey, (oldEvents = []) => [...oldEvents, ...newEvents]);\n      },\n      events,\n      latestBlockNumber: latestBlockNumber.current\n    });\n  }, [contract, enabled, events, queryClient, queryKey, watch]);\n  return query;\n}\n//# sourceMappingURL=useContractEvents.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}