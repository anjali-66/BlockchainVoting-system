{"ast":null,"code":"import { hexToBytes, toRlp } from \"viem\";\nimport { eth_sendRawTransaction } from \"../../../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../../../rpc/rpc.js\";\nimport { getAddress } from \"../../../utils/address.js\";\nimport { replaceBigInts, toBigInt } from \"../../../utils/bigint.js\";\nimport { concatHex } from \"../../../utils/encoding/helpers/concat-hex.js\";\nimport { toHex } from \"../../../utils/encoding/hex.js\";\nimport { resolvePromisedValue } from \"../../../utils/promise/resolve-promised-value.js\";\nimport { encode } from \"../encode.js\";\nimport { toSerializableTransaction } from \"../to-serializable-transaction.js\";\nimport { gasPerPubdataDefault, getEip712Domain } from \"./getEip721Domain.js\";\n/**\n * Sends a transaction using the provided wallet.\n * @param options - The options for sending the transaction.\n * @returns A promise that resolves to the transaction hash.\n * @throws An error if the wallet is not connected.\n * @transaction\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n *\n * const { transactionHash } = await sendTransaction({\n *  account,\n *  transaction\n * });\n * ```\n */\nexport async function sendEip712Transaction(options) {\n  const {\n    account,\n    transaction\n  } = options;\n  const eip712Transaction = await populateEip712Transaction(options);\n  const hash = await signEip712Transaction({\n    account,\n    eip712Transaction,\n    chainId: transaction.chain.id\n  });\n  const rpc = getRpcClient(transaction);\n  const result = await eth_sendRawTransaction(rpc, hash);\n  return {\n    transactionHash: result,\n    chain: transaction.chain,\n    client: transaction.client\n  };\n}\nexport async function signEip712Transaction(options) {\n  const {\n    account,\n    eip712Transaction,\n    chainId\n  } = options;\n  // EIP712 signing of the serialized tx\n  const eip712Domain = getEip712Domain(eip712Transaction);\n  const customSignature = await account.signTypedData({\n    // biome-ignore lint/suspicious/noExplicitAny: TODO type properly\n    ...eip712Domain\n  });\n  return serializeTransactionEIP712({\n    ...eip712Transaction,\n    chainId,\n    customSignature\n  });\n}\n/**\n * Populate a prepared transaction to be serialized as a EIP712 transaction\n * @param options\n * @internal\n */\nexport async function populateEip712Transaction(options) {\n  const {\n    account,\n    transaction\n  } = options;\n  const {\n    gas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    gasPerPubdata\n  } = await getZkGasFees({\n    transaction,\n    from: getAddress(account.address)\n  });\n  // serialize the transaction (with fees, gas, nonce)\n  const serializableTransaction = await toSerializableTransaction({\n    transaction: {\n      ...transaction,\n      gas,\n      maxFeePerGas,\n      maxPriorityFeePerGas\n    },\n    from: account.address\n  });\n  return {\n    ...serializableTransaction,\n    ...transaction.eip712,\n    gasPerPubdata,\n    from: account.address\n  };\n}\nfunction serializeTransactionEIP712(transaction) {\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    from,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    customSignature,\n    factoryDeps,\n    paymaster,\n    paymasterInput,\n    gasPerPubdata,\n    data\n  } = transaction;\n  const serializedTransaction = [nonce ? toHex(nonce) : \"0x\", maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : \"0x\", maxFeePerGas ? toHex(maxFeePerGas) : \"0x\", gas ? toHex(gas) : \"0x\", to ?? \"0x\", value ? toHex(value) : \"0x\", data ?? \"0x0\", toHex(chainId), toHex(\"\"), toHex(\"\"), toHex(chainId), from ?? \"0x\", gasPerPubdata ? toHex(gasPerPubdata) : toHex(gasPerPubdataDefault), factoryDeps ?? [], customSignature ?? \"0x\",\n  // EIP712 signature\n  paymaster && paymasterInput ? [paymaster, paymasterInput] : []];\n  // @ts-ignore - TODO: fix types\n  return concatHex([\"0x71\", toRlp(serializedTransaction)]);\n}\nexport async function getZkGasFees(args) {\n  const {\n    transaction,\n    from\n  } = args;\n  let [gas, maxFeePerGas, maxPriorityFeePerGas, eip712] = await Promise.all([resolvePromisedValue(transaction.gas), resolvePromisedValue(transaction.maxFeePerGas), resolvePromisedValue(transaction.maxPriorityFeePerGas), resolvePromisedValue(transaction.eip712)]);\n  let gasPerPubdata = eip712?.gasPerPubdata;\n  if (gas === undefined || maxFeePerGas === undefined || maxPriorityFeePerGas === undefined) {\n    const rpc = getRpcClient(transaction);\n    const params = await formatTransaction({\n      transaction,\n      from\n    });\n    const result = await rpc({\n      // biome-ignore lint/suspicious/noExplicitAny: TODO add to RPC method types\n      method: \"zks_estimateFee\",\n      // biome-ignore lint/suspicious/noExplicitAny: TODO add to RPC method types\n      params: [replaceBigInts(params, toHex)]\n    });\n    gas = toBigInt(result.gas_limit) * 2n; // overestimating to avoid issues when not accounting for paymaster extra gas ( we should really pass the paymaster input above for better accuracy )\n    const baseFee = toBigInt(result.max_fee_per_gas);\n    maxFeePerGas = baseFee * 2n; // bumping the base fee per gas to ensure fast inclusion\n    maxPriorityFeePerGas = toBigInt(result.max_priority_fee_per_gas) || 1n;\n    gasPerPubdata = toBigInt(result.gas_per_pubdata_limit) * 2n; // doubling for fast inclusion;\n    if (gasPerPubdata < 50000n) {\n      // enforce a minimum gas per pubdata limit\n      gasPerPubdata = 50000n;\n    }\n  }\n  return {\n    gas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    gasPerPubdata\n  };\n}\nasync function formatTransaction(args) {\n  const {\n    transaction,\n    from\n  } = args;\n  const [data, to, value, eip712] = await Promise.all([encode(transaction), resolvePromisedValue(transaction.to), resolvePromisedValue(transaction.value), resolvePromisedValue(transaction.eip712)]);\n  const gasPerPubdata = eip712?.gasPerPubdata;\n  return {\n    from,\n    to,\n    data,\n    value,\n    gasPerPubdata,\n    eip712Meta: {\n      ...eip712,\n      gasPerPubdata: gasPerPubdata || 50000n,\n      factoryDeps: eip712?.factoryDeps?.map(dep => Array.from(hexToBytes(dep)))\n    },\n    type: \"0x71\"\n  };\n}\n//# sourceMappingURL=send-eip712-transaction.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}