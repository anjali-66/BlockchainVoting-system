{"ast":null,"code":"import * as ox__Hex from \"ox/Hex\";\nimport * as ox__TypedData from \"ox/TypedData\";\nimport { getValidPublicRPCUrl } from \"../utils/chains.js\";\nimport { normalizeChainId } from \"../utils/normalizeChainId.js\";\nimport { trackTransaction } from \"../../analytics/track/transaction.js\";\nimport { getCachedChain, getChainMetadata } from \"../../chains/utils.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { numberToHex, stringToHex, uint8ArrayToHex } from \"../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parse-typed-data.js\";\nimport { COINBASE } from \"../constants.js\";\nimport { getDefaultAppMetadata } from \"../utils/defaultDappMetadata.js\";\nimport { showCoinbasePopup } from \"./utils.js\";\n// Need to keep the provider around because it keeps a single popup window connection behind the scenes\n// this should be ok since all the creation options are provided at build time\nlet _provider;\n/**\n * @internal\n */\nexport async function getCoinbaseWebProvider(options) {\n  if (!_provider) {\n    let CoinbaseWalletSDK = (await import(\"@coinbase/wallet-sdk\")).default;\n    // Workaround for Vite dev import errors\n    // https://github.com/vitejs/vite/issues/7112\n    if (typeof CoinbaseWalletSDK !== \"function\" && typeof CoinbaseWalletSDK.default === \"function\") {\n      CoinbaseWalletSDK = CoinbaseWalletSDK.default;\n    }\n    // @ts-expect-error This import error is not visible to TypeScript\n    const client = new CoinbaseWalletSDK({\n      appName: options?.appMetadata?.name || getDefaultAppMetadata().name,\n      appChainIds: options?.chains ? options.chains.map(c => c.id) : undefined,\n      appLogoUrl: options?.appMetadata?.logoUrl || getDefaultAppMetadata().logoUrl\n    });\n    const provider = client.makeWeb3Provider(options?.walletConfig);\n    _provider = provider;\n    return provider;\n  }\n  return _provider;\n}\n/**\n * Checks if the provided wallet is a Coinbase SDK wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is a Coinbase SDK wallet, false otherwise.\n */\nexport function isCoinbaseSDKWallet(wallet) {\n  return wallet.id === COINBASE;\n}\n/**\n * @internal\n */\nexport async function coinbaseSDKWalletGetCapabilities(args) {\n  const {\n    wallet\n  } = args;\n  const account = wallet.getAccount();\n  if (!account) {\n    return {\n      message: `Can't get capabilities, no account connected for wallet: ${wallet.id}`\n    };\n  }\n  const config = wallet.getConfig();\n  const provider = await getCoinbaseWebProvider(config);\n  try {\n    return await provider.request({\n      method: \"wallet_getCapabilities\",\n      params: [account.address]\n    });\n  } catch (error) {\n    if (/unsupport|not support/i.test(error.message)) {\n      return {\n        message: `${wallet.id} does not support wallet_getCapabilities, reach out to them directly to request EIP-5792 support.`\n      };\n    }\n    throw error;\n  }\n}\n/**\n * @internal\n */\nexport async function coinbaseSDKWalletSendCalls(args) {\n  const {\n    wallet,\n    params\n  } = args;\n  const config = wallet.getConfig();\n  const provider = await getCoinbaseWebProvider(config);\n  try {\n    return await provider.request({\n      method: \"wallet_sendCalls\",\n      params\n    });\n  } catch (error) {\n    if (/unsupport|not support/i.test(error.message)) {\n      throw new Error(`${wallet.id} does not support wallet_sendCalls, reach out to them directly to request EIP-5792 support.`);\n    }\n    throw error;\n  }\n}\n/**\n * @internal\n */\nexport async function coinbaseSDKWalletShowCallsStatus(args) {\n  const {\n    wallet,\n    bundleId\n  } = args;\n  const provider = await getCoinbaseWebProvider(wallet.getConfig());\n  try {\n    return await provider.request({\n      method: \"wallet_showCallsStatus\",\n      params: [bundleId]\n    });\n  } catch (error) {\n    if (/unsupport|not support/i.test(error.message)) {\n      throw new Error(`${wallet.id} does not support wallet_showCallsStatus, reach out to them directly to request EIP-5792 support.`);\n    }\n    throw error;\n  }\n}\n/**\n * @internal\n */\nexport async function coinbaseSDKWalletGetCallsStatus(args) {\n  const {\n    wallet,\n    bundleId\n  } = args;\n  const config = wallet.getConfig();\n  const provider = await getCoinbaseWebProvider(config);\n  return provider.request({\n    method: \"wallet_getCallsStatus\",\n    params: [bundleId]\n  });\n}\nfunction createAccount({\n  provider,\n  address,\n  client\n}) {\n  const account = {\n    address,\n    async sendTransaction(tx) {\n      const transactionHash = await provider.request({\n        method: \"eth_sendTransaction\",\n        params: [{\n          accessList: tx.accessList,\n          value: tx.value ? numberToHex(tx.value) : undefined,\n          gas: tx.gas ? numberToHex(tx.gas) : undefined,\n          from: getAddress(address),\n          to: tx.to,\n          data: tx.data\n        }]\n      });\n      trackTransaction({\n        client: client,\n        chainId: tx.chainId,\n        walletAddress: getAddress(address),\n        walletType: COINBASE,\n        transactionHash,\n        contractAddress: tx.to ?? undefined,\n        gasPrice: tx.gasPrice\n      });\n      return {\n        transactionHash\n      };\n    },\n    async signMessage({\n      message\n    }) {\n      if (!account.address) {\n        throw new Error(\"Provider not setup\");\n      }\n      const messageToSign = (() => {\n        if (typeof message === \"string\") {\n          return stringToHex(message);\n        }\n        if (message.raw instanceof Uint8Array) {\n          return uint8ArrayToHex(message.raw);\n        }\n        return message.raw;\n      })();\n      const res = await provider.request({\n        method: \"personal_sign\",\n        params: [messageToSign, account.address]\n      });\n      if (!ox__Hex.validate(res)) {\n        throw new Error(\"Invalid signature returned\");\n      }\n      return res;\n    },\n    async signTypedData(typedData) {\n      if (!account.address) {\n        throw new Error(\"Provider not setup\");\n      }\n      const {\n        domain,\n        message,\n        primaryType\n      } = parseTypedData(typedData);\n      const types = {\n        EIP712Domain: ox__TypedData.extractEip712DomainTypes(domain),\n        ...typedData.types\n      };\n      // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n      // as we can't statically check this with TypeScript.\n      ox__TypedData.validate({\n        domain,\n        message,\n        primaryType,\n        types\n      });\n      const stringifiedData = ox__TypedData.serialize({\n        domain: domain ?? {},\n        message,\n        primaryType,\n        types\n      });\n      const res = await provider.request({\n        method: \"eth_signTypedData_v4\",\n        params: [account.address, stringifiedData]\n      });\n      if (!ox__Hex.validate(res)) {\n        throw new Error(\"Invalid signed payload returned\");\n      }\n      return res;\n    },\n    onTransactionRequested: async () => {\n      // make sure to show the coinbase popup BEFORE doing any transaction preprocessing\n      // otherwise the popup might get blocked in safari\n      await showCoinbasePopup(provider);\n    }\n  };\n  return account;\n}\nfunction onConnect(address, chain, provider, emitter, client) {\n  const account = createAccount({\n    provider,\n    address,\n    client\n  });\n  async function disconnect() {\n    provider.removeListener(\"accountsChanged\", onAccountsChanged);\n    provider.removeListener(\"chainChanged\", onChainChanged);\n    provider.removeListener(\"disconnect\", onDisconnect);\n    await provider.disconnect();\n  }\n  async function onDisconnect() {\n    disconnect();\n    emitter.emit(\"disconnect\", undefined);\n  }\n  function onAccountsChanged(accounts) {\n    if (accounts[0]) {\n      const newAccount = createAccount({\n        provider,\n        address: getAddress(accounts[0]),\n        client\n      });\n      emitter.emit(\"accountChanged\", newAccount);\n      emitter.emit(\"accountsChanged\", accounts);\n    } else {\n      onDisconnect();\n    }\n  }\n  function onChainChanged(newChainId) {\n    const newChain = getCachedChain(normalizeChainId(newChainId));\n    emitter.emit(\"chainChanged\", newChain);\n  }\n  // subscribe to events\n  provider.on(\"accountsChanged\", onAccountsChanged);\n  provider.on(\"chainChanged\", onChainChanged);\n  provider.on(\"disconnect\", onDisconnect);\n  return [account, chain, onDisconnect, newChain => switchChainCoinbaseWalletSDK(provider, newChain)];\n}\n/**\n * @internal\n */\nexport async function connectCoinbaseWalletSDK(options, emitter, provider) {\n  const accounts = await provider.request({\n    method: \"eth_requestAccounts\"\n  });\n  if (!accounts[0]) {\n    throw new Error(\"No accounts found\");\n  }\n  const address = getAddress(accounts[0]);\n  const connectedChainId = await provider.request({\n    method: \"eth_chainId\"\n  });\n  const chainId = normalizeChainId(connectedChainId);\n  let chain = options.chain && options.chain.id === chainId ? options.chain : getCachedChain(chainId);\n  // Switch to chain if provided\n  if (chainId && options?.chain && chainId !== options?.chain.id) {\n    await switchChainCoinbaseWalletSDK(provider, options.chain);\n    chain = options.chain;\n  }\n  return onConnect(address, chain, provider, emitter, options.client);\n}\n/**\n * @internal\n */\nexport async function autoConnectCoinbaseWalletSDK(options, emitter, provider) {\n  // connected accounts\n  const addresses = await provider.request({\n    method: \"eth_accounts\"\n  });\n  const address = addresses[0];\n  if (!address) {\n    throw new Error(\"No accounts found\");\n  }\n  const connectedChainId = await provider.request({\n    method: \"eth_chainId\"\n  });\n  const chainId = normalizeChainId(connectedChainId);\n  const chain = options.chain && options.chain.id === chainId ? options.chain : getCachedChain(chainId);\n  return onConnect(address, chain, provider, emitter, options.client);\n}\nasync function switchChainCoinbaseWalletSDK(provider, chain) {\n  const chainIdHex = numberToHex(chain.id);\n  try {\n    await provider.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{\n        chainId: chainIdHex\n      }]\n    });\n  } catch (error) {\n    const apiChain = await getChainMetadata(chain);\n    // Indicates chain is not added to provider\n    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n    if (error?.code === 4902) {\n      // try to add the chain\n      await provider.request({\n        method: \"wallet_addEthereumChain\",\n        params: [{\n          chainId: chainIdHex,\n          chainName: apiChain.name,\n          nativeCurrency: apiChain.nativeCurrency,\n          rpcUrls: getValidPublicRPCUrl(apiChain),\n          // no client id on purpose here\n          blockExplorerUrls: apiChain.explorers?.map(x => x.url) || []\n        }]\n      });\n    }\n  }\n}\n//# sourceMappingURL=coinbase-web.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}