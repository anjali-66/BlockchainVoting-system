{"ast":null,"code":"const DEFAULT_GATEWAY = \"https://{clientId}.ipfscdn.io/ipfs/{cid}\";\n/**\n * Resolves the scheme of a given URI and returns the corresponding URL.\n * If the URI starts with \"ipfs://\", it constructs a URL using the IPFS client ID and the IPFS gateway.\n * If the URI starts with \"http\", it returns the URI as is.\n * Otherwise, it throws an error indicating an invalid URI scheme.\n * @param options - The options object containing the URI and the IPFS client.\n * @returns The resolved URL.\n * @throws Error if the URI scheme is invalid.\n * @example\n * ```ts\n * import { resolveScheme } from \"thirdweb/storage\";\n * const url = resolveScheme({\n *  client,\n *  uri: \"ipfs://Qm...\",\n * });\n * ```\n * @storage\n */\nexport function resolveScheme(options) {\n  if (options.uri.startsWith(\"ipfs://\")) {\n    const gateway = options.client.config?.storage?.gatewayUrl ?? DEFAULT_GATEWAY;\n    const clientId = options.client.clientId;\n    const cid = findIPFSCidFromUri(options.uri);\n    let bundleId = undefined;\n    if (typeof globalThis !== \"undefined\" && \"Application\" in globalThis) {\n      // shims use wallet connect RN module which injects Application info in globalThis\n      // biome-ignore lint/suspicious/noExplicitAny: get around globalThis typing\n      bundleId = globalThis.Application.applicationId;\n    }\n    // purposefully using SPLIT here and not replace for CID to avoid cases where users don't know the schema\n    // also only splitting on `/ipfs` to avoid cases where people pass non `/` terminated gateway urls\n    return `${gateway.replace(\"{clientId}\", clientId).split(\"/ipfs\")[0]}/ipfs/${cid}${bundleId ? `?bundleId=${bundleId}` : \"\"}`;\n  }\n  if (options.uri.startsWith(\"http\")) {\n    return options.uri;\n  }\n  throw new Error(`Invalid URI scheme, expected \"ipfs://\" or \"http(s)://\"`);\n}\n/**\n * @internal\n */\nexport function findIPFSCidFromUri(uri) {\n  if (!uri.startsWith(\"ipfs://\")) {\n    // do not touch URIs that are not ipfs URIs\n    return uri;\n  }\n  // first index of `/Qm` or `/bafy` in the uri (case insensitive)\n  const firstIndex = uri.search(/\\/(Qm|baf)/i);\n  // we start one character after the first `/` to avoid including it in the CID\n  return uri.slice(firstIndex + 1);\n}\n/**\n * Uploads or extracts URIs from the given files.\n * @template T - The type of the files (File, Buffer, String).\n * @param files - The files to upload or extract URIs from.\n * @param client - The Thirdweb client.\n * @param [startNumber] - The starting number for rewriting file names.\n * @returns - A promise that resolves to an array of URIs.\n * @throws {Error} - If the files are not all of the same type (all URI or all FileOrBufferOrString).\n * @internal\n *\n */\nexport async function uploadOrExtractURIs(files, client, startNumber) {\n  if (isUriList(files)) {\n    return files;\n  }\n  if (isMetadataList(files)) {\n    const {\n      upload\n    } = await import(\"../storage/upload.js\");\n    const uris = await upload({\n      client,\n      files,\n      rewriteFileNames: {\n        fileStartNumber: startNumber || 0\n      }\n    });\n    return Array.isArray(uris) ? uris : [uris];\n  }\n  throw new Error(\"Files must all be of the same type (all URI or all FileOrBufferOrString)\");\n}\n/**\n * Retrieves the base URI from a batch of URIs.\n *\n * @param uris - An array of URIs.\n * @returns The base URI shared by all URIs in the batch.\n * @throws If the batch contains URIs with different base URIs or if no base URI is found.\n * @internal\n */\nexport function getBaseUriFromBatch(uris) {\n  // biome-ignore lint/style/noParameterAssign: lemme do my stuff\n  uris = Array.isArray(uris) ? uris : [uris];\n  const [base, ...rest] = uris.map(uri => {\n    // remove query parameters\n    // biome-ignore lint/style/noParameterAssign: lemme do my stuff\n    [uri] = uri.split(\"?\");\n    // remove fragments\n    // biome-ignore lint/style/noParameterAssign: lemme do my stuff\n    [uri] = uri.split(\"#\");\n    // if the URI ends with a `/`, remove it\n    if (uri.endsWith(\"/\")) {\n      // biome-ignore lint/style/noParameterAssign: lemme do my stuff\n      uri = uri.slice(0, -1);\n    }\n    // remove the last part of the URI & add the trailing `/`\n    return `${uri.split(\"/\").slice(0, -1).join(\"/\")}/`;\n  });\n  if (!base) {\n    throw new Error(\"Batch of URIs is empty\");\n  }\n  if (rest.some(uri => uri !== base)) {\n    throw new Error(\"All URIs in the batch must have the same base URI\");\n  }\n  return base;\n}\nfunction isUriList(metadatas) {\n  return metadatas.every(m => typeof m === \"string\");\n}\nfunction isMetadataList(metadatas) {\n  return metadatas.every(m => typeof m !== \"string\");\n}\n//# sourceMappingURL=ipfs.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}