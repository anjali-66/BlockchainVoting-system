{"ast":null,"code":"import { concat, slice } from \"viem/utils\";\nimport { isAddress } from \"../address.js\";\nimport { byteSize } from \"../encoding/helpers/byte-size.js\";\nimport { boolToHex, numberToHex, padHex, stringToHex } from \"../encoding/hex.js\";\n/**\n * Encodes the given ABI parameters and values into a hexadecimal string.\n * @template TParams - The type of the ABI parameters.\n * @param params - The ABI parameters.\n * @param values - The corresponding values for the ABI parameters.\n * @returns - The encoded ABI parameters as a hexadecimal string.\n * @throws {Error} - If the number of parameters and values do not match.\n * @example\n * ```ts\n * import { encodeAbiParameters } from \"viem\";\n *\n * const params = [\n *  { name: \"param1\", type: \"uint256\" },\n *  { name: \"param2\", type: \"string\" },\n * ];\n * const values = [123, \"hello\"];\n *\n * const data = encodeAbiParameters(params, values);\n * console.log(data);\n * ```\n * @utils\n */\nexport function encodeAbiParameters(params, values) {\n  if (params.length !== values.length) {\n    throw new Error(\"The number of parameters and values must match.\");\n  }\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParams = prepareParams({\n    params: params,\n    values\n  });\n  const data = encodeParams(preparedParams);\n  if (data.length === 0) {\n    return \"0x\";\n  }\n  return data;\n}\nfunction prepareParams({\n  params,\n  values\n}) {\n  const preparedParams = [];\n  for (let i = 0; i < params.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    preparedParams.push(prepareParam({\n      param: params[i],\n      value: values[i]\n    }));\n  }\n  return preparedParams;\n}\n/**\n * @internal Export for unit test\n */\nexport function prepareParam({\n  param,\n  value\n}) {\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return encodeArray(value, {\n      length,\n      param: {\n        ...param,\n        type\n      }\n    });\n  }\n  if (param.type === \"tuple\") {\n    return encodeTuple(value, {\n      param: param\n    });\n  }\n  if (param.type === \"address\") {\n    return encodeAddress(value);\n  }\n  if (param.type === \"bool\") {\n    return encodeBool(value);\n  }\n  if (param.type.startsWith(\"uint\") || param.type.startsWith(\"int\")) {\n    const signed = param.type.startsWith(\"int\");\n    return encodeNumber(value, {\n      signed\n    });\n  }\n  if (param.type.startsWith(\"bytes\")) {\n    return encodeBytes(value, {\n      param\n    });\n  }\n  if (param.type === \"string\") {\n    return encodeString(value);\n  }\n  throw new Error(`Unsupported parameter type: ${param.type}`);\n}\nfunction encodeParams(preparedParams) {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0;\n  for (let i = 0; i < preparedParams.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    const {\n      dynamic,\n      encoded\n    } = preparedParams[i];\n    if (dynamic) {\n      staticSize += 32;\n    } else {\n      staticSize += byteSize(encoded);\n    }\n  }\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParams = [];\n  const dynamicParams = [];\n  let dynamicSize = 0;\n  for (let i = 0; i < preparedParams.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    const {\n      dynamic,\n      encoded\n    } = preparedParams[i];\n    if (dynamic) {\n      staticParams.push(numberToHex(staticSize + dynamicSize, {\n        size: 32\n      }));\n      dynamicParams.push(encoded);\n      dynamicSize += byteSize(encoded);\n    } else {\n      staticParams.push(encoded);\n    }\n  }\n  // 3. Concatenate static and dynamic parts.\n  return concat([...staticParams, ...dynamicParams]);\n}\n/////////////////////////////////////////////////////////////////\n/**\n * @internal Export for unit test\n */\nexport function encodeAddress(value) {\n  // We allow empty strings for deployment transactions where there is no to address\n  if (value !== \"\" && value !== undefined && !isAddress(value)) {\n    throw new Error(`Invalid address: ${value}`);\n  }\n  return {\n    dynamic: false,\n    encoded: padHex(value.toLowerCase())\n  };\n}\nfunction encodeArray(value, {\n  length,\n  param\n}) {\n  const dynamic = length === null;\n  if (!Array.isArray(value)) {\n    throw new Error(\"Invalid array value.\");\n  }\n  if (!dynamic && value.length !== length) {\n    throw new Error(\"Invalid array length.\");\n  }\n  let dynamicChild = false;\n  const preparedParams = [];\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParam({\n      param,\n      value: value[i]\n    });\n    if (preparedParam.dynamic) {\n      dynamicChild = true;\n    }\n    preparedParams.push(preparedParam);\n  }\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams);\n    if (dynamic) {\n      const length_ = numberToHex(preparedParams.length, {\n        size: 32\n      });\n      return {\n        dynamic: true,\n        encoded: preparedParams.length > 0 ? concat([length_, data]) : length_\n      };\n    }\n    if (dynamicChild) {\n      return {\n        dynamic: true,\n        encoded: data\n      };\n    }\n  }\n  return {\n    dynamic: false,\n    encoded: concat(preparedParams.map(({\n      encoded\n    }) => encoded))\n  };\n}\nfunction encodeBytes(value, {\n  param\n}) {\n  const [, paramSize] = param.type.split(\"bytes\");\n  const bytesSize = byteSize(value);\n  if (!paramSize) {\n    let value_ = value;\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0) {\n      value_ = padHex(value_, {\n        dir: \"right\",\n        size: Math.ceil((value.length - 2) / 2 / 32) * 32\n      });\n    }\n    return {\n      dynamic: true,\n      encoded: concat([padHex(numberToHex(bytesSize, {\n        size: 32\n      })), value_])\n    };\n  }\n  if (bytesSize !== Number.parseInt(paramSize)) {\n    throw new Error(`Invalid bytes${paramSize} size: ${bytesSize}`);\n  }\n  return {\n    dynamic: false,\n    encoded: padHex(value, {\n      dir: \"right\"\n    })\n  };\n}\nfunction encodeBool(value) {\n  return {\n    dynamic: false,\n    encoded: padHex(boolToHex(value))\n  };\n}\nfunction encodeNumber(value, {\n  signed\n}) {\n  return {\n    dynamic: false,\n    encoded: numberToHex(value, {\n      size: 32,\n      signed\n    })\n  };\n}\nfunction encodeString(value) {\n  const hexValue = stringToHex(value);\n  const partsLength = Math.ceil(byteSize(hexValue) / 32);\n  const parts = [];\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(padHex(slice(hexValue, i * 32, (i + 1) * 32), {\n      dir: \"right\"\n    }));\n  }\n  return {\n    dynamic: true,\n    encoded: concat([padHex(numberToHex(byteSize(hexValue), {\n      size: 32\n    })), ...parts])\n  };\n}\nfunction encodeTuple(value, {\n  param\n}) {\n  let dynamic = false;\n  const preparedParams = [];\n  for (let i = 0; i < param.components.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    const param_ = param.components[i];\n    const index = Array.isArray(value) ? i : param_.name;\n    const preparedParam = prepareParam({\n      param: param_,\n      // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      value: value[index]\n    });\n    preparedParams.push(preparedParam);\n    if (preparedParam.dynamic) {\n      dynamic = true;\n    }\n  }\n  return {\n    dynamic,\n    encoded: dynamic ? encodeParams(preparedParams) : concat(preparedParams.map(({\n      encoded\n    }) => encoded))\n  };\n}\nfunction getArrayComponents(type) {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n  return matches ?\n  // Return `null` if the array is dynamic.\n  // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n  [matches[2] ? Number(matches[2]) : null, matches[1]] : undefined;\n}\n//# sourceMappingURL=encodeAbiParameters.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}