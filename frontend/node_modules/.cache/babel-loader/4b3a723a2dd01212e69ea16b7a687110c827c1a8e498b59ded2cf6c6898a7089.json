{"ast":null,"code":"import { standardErrorCodes } from './constants.js';\nimport { getMessageFromCode } from './utils.js';\nexport const standardErrors = {\n  rpc: {\n    parse: arg => getEthJsonRpcError(standardErrorCodes.rpc.parse, arg),\n    invalidRequest: arg => getEthJsonRpcError(standardErrorCodes.rpc.invalidRequest, arg),\n    invalidParams: arg => getEthJsonRpcError(standardErrorCodes.rpc.invalidParams, arg),\n    methodNotFound: arg => getEthJsonRpcError(standardErrorCodes.rpc.methodNotFound, arg),\n    internal: arg => getEthJsonRpcError(standardErrorCodes.rpc.internal, arg),\n    server: opts => {\n      if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {\n        throw new Error('Ethereum RPC Server errors must provide single object argument.');\n      }\n      const {\n        code\n      } = opts;\n      if (!Number.isInteger(code) || code > -32005 || code < -32099) {\n        throw new Error('\"code\" must be an integer such that: -32099 <= code <= -32005');\n      }\n      return getEthJsonRpcError(code, opts);\n    },\n    invalidInput: arg => getEthJsonRpcError(standardErrorCodes.rpc.invalidInput, arg),\n    resourceNotFound: arg => getEthJsonRpcError(standardErrorCodes.rpc.resourceNotFound, arg),\n    resourceUnavailable: arg => getEthJsonRpcError(standardErrorCodes.rpc.resourceUnavailable, arg),\n    transactionRejected: arg => getEthJsonRpcError(standardErrorCodes.rpc.transactionRejected, arg),\n    methodNotSupported: arg => getEthJsonRpcError(standardErrorCodes.rpc.methodNotSupported, arg),\n    limitExceeded: arg => getEthJsonRpcError(standardErrorCodes.rpc.limitExceeded, arg)\n  },\n  provider: {\n    userRejectedRequest: arg => {\n      return getEthProviderError(standardErrorCodes.provider.userRejectedRequest, arg);\n    },\n    unauthorized: arg => {\n      return getEthProviderError(standardErrorCodes.provider.unauthorized, arg);\n    },\n    unsupportedMethod: arg => {\n      return getEthProviderError(standardErrorCodes.provider.unsupportedMethod, arg);\n    },\n    disconnected: arg => {\n      return getEthProviderError(standardErrorCodes.provider.disconnected, arg);\n    },\n    chainDisconnected: arg => {\n      return getEthProviderError(standardErrorCodes.provider.chainDisconnected, arg);\n    },\n    unsupportedChain: arg => {\n      return getEthProviderError(standardErrorCodes.provider.unsupportedChain, arg);\n    },\n    custom: opts => {\n      if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {\n        throw new Error('Ethereum Provider custom errors must provide single object argument.');\n      }\n      const {\n        code,\n        message,\n        data\n      } = opts;\n      if (!message || typeof message !== 'string') {\n        throw new Error('\"message\" must be a nonempty string');\n      }\n      return new EthereumProviderError(code, message, data);\n    }\n  }\n};\n// Internal\nfunction getEthJsonRpcError(code, arg) {\n  const [message, data] = parseOpts(arg);\n  return new EthereumRpcError(code, message || getMessageFromCode(code), data);\n}\nfunction getEthProviderError(code, arg) {\n  const [message, data] = parseOpts(arg);\n  return new EthereumProviderError(code, message || getMessageFromCode(code), data);\n}\nfunction parseOpts(arg) {\n  if (arg) {\n    if (typeof arg === 'string') {\n      return [arg];\n    } else if (typeof arg === 'object' && !Array.isArray(arg)) {\n      const {\n        message,\n        data\n      } = arg;\n      if (message && typeof message !== 'string') {\n        throw new Error('Must specify string message.');\n      }\n      return [message || undefined, data];\n    }\n  }\n  return [];\n}\nclass EthereumRpcError extends Error {\n  constructor(code, message, data) {\n    if (!Number.isInteger(code)) {\n      throw new Error('\"code\" must be an integer.');\n    }\n    if (!message || typeof message !== 'string') {\n      throw new Error('\"message\" must be a nonempty string.');\n    }\n    super(message);\n    this.code = code;\n    if (data !== undefined) {\n      this.data = data;\n    }\n  }\n}\nclass EthereumProviderError extends EthereumRpcError {\n  /**\n   * Create an Ethereum Provider JSON-RPC error.\n   * `code` must be an integer in the 1000 <= 4999 range.\n   */\n  constructor(code, message, data) {\n    if (!isValidEthProviderCode(code)) {\n      throw new Error('\"code\" must be an integer such that: 1000 <= code <= 4999');\n    }\n    super(code, message, data);\n  }\n}\nfunction isValidEthProviderCode(code) {\n  return Number.isInteger(code) && code >= 1000 && code <= 4999;\n}\n//# sourceMappingURL=errors.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}