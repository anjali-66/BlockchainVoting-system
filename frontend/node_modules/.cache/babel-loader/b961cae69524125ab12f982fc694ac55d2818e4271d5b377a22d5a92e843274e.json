{"ast":null,"code":"import { DEFAULT_RPC_URL, getThirdwebDomains } from \"../utils/domains.js\";\nimport { isThirdwebUrl } from \"../utils/fetch.js\";\nimport { withCache } from \"../utils/promise/withCache.js\";\n/**\n * @internal Exported for tests\n */\nexport const CUSTOM_CHAIN_MAP = new Map();\n/**\n * Defines a chain with the given options.\n * @param options The options for the chain.\n * @returns The defined chain.\n * @example\n * Just pass the chain ID to connect to:\n * ```ts\n * const chain = defineChain(1);\n * ```\n * Or pass your own RPC or custom values:\n * ```ts\n * const chain = defineChain({\n *  id: 1,\n *  rpc: \"https://my-rpc.com\",\n *  nativeCurrency: {\n *    name: \"Ether\",\n *    symbol: \"ETH\",\n *    decimals: 18,\n *  },\n * });\n * ```\n * @chain\n */\nexport function defineChain(options) {\n  const RPC_URL = getThirdwebDomains().rpc;\n  if (typeof options === \"number\") {\n    return {\n      id: options,\n      rpc: `https://${options}.${RPC_URL}`\n    };\n  }\n  if (isViemChain(options)) {\n    return convertViemChain(options);\n  }\n  if (isLegacyChain(options)) {\n    return convertLegacyChain(options);\n  }\n  // otherwise if it's not a viem chain, continue\n  let rpc = options.rpc;\n  if (!rpc) {\n    rpc = `https://${options.id}.${RPC_URL}`;\n  }\n  const chain = {\n    ...options,\n    rpc\n  };\n  CUSTOM_CHAIN_MAP.set(options.id, chain);\n  return chain;\n}\n/**\n * @internal\n */\nexport function cacheChains(chains) {\n  for (const chain of chains) {\n    CUSTOM_CHAIN_MAP.set(chain.id, chain);\n  }\n}\n/**\n * @internal\n */\nexport function getCachedChain(id) {\n  if (CUSTOM_CHAIN_MAP.has(id)) {\n    return CUSTOM_CHAIN_MAP.get(id);\n  }\n  const RPC_URL = getThirdwebDomains().rpc;\n  const chain = {\n    id: id,\n    rpc: `https://${id}.${RPC_URL}`\n  };\n  return chain;\n}\n/**\n * @internal\n */\nexport function getCachedChainIfExists(id) {\n  return CUSTOM_CHAIN_MAP.get(id);\n}\nfunction isLegacyChain(chain) {\n  return \"rpc\" in chain && Array.isArray(chain.rpc) && \"slug\" in chain;\n}\n/**\n * @internal\n */\nexport function convertLegacyChain(legacyChain) {\n  const RPC_URL = getThirdwebDomains().rpc;\n  return {\n    id: legacyChain.chainId,\n    name: legacyChain.name,\n    rpc: legacyChain.rpc[0] ?? `https://${legacyChain.chainId}.${RPC_URL}`,\n    blockExplorers: legacyChain?.explorers?.map(explorer => ({\n      name: explorer.name,\n      url: explorer.url,\n      apiUrl: explorer.url\n    })),\n    nativeCurrency: {\n      name: legacyChain.nativeCurrency.name,\n      symbol: legacyChain.nativeCurrency.symbol,\n      decimals: legacyChain.nativeCurrency.decimals\n    },\n    faucets: legacyChain.faucets ? [...legacyChain.faucets] : undefined,\n    icon: legacyChain.icon,\n    testnet: legacyChain.testnet ? true : undefined\n  };\n}\nfunction isViemChain(chain) {\n  return \"rpcUrls\" in chain && !(\"rpc\" in chain);\n}\nfunction convertViemChain(viemChain) {\n  const RPC_URL = getThirdwebDomains().rpc;\n  return {\n    id: viemChain.id,\n    name: viemChain.name,\n    nativeCurrency: {\n      name: viemChain.nativeCurrency.name,\n      symbol: viemChain.nativeCurrency.symbol,\n      decimals: viemChain.nativeCurrency.decimals\n    },\n    rpc: viemChain.rpcUrls.default.http[0] ?? `https://${viemChain.id}.${RPC_URL}`,\n    blockExplorers: viemChain?.blockExplorers ? Object.values(viemChain?.blockExplorers).map(explorer => {\n      return {\n        name: explorer.name,\n        url: explorer.url,\n        apiUrl: explorer.apiUrl\n      };\n    }) : [],\n    testnet: viemChain.testnet ? true : undefined\n  };\n}\n/**\n * Retrieves the RPC URL for the specified chain.\n * If a custom RPC URL is defined in the options, it will be used.\n * Otherwise, a thirdweb RPC URL will be constructed using the chain ID and client ID.\n * @param options - The options object containing the chain and client information.\n * @returns The RPC URL for the specified chain.\n * @example\n * ```ts\n * import { getRpcUrlForChain } from \"thirdweb/chains\";\n * const rpcUrl = getRpcUrlForChain({ chain: 1, client });\n * console.log(rpcUrl); // \"https://1.rpc.thirdweb.com/...\n * ```\n * @chain\n */\nexport function getRpcUrlForChain(options) {\n  const baseRpcUrl = getThirdwebDomains().rpc;\n  // if the chain is just a number, construct the RPC URL using the chain ID and client ID\n  if (typeof options.chain === \"number\") {\n    return `https://${options.chain}.${baseRpcUrl}/${options.client.clientId}`;\n  }\n  const {\n    rpc\n  } = options.chain;\n  // add on the client ID to the RPC URL if it's a thirdweb URL\n  if (isThirdwebUrl(rpc)) {\n    const rpcUrl = new URL(options.chain.rpc.replace(DEFAULT_RPC_URL, baseRpcUrl));\n    rpcUrl.pathname = `/${options.client.clientId}`;\n    return rpcUrl.toString();\n  }\n  return rpc;\n}\n/**\n * Retrieves the chain symbol from the provided chain.\n * @param chain - The chain.\n * @returns The chain symbol.\n * @internal\n */\nexport async function getChainSymbol(chain) {\n  if (!chain.nativeCurrency?.symbol) {\n    return getChainMetadata(chain).then(data => data.nativeCurrency.symbol).catch(() => {\n      // if we fail to fetch the chain data, return \"ETH\" as a fallback\n      return \"ETH\";\n    });\n  }\n  // if we have a symbol, return it\n  return chain.nativeCurrency.symbol;\n}\n/**\n * Retrieves the number of decimals for the native currency of a given chain.\n * If the chain is not recognized or the data cannot be fetched, it returns a fallback value of 18.\n * @param chain - The chain for which to retrieve the decimals.\n * @returns A promise that resolves to the number of decimals for the native currency of the chain.\n * @internal\n */\nexport async function getChainDecimals(chain) {\n  if (!chain.nativeCurrency?.decimals) {\n    return getChainMetadata(chain).then(data => data.nativeCurrency.decimals).catch(() => {\n      // if we fail to fetch the chain data, return 18 as a fallback (most likely it's 18)\n      return 18;\n    });\n  }\n  // if we have decimals, return it\n  return chain.nativeCurrency.decimals;\n}\n/**\n * Retrieves the name of the native currency for a given chain.\n * If the chain object does not have a native currency name, it attempts to fetch the chain data and retrieve the native currency name from there.\n * If fetching the chain data fails, it falls back to returning \"ETH\".\n * @param chain The chain object for which to retrieve the native currency name.\n * @returns A promise that resolves to the native currency name.\n * @internal\n */\nexport async function getChainNativeCurrencyName(chain) {\n  if (!chain.nativeCurrency?.name) {\n    return getChainMetadata(chain).then(data => data.nativeCurrency.name).catch(() => {\n      // if we fail to fetch the chain data, return 18 as a fallback (most likely it's 18)\n      return \"ETH\";\n    });\n  }\n  // if we have a name, return it\n  return chain.nativeCurrency.name;\n}\n/**\n * Retrieves chain data for a given chain.\n * @param chain - The chain object containing the chain ID.\n * @returns A Promise that resolves to the chain data.\n * @throws If there is an error fetching the chain data.\n * @example\n * ```ts\n * const chain = defineChain({ id: 1 });\n * const chainData = await getChainMetadata(chain);\n * console.log(chainData);\n * ```\n * @chain\n */\nexport function getChainMetadata(chain) {\n  const chainId = chain.id;\n  return withCache(async () => {\n    try {\n      const res = await fetch(`https://api.thirdweb.com/v1/chains/${chainId}`);\n      if (!res.ok) {\n        res.body?.cancel();\n        throw new Error(`Failed to fetch chain data for chainId ${chainId}`);\n      }\n      const response = await res.json();\n      if (response.error) {\n        throw new Error(`Failed to fetch chain data for chainId ${chainId}`);\n      }\n      if (!response.data) {\n        throw new Error(`Failed to fetch chain data for chainId ${chainId}`);\n      }\n      const data = response.data;\n      return createChainMetadata(chain, data);\n    } catch {\n      return createChainMetadata(chain);\n    }\n  }, {\n    cacheKey: `chain:${chainId}`,\n    cacheTime: 5 * 60 * 1000 // 5 minutes\n  });\n}\n/**\n * Convert `ApiChain` to `Chain` object\n * @internal\n */\nexport function convertApiChainToChain(apiChain) {\n  return {\n    id: apiChain.chainId,\n    name: apiChain.name,\n    rpc: apiChain.rpc[0] || \"\",\n    testnet: apiChain.testnet === true ? true : undefined,\n    nativeCurrency: apiChain.nativeCurrency,\n    blockExplorers: apiChain.explorers?.map(explorer => {\n      return {\n        name: explorer.name,\n        url: explorer.url,\n        apiUrl: explorer.url\n      };\n    }),\n    faucets: apiChain.faucets ? [...apiChain.faucets] : undefined,\n    icon: apiChain.icon\n  };\n}\nfunction createChainMetadata(chain, data) {\n  const nativeCurrency = chain.nativeCurrency ? {\n    ...data?.nativeCurrency,\n    ...chain.nativeCurrency\n  } : data?.nativeCurrency;\n  return {\n    ...data,\n    name: chain.name || data?.name || \"\",\n    chainId: chain.id || data?.chainId || -1,\n    rpc: chain.rpc ? [chain.rpc] : data?.rpc || [\"\"],\n    testnet: chain.testnet || data?.testnet || false,\n    nativeCurrency: {\n      name: nativeCurrency?.name || \"\",\n      symbol: nativeCurrency?.symbol || \"\",\n      decimals: nativeCurrency?.decimals || 18\n    },\n    icon: chain.icon || data?.icon,\n    chain: data?.chain || chain.name || \"\",\n    shortName: data?.shortName || chain.name || \"\",\n    slug: data?.slug || chain.name || \"\",\n    explorers: chain.blockExplorers?.map(e => ({\n      name: e.name,\n      url: e.url,\n      standard: \"EIP3091\"\n    })) || data?.explorers,\n    stackType: data?.stackType || \"\"\n  };\n}\n//# sourceMappingURL=utils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}