{"ast":null,"code":"import { decodeErrorResult } from \"viem\";\nimport { parseEventLogs } from \"../../../event/actions/parse-logs.js\";\nimport { userOperationRevertReasonEvent } from \"../../../extensions/erc4337/__generated__/IEntryPoint/events/UserOperationRevertReason.js\";\nimport { postOpRevertReasonEvent } from \"../../../extensions/erc4337/__generated__/IEntryPoint_v07/events/PostOpRevertReason.js\";\nimport { hexToBigInt } from \"../../../utils/encoding/hex.js\";\nimport { getClientFetch } from \"../../../utils/fetch.js\";\nimport { stringify } from \"../../../utils/json.js\";\nimport { formatUserOperationReceipt } from \"../types.js\";\nimport { ENTRYPOINT_ADDRESS_v0_6, MANAGED_ACCOUNT_GAS_BUFFER, getDefaultBundlerUrl } from \"./constants.js\";\nimport { hexlifyUserOp } from \"./utils.js\";\n/**\n * Bundle a user operation.\n * @param args - The options for bundling a user operation.\n * @returns The bundle hash of the user operation.\n * @example\n * ```ts\n * import { bundleUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOpHash = await bundleUserOp({\n *  userOp,\n *  options,\n * });\n * ```\n * @walletUtils\n */\nexport async function bundleUserOp(args) {\n  return sendBundlerRequest({\n    ...args,\n    operation: \"eth_sendUserOperation\",\n    params: [hexlifyUserOp(args.userOp), args.options.entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6]\n  });\n}\n/**\n * Estimate the gas cost of a user operation.\n * @param args - The options for estimating the gas cost of a user operation.\n * @returns The estimated gas cost of the user operation.\n * @example\n * ```ts\n * import { estimateUserOpGas } from \"thirdweb/wallets/smart\";\n *\n * const gasCost = await estimateUserOpGas({\n *  userOp,\n *  options,\n * });\n * ```\n * @walletUtils\n */\nexport async function estimateUserOpGas(args, stateOverrides) {\n  const res = await sendBundlerRequest({\n    ...args,\n    operation: \"eth_estimateUserOperationGas\",\n    params: [hexlifyUserOp(args.userOp), args.options.entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6, stateOverrides ?? {}]\n  });\n  // add gas buffer for managed account factory delegate calls\n  return {\n    preVerificationGas: hexToBigInt(res.preVerificationGas),\n    verificationGas: res.verificationGas !== undefined ? hexToBigInt(res.verificationGas) : undefined,\n    verificationGasLimit: hexToBigInt(res.verificationGasLimit),\n    callGasLimit: hexToBigInt(res.callGasLimit) + MANAGED_ACCOUNT_GAS_BUFFER,\n    paymasterVerificationGasLimit: res.paymasterVerificationGasLimit !== undefined ? hexToBigInt(res.paymasterVerificationGasLimit) : undefined,\n    paymasterPostOpGasLimit: res.paymasterPostOpGasLimit !== undefined ? hexToBigInt(res.paymasterPostOpGasLimit) : undefined\n  };\n}\n/**\n * Get the gas fees of a user operation.\n * @param args - The options for getting the gas price of a user operation.\n * @returns The gas price of the user operation.\n * @example\n * ```ts\n * import { getUserOpGasPrice } from \"thirdweb/wallets/smart\";\n *\n * const fees = await getUserOpGasPrice({\n *  options,\n * });\n * ```\n * @walletUtils\n */\nexport async function getUserOpGasFees(args) {\n  const res = await sendBundlerRequest({\n    ...args,\n    operation: \"thirdweb_getUserOperationGasPrice\",\n    params: []\n  });\n  return {\n    maxPriorityFeePerGas: hexToBigInt(res.maxPriorityFeePerGas),\n    maxFeePerGas: hexToBigInt(res.maxFeePerGas)\n  };\n}\n/**\n * Get the receipt of a user operation.\n * @param args - The options for getting the receipt of a user operation.\n * @returns The receipt of the user operation.\n * @example\n * ```ts\n * import { getUserOpReceipt } from \"thirdweb/wallets/smart\";\n *\n * const receipt = await getUserOpReceipt({\n *  client,\n *  chain,\n *  userOpHash,\n * });\n * ```\n * @walletUtils\n */\nexport async function getUserOpReceipt(args) {\n  const res = await getUserOpReceiptRaw(args);\n  if (!res) {\n    return undefined;\n  }\n  if (res.success === false) {\n    // parse revert reason\n    const logs = parseEventLogs({\n      events: [userOperationRevertReasonEvent(), postOpRevertReasonEvent()],\n      logs: res.logs\n    });\n    const revertReason = logs[0]?.args?.revertReason;\n    if (!revertReason) {\n      throw new Error(`UserOp failed at txHash: ${res.receipt.transactionHash}`);\n    }\n    const revertMsg = decodeErrorResult({\n      data: revertReason\n    });\n    throw new Error(`UserOp failed with reason: '${revertMsg.args.join(\",\")}' at txHash: ${res.receipt.transactionHash}`);\n  }\n  return res.receipt;\n}\n/**\n * Get the receipt of a user operation.\n * @param args - The options for getting the receipt of a user operation.\n * @returns The raw receipt of the user operation.\n * @example\n * ```ts\n * import { getUserOpReceiptRaw } from \"thirdweb/wallets/smart\";\n *\n * const receipt = await getUserOpReceiptRaw({\n *  client,\n *  chain,\n *  userOpHash,\n * });\n * ```\n * @walletUtils\n */\nexport async function getUserOpReceiptRaw(args) {\n  const res = await sendBundlerRequest({\n    options: args,\n    operation: \"eth_getUserOperationReceipt\",\n    params: [args.userOpHash]\n  });\n  if (!res) {\n    return undefined;\n  }\n  return formatUserOperationReceipt(res);\n}\n/**\n * @internal\n */\nexport async function getZkPaymasterData(args) {\n  const res = await sendBundlerRequest({\n    options: args.options,\n    operation: \"zk_paymasterData\",\n    params: [args.transaction]\n  });\n  return {\n    paymaster: res.paymaster,\n    paymasterInput: res.paymasterInput\n  };\n}\nexport async function broadcastZkTransaction(args) {\n  const res = await sendBundlerRequest({\n    options: args.options,\n    operation: \"zk_broadcastTransaction\",\n    params: [{\n      ...args.transaction,\n      signedTransaction: args.signedTransaction\n    }]\n  });\n  return {\n    transactionHash: res.transactionHash\n  };\n}\nasync function sendBundlerRequest(args) {\n  const {\n    options,\n    operation,\n    params\n  } = args;\n  const bundlerUrl = options.bundlerUrl ?? getDefaultBundlerUrl(options.chain);\n  const fetchWithHeaders = getClientFetch(options.client);\n  const response = await fetchWithHeaders(bundlerUrl, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: stringify({\n      jsonrpc: \"2.0\",\n      id: 1,\n      method: operation,\n      params\n    })\n  });\n  const res = await response.json();\n  if (!response.ok || res.error) {\n    let error = res.error || response.statusText;\n    if (typeof error === \"object\") {\n      error = stringify(error);\n    }\n    const code = res.code || \"UNKNOWN\";\n    throw new Error(`${operation} error: ${error}\nStatus: ${response.status}\nCode: ${code}`);\n  }\n  return res.result;\n}\n//# sourceMappingURL=bundler.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}