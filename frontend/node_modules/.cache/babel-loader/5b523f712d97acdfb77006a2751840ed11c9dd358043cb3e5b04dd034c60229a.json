{"ast":null,"code":"import { sleep } from \"../utils/sleep.js\";\nimport { eth_blockNumber } from \"./actions/eth_blockNumber.js\";\nimport { getRpcClient } from \"./rpc.js\";\nconst MAX_POLL_DELAY = 5000; // 5 seconds\nconst DEFAULT_POLL_DELAY = 1000; // 1 second\nconst MIN_POLL_DELAY = 500; // 500 milliseconds\nconst DEFAULT_OVERPOLL_RATIO = 2; // poll twice as often as the average block time by default\nconst SLIDING_WINDOW_SIZE = 10; // always keep track of the last 10 block times\n/**\n * TODO: document\n * @internal\n */\nfunction getAverageBlockTime(blockTimes) {\n  // left-pad the blocktimes Array with the DEFAULT_POLL_DELAY\n  while (blockTimes.length < SLIDING_WINDOW_SIZE) {\n    blockTimes.unshift(DEFAULT_POLL_DELAY);\n  }\n  const sum = blockTimes.reduce((acc, blockTime) => acc + blockTime, 0);\n  return sum / blockTimes.length;\n}\n/**\n * TODO: document\n * @internal\n */\nfunction createBlockNumberPoller(client, chain, overPollRatio, onError) {\n  let subscribers = [];\n  let blockTimesWindow = [];\n  let isActive = false;\n  let lastBlockNumber;\n  let lastBlockAt;\n  const rpcRequest = getRpcClient({\n    client,\n    chain\n  });\n  /**\n   * TODO: document\n   * @internal\n   */\n  async function poll() {\n    // stop polling if there are no more subscriptions\n    if (!isActive) {\n      return;\n    }\n    try {\n      const blockNumber = await eth_blockNumber(rpcRequest);\n      if (!lastBlockNumber || blockNumber > lastBlockNumber) {\n        let newBlockNumbers = [];\n        if (lastBlockNumber) {\n          for (let i = lastBlockNumber + 1n; i <= blockNumber; i++) {\n            newBlockNumbers.push(BigInt(i));\n          }\n        } else {\n          newBlockNumbers = [blockNumber];\n        }\n        lastBlockNumber = blockNumber;\n        const currentTime = new Date().getTime();\n        if (lastBlockAt) {\n          // if we skipped a block we need to adjust the block time down to that level\n          const blockTime = (currentTime - lastBlockAt) / newBlockNumbers.length;\n          blockTimesWindow.push(blockTime);\n          blockTimesWindow = blockTimesWindow.slice(-SLIDING_WINDOW_SIZE);\n        }\n        lastBlockAt = currentTime;\n        // for all new blockNumbers...\n        for (const b of newBlockNumbers) {\n          // ... call all current subscribers\n          for (const subscriberCallback of subscribers) {\n            subscriberCallback(b);\n          }\n        }\n      }\n    } catch (err) {\n      if (onError) {\n        onError(err);\n      } else {\n        console.error(`[watchBlockNumber]: Failed to poll for latest block number: ${err}`);\n      }\n    }\n    const currentApproximateBlockTime = getAverageBlockTime(blockTimesWindow);\n    // make sure we never poll faster than our minimum poll delay or slower than our maximum poll delay\n    const pollDelay = Math.max(MIN_POLL_DELAY, Math.min(MAX_POLL_DELAY, Math.max(MIN_POLL_DELAY, currentApproximateBlockTime)));\n    // sleep for the pollDelay for this chain (divided by the overPollRatio, which defaults to 2)\n    await sleep(pollDelay / (overPollRatio ?? DEFAULT_OVERPOLL_RATIO));\n    // poll again\n    poll();\n  }\n  // return the \"subscribe\" function\n  return function subscribe(callBack, initialBlockNumber) {\n    subscribers.push(callBack);\n    // if we are currently not active -> start polling\n    if (!isActive) {\n      lastBlockNumber = initialBlockNumber;\n      isActive = true;\n      poll();\n    }\n    // return the \"unsubscribe\" function (meaning the caller can unsubscribe)\n    return function unSubscribe() {\n      // filter out the callback from the subscribers\n      subscribers = subscribers.filter(fn => fn !== callBack);\n      // if the new subscribers Array is empty (aka we were the last subscriber) -> stop polling\n      if (subscribers.length === 0) {\n        lastBlockNumber = undefined;\n        lastBlockAt = undefined;\n        isActive = false;\n      }\n    };\n  };\n}\nconst existingPollers = new Map();\n/**\n * Watches the block number for a specific chain.\n * @param opts - The options for watching the block number.\n * @returns The unwatch function.\n * @example\n * ```ts\n * import { watchBlockNumber } from \"thirdweb\";\n * const unwatch = watchBlockNumber({\n *  client,\n *  chainId,\n *  onNewBlockNumber: (blockNumber) => {\n *    // do something with the block number\n *  },\n *  onError: (err) => {\n *    // do something if getting the block number fails\n *  },\n * });\n *\n * // later stop watching\n * unwatch();\n * ```\n * @rpc\n */\nexport function watchBlockNumber(opts) {\n  const {\n    client,\n    chain,\n    onNewBlockNumber,\n    overPollRatio,\n    latestBlockNumber,\n    onError\n  } = opts;\n  const chainId = chain.id;\n  // if we already have a poller for this chainId -> use it.\n  let poller = existingPollers.get(chainId);\n  // otherwise create a new poller\n  if (!poller) {\n    poller = createBlockNumberPoller(client, chain, overPollRatio, onError);\n    // and store it for later use\n    existingPollers.set(chainId, poller);\n  }\n  // subscribe to the poller and return the unSubscribe function to the caller\n  return poller(onNewBlockNumber, latestBlockNumber);\n}\n//# sourceMappingURL=watchBlockNumber.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}